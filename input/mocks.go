package input

import (
	"github.com/btcsuite/btcd/txscript"
	"github.com/btcsuite/btcd/wire"
	"github.com/stretchr/testify/mock"
)

// MockInput implements the `Input` interface and is used by other packages for
// mock testing.
type MockInput struct {
	mock.Mock
}

// Compile time assertion that MockInput implements Input.
var _ Input = (*MockInput)(nil)

// Outpoint returns the reference to the output being spent, used to construct
// the corresponding transaction input.
func (m *MockInput) OutPoint() *wire.OutPoint {
	args := m.Called()
	op := args.Get(0)

	if op == nil {
		return nil
	}

	return op.(*wire.OutPoint)
}

// RequiredTxOut returns a non-nil TxOut if input commits to a certain
// transaction output. This is used in the SINGLE|ANYONECANPAY case to make
// sure any presigned input is still valid by including the output.
func (m *MockInput) RequiredTxOut() *wire.TxOut {
	args := m.Called()
	txOut := args.Get(0)

	if txOut == nil {
		return nil
	}

	return txOut.(*wire.TxOut)
}

// RequiredLockTime returns whether this input commits to a tx locktime that
// must be used in the transaction including it.
func (m *MockInput) RequiredLockTime() (uint32, bool) {
	args := m.Called()

	return args.Get(0).(uint32), args.Bool(1)
}

// WitnessType returns an enum specifying the type of witness that must be
// generated in order to spend this output.
func (m *MockInput) WitnessType() WitnessType {
	args := m.Called()

	wt := args.Get(0)
	if wt == nil {
		return nil
	}

	return wt.(WitnessType)
}

// SignDesc returns a reference to a spendable output's sign descriptor, which
// is used during signing to compute a valid witness that spends this output.
func (m *MockInput) SignDesc() *SignDescriptor {
	args := m.Called()

	sd := args.Get(0)
	if sd == nil {
		return nil
	}

	return sd.(*SignDescriptor)
}

// CraftInputScript returns a valid set of input scripts allowing this output
// to be spent. The returns input scripts should target the input at location
// txIndex within the passed transaction. The input scripts generated by this
// method support spending p2wkh, p2wsh, and also nested p2sh outputs.
func (m *MockInput) CraftInputScript(signer Signer, txn *wire.MsgTx,
	hashCache *txscript.TxSigHashes,
	prevOutputFetcher txscript.PrevOutputFetcher,
	txinIdx int) (*Script, error) {

	args := m.Called(signer, txn, hashCache, prevOutputFetcher, txinIdx)

	s := args.Get(0)
	if s == nil {
		return nil, args.Error(1)
	}

	return s.(*Script), args.Error(1)
}

// BlocksToMaturity returns the relative timelock, as a number of blocks, that
// must be built on top of the confirmation height before the output can be
// spent. For non-CSV locked inputs this is always zero.
func (m *MockInput) BlocksToMaturity() uint32 {
	args := m.Called()

	return args.Get(0).(uint32)
}

// HeightHint returns the minimum height at which a confirmed spending tx can
// occur.
func (m *MockInput) HeightHint() uint32 {
	args := m.Called()

	return args.Get(0).(uint32)
}

// UnconfParent returns information about a possibly unconfirmed parent tx.
func (m *MockInput) UnconfParent() *TxInfo {
	args := m.Called()

	info := args.Get(0)
	if info == nil {
		return nil
	}

	return info.(*TxInfo)
}

// MockWitnessType implements the `WitnessType` interface and is used by other
// packages for mock testing.
type MockWitnessType struct {
	mock.Mock
}

// Compile time assertion that MockWitnessType implements WitnessType.
var _ WitnessType = (*MockWitnessType)(nil)

// String returns a human readable version of the WitnessType.
func (m *MockWitnessType) String() string {
	args := m.Called()

	return args.String(0)
}

// WitnessGenerator will return a WitnessGenerator function that an output uses
// to generate the witness and optionally the sigScript for a sweep
// transaction.
func (m *MockWitnessType) WitnessGenerator(signer Signer,
	descriptor *SignDescriptor) WitnessGenerator {

	args := m.Called()

	return args.Get(0).(WitnessGenerator)
}

// SizeUpperBound returns the maximum length of the witness of this WitnessType
// if it would be included in a tx. It also returns if the output itself is a
// nested p2sh output, if so then we need to take into account the extra
// sigScript data size.
func (m *MockWitnessType) SizeUpperBound() (int, bool, error) {
	args := m.Called()

	return args.Int(0), args.Bool(1), args.Error(2)
}

// AddWeightEstimation adds the estimated size of the witness in bytes to the
// given weight estimator.
func (m *MockWitnessType) AddWeightEstimation(e *TxWeightEstimator) error {
	args := m.Called()

	return args.Error(0)
}
