// Code generated by protoc-gen-go. DO NOT EDIT.
// source: chainrpc/chainnotifier.proto

/*
Package chainrpc is a generated protocol buffer package.

It is generated from these files:
	chainrpc/chainnotifier.proto

It has these top-level messages:
	ConfRequest
	ConfDetails
	Reorg
	ConfEvent
	Outpoint
	SpendRequest
	SpendDetails
	SpendEvent
	BlockEpoch
*/
package chainrpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ConfRequest struct {
	//
	// The transaction hash for which we should request a confirmation notification
	// for. If set to a hash of all zeros, then the confirmation notification will
	// be requested for the script instead.
	Txid []byte `protobuf:"bytes,1,opt,name=txid,proto3" json:"txid,omitempty"`
	//
	// An output script within a transaction with the hash above which will be used
	// by light clients to match block filters. If the transaction hash is set to a
	// hash of all zeros, then a confirmation notification will be requested for
	// this script instead.
	Script []byte `protobuf:"bytes,2,opt,name=script,proto3" json:"script,omitempty"`
	//
	// The number of desired confirmations the transaction/output script should
	// reach before dispatching a confirmation notification.
	NumConfs uint32 `protobuf:"varint,3,opt,name=num_confs,json=numConfs" json:"num_confs,omitempty"`
	//
	// The earliest height in the chain for which the transaction/output script
	// could have been included in a block. This should in most cases be set to the
	// broadcast height of the transaction/output script.
	HeightHint uint32 `protobuf:"varint,4,opt,name=height_hint,json=heightHint" json:"height_hint,omitempty"`
}

func (m *ConfRequest) Reset()                    { *m = ConfRequest{} }
func (m *ConfRequest) String() string            { return proto.CompactTextString(m) }
func (*ConfRequest) ProtoMessage()               {}
func (*ConfRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ConfRequest) GetTxid() []byte {
	if m != nil {
		return m.Txid
	}
	return nil
}

func (m *ConfRequest) GetScript() []byte {
	if m != nil {
		return m.Script
	}
	return nil
}

func (m *ConfRequest) GetNumConfs() uint32 {
	if m != nil {
		return m.NumConfs
	}
	return 0
}

func (m *ConfRequest) GetHeightHint() uint32 {
	if m != nil {
		return m.HeightHint
	}
	return 0
}

type ConfDetails struct {
	// The raw bytes of the confirmed transaction.
	RawTx []byte `protobuf:"bytes,1,opt,name=raw_tx,json=rawTx,proto3" json:"raw_tx,omitempty"`
	// The hash of the block in which the confirmed transaction was included in.
	BlockHash []byte `protobuf:"bytes,2,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	// The height of the block in which the confirmed transaction was included in.
	BlockHeight uint32 `protobuf:"varint,3,opt,name=block_height,json=blockHeight" json:"block_height,omitempty"`
	// The index of the confirmed transaction within the transaction.
	TxIndex uint32 `protobuf:"varint,4,opt,name=tx_index,json=txIndex" json:"tx_index,omitempty"`
}

func (m *ConfDetails) Reset()                    { *m = ConfDetails{} }
func (m *ConfDetails) String() string            { return proto.CompactTextString(m) }
func (*ConfDetails) ProtoMessage()               {}
func (*ConfDetails) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ConfDetails) GetRawTx() []byte {
	if m != nil {
		return m.RawTx
	}
	return nil
}

func (m *ConfDetails) GetBlockHash() []byte {
	if m != nil {
		return m.BlockHash
	}
	return nil
}

func (m *ConfDetails) GetBlockHeight() uint32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *ConfDetails) GetTxIndex() uint32 {
	if m != nil {
		return m.TxIndex
	}
	return 0
}

type Reorg struct {
}

func (m *Reorg) Reset()                    { *m = Reorg{} }
func (m *Reorg) String() string            { return proto.CompactTextString(m) }
func (*Reorg) ProtoMessage()               {}
func (*Reorg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type ConfEvent struct {
	// Types that are valid to be assigned to Event:
	//	*ConfEvent_Conf
	//	*ConfEvent_Reorg
	Event isConfEvent_Event `protobuf_oneof:"event"`
}

func (m *ConfEvent) Reset()                    { *m = ConfEvent{} }
func (m *ConfEvent) String() string            { return proto.CompactTextString(m) }
func (*ConfEvent) ProtoMessage()               {}
func (*ConfEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isConfEvent_Event interface{ isConfEvent_Event() }

type ConfEvent_Conf struct {
	Conf *ConfDetails `protobuf:"bytes,1,opt,name=conf,oneof"`
}
type ConfEvent_Reorg struct {
	Reorg *Reorg `protobuf:"bytes,2,opt,name=reorg,oneof"`
}

func (*ConfEvent_Conf) isConfEvent_Event()  {}
func (*ConfEvent_Reorg) isConfEvent_Event() {}

func (m *ConfEvent) GetEvent() isConfEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *ConfEvent) GetConf() *ConfDetails {
	if x, ok := m.GetEvent().(*ConfEvent_Conf); ok {
		return x.Conf
	}
	return nil
}

func (m *ConfEvent) GetReorg() *Reorg {
	if x, ok := m.GetEvent().(*ConfEvent_Reorg); ok {
		return x.Reorg
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ConfEvent) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ConfEvent_OneofMarshaler, _ConfEvent_OneofUnmarshaler, _ConfEvent_OneofSizer, []interface{}{
		(*ConfEvent_Conf)(nil),
		(*ConfEvent_Reorg)(nil),
	}
}

func _ConfEvent_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ConfEvent)
	// event
	switch x := m.Event.(type) {
	case *ConfEvent_Conf:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Conf); err != nil {
			return err
		}
	case *ConfEvent_Reorg:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Reorg); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ConfEvent.Event has unexpected type %T", x)
	}
	return nil
}

func _ConfEvent_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ConfEvent)
	switch tag {
	case 1: // event.conf
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConfDetails)
		err := b.DecodeMessage(msg)
		m.Event = &ConfEvent_Conf{msg}
		return true, err
	case 2: // event.reorg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Reorg)
		err := b.DecodeMessage(msg)
		m.Event = &ConfEvent_Reorg{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ConfEvent_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ConfEvent)
	// event
	switch x := m.Event.(type) {
	case *ConfEvent_Conf:
		s := proto.Size(x.Conf)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ConfEvent_Reorg:
		s := proto.Size(x.Reorg)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Outpoint struct {
	// The hash of the transaction.
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// The index of the output within the transaction.
	Index uint32 `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
}

func (m *Outpoint) Reset()                    { *m = Outpoint{} }
func (m *Outpoint) String() string            { return proto.CompactTextString(m) }
func (*Outpoint) ProtoMessage()               {}
func (*Outpoint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Outpoint) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *Outpoint) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

type SpendRequest struct {
	//
	// The outpoint for which we should request a spend notification for. If set to
	// a zero outpoint, then the spend notification will be requested for the
	// script instead.
	Outpoint *Outpoint `protobuf:"bytes,1,opt,name=outpoint" json:"outpoint,omitempty"`
	//
	// The output script for the outpoint above. This will be used by light clients
	// to match block filters. If the outpoint is set to a zero outpoint, then a
	// spend notification will be requested for this script instead.
	Script []byte `protobuf:"bytes,2,opt,name=script,proto3" json:"script,omitempty"`
	//
	// The earliest height in the chain for which the outpoint/output script could
	// have been spent. This should in most cases be set to the broadcast height of
	// the outpoint/output script.
	HeightHint uint32 `protobuf:"varint,3,opt,name=height_hint,json=heightHint" json:"height_hint,omitempty"`
}

func (m *SpendRequest) Reset()                    { *m = SpendRequest{} }
func (m *SpendRequest) String() string            { return proto.CompactTextString(m) }
func (*SpendRequest) ProtoMessage()               {}
func (*SpendRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SpendRequest) GetOutpoint() *Outpoint {
	if m != nil {
		return m.Outpoint
	}
	return nil
}

func (m *SpendRequest) GetScript() []byte {
	if m != nil {
		return m.Script
	}
	return nil
}

func (m *SpendRequest) GetHeightHint() uint32 {
	if m != nil {
		return m.HeightHint
	}
	return 0
}

type SpendDetails struct {
	// The outpoint was that spent.
	SpendingOutpoint *Outpoint `protobuf:"bytes,1,opt,name=spending_outpoint,json=spendingOutpoint" json:"spending_outpoint,omitempty"`
	// The raw bytes of the spending transaction.
	RawSpendingTx []byte `protobuf:"bytes,2,opt,name=raw_spending_tx,json=rawSpendingTx,proto3" json:"raw_spending_tx,omitempty"`
	// The hash of the spending transaction.
	SpendingTxHash []byte `protobuf:"bytes,3,opt,name=spending_tx_hash,json=spendingTxHash,proto3" json:"spending_tx_hash,omitempty"`
	// The input of the spending transaction that fulfilled the spend request.
	SpendingInputIndex uint32 `protobuf:"varint,4,opt,name=spending_input_index,json=spendingInputIndex" json:"spending_input_index,omitempty"`
	// The height at which the spending transaction was included in a block.
	SpendingHeight uint32 `protobuf:"varint,5,opt,name=spending_height,json=spendingHeight" json:"spending_height,omitempty"`
}

func (m *SpendDetails) Reset()                    { *m = SpendDetails{} }
func (m *SpendDetails) String() string            { return proto.CompactTextString(m) }
func (*SpendDetails) ProtoMessage()               {}
func (*SpendDetails) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *SpendDetails) GetSpendingOutpoint() *Outpoint {
	if m != nil {
		return m.SpendingOutpoint
	}
	return nil
}

func (m *SpendDetails) GetRawSpendingTx() []byte {
	if m != nil {
		return m.RawSpendingTx
	}
	return nil
}

func (m *SpendDetails) GetSpendingTxHash() []byte {
	if m != nil {
		return m.SpendingTxHash
	}
	return nil
}

func (m *SpendDetails) GetSpendingInputIndex() uint32 {
	if m != nil {
		return m.SpendingInputIndex
	}
	return 0
}

func (m *SpendDetails) GetSpendingHeight() uint32 {
	if m != nil {
		return m.SpendingHeight
	}
	return 0
}

type SpendEvent struct {
	// Types that are valid to be assigned to Event:
	//	*SpendEvent_Spend
	//	*SpendEvent_Reorg
	Event isSpendEvent_Event `protobuf_oneof:"event"`
}

func (m *SpendEvent) Reset()                    { *m = SpendEvent{} }
func (m *SpendEvent) String() string            { return proto.CompactTextString(m) }
func (*SpendEvent) ProtoMessage()               {}
func (*SpendEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isSpendEvent_Event interface{ isSpendEvent_Event() }

type SpendEvent_Spend struct {
	Spend *SpendDetails `protobuf:"bytes,1,opt,name=spend,oneof"`
}
type SpendEvent_Reorg struct {
	Reorg *Reorg `protobuf:"bytes,2,opt,name=reorg,oneof"`
}

func (*SpendEvent_Spend) isSpendEvent_Event() {}
func (*SpendEvent_Reorg) isSpendEvent_Event() {}

func (m *SpendEvent) GetEvent() isSpendEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *SpendEvent) GetSpend() *SpendDetails {
	if x, ok := m.GetEvent().(*SpendEvent_Spend); ok {
		return x.Spend
	}
	return nil
}

func (m *SpendEvent) GetReorg() *Reorg {
	if x, ok := m.GetEvent().(*SpendEvent_Reorg); ok {
		return x.Reorg
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SpendEvent) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SpendEvent_OneofMarshaler, _SpendEvent_OneofUnmarshaler, _SpendEvent_OneofSizer, []interface{}{
		(*SpendEvent_Spend)(nil),
		(*SpendEvent_Reorg)(nil),
	}
}

func _SpendEvent_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SpendEvent)
	// event
	switch x := m.Event.(type) {
	case *SpendEvent_Spend:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Spend); err != nil {
			return err
		}
	case *SpendEvent_Reorg:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Reorg); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SpendEvent.Event has unexpected type %T", x)
	}
	return nil
}

func _SpendEvent_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SpendEvent)
	switch tag {
	case 1: // event.spend
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SpendDetails)
		err := b.DecodeMessage(msg)
		m.Event = &SpendEvent_Spend{msg}
		return true, err
	case 2: // event.reorg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Reorg)
		err := b.DecodeMessage(msg)
		m.Event = &SpendEvent_Reorg{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SpendEvent_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SpendEvent)
	// event
	switch x := m.Event.(type) {
	case *SpendEvent_Spend:
		s := proto.Size(x.Spend)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SpendEvent_Reorg:
		s := proto.Size(x.Reorg)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type BlockEpoch struct {
	// The hash of the block.
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// The height of the block.
	Height uint32 `protobuf:"varint,2,opt,name=height" json:"height,omitempty"`
}

func (m *BlockEpoch) Reset()                    { *m = BlockEpoch{} }
func (m *BlockEpoch) String() string            { return proto.CompactTextString(m) }
func (*BlockEpoch) ProtoMessage()               {}
func (*BlockEpoch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *BlockEpoch) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *BlockEpoch) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func init() {
	proto.RegisterType((*ConfRequest)(nil), "chainrpc.ConfRequest")
	proto.RegisterType((*ConfDetails)(nil), "chainrpc.ConfDetails")
	proto.RegisterType((*Reorg)(nil), "chainrpc.Reorg")
	proto.RegisterType((*ConfEvent)(nil), "chainrpc.ConfEvent")
	proto.RegisterType((*Outpoint)(nil), "chainrpc.Outpoint")
	proto.RegisterType((*SpendRequest)(nil), "chainrpc.SpendRequest")
	proto.RegisterType((*SpendDetails)(nil), "chainrpc.SpendDetails")
	proto.RegisterType((*SpendEvent)(nil), "chainrpc.SpendEvent")
	proto.RegisterType((*BlockEpoch)(nil), "chainrpc.BlockEpoch")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ChainNotifier service

type ChainNotifierClient interface {
	//
	// RegisterConfirmationsNtfn is a synchronous response-streaming RPC that
	// registers an intent for a client to be notified once a confirmation request
	// has reached its required number of confirmations on-chain.
	//
	// A client can specify whether the confirmation request should be for a
	// particular transaction by its hash or for an output script by specifying a
	// zero hash.
	RegisterConfirmationsNtfn(ctx context.Context, in *ConfRequest, opts ...grpc.CallOption) (ChainNotifier_RegisterConfirmationsNtfnClient, error)
	//
	// RegisterSpendNtfn is a synchronous response-streaming RPC that registers an
	// intent for a client to be notification once a spend request has been spent
	// by a transaction that has confirmed on-chain.
	//
	// A client can specify whether the spend request should be for a particular
	// outpoint  or for an output script by specifying a zero outpoint.
	RegisterSpendNtfn(ctx context.Context, in *SpendRequest, opts ...grpc.CallOption) (ChainNotifier_RegisterSpendNtfnClient, error)
	//
	// RegisterBlockEpochNtfn is a synchronous response-streaming RPC that
	// registers an intent for a client to be notified of blocks in the chain. The
	// stream will return a hash and height tuple of a block for each new/stale
	// block in the chain. It is the client's responsibility to determine whether
	// the tuple returned is for a new or stale block in the chain.
	//
	// A client can also request a historical backlog of blocks from a particular
	// point. This allows clients to be idempotent by ensuring that they do not
	// missing processing a single block within the chain.
	RegisterBlockEpochNtfn(ctx context.Context, in *BlockEpoch, opts ...grpc.CallOption) (ChainNotifier_RegisterBlockEpochNtfnClient, error)
}

type chainNotifierClient struct {
	cc *grpc.ClientConn
}

func NewChainNotifierClient(cc *grpc.ClientConn) ChainNotifierClient {
	return &chainNotifierClient{cc}
}

func (c *chainNotifierClient) RegisterConfirmationsNtfn(ctx context.Context, in *ConfRequest, opts ...grpc.CallOption) (ChainNotifier_RegisterConfirmationsNtfnClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ChainNotifier_serviceDesc.Streams[0], c.cc, "/chainrpc.ChainNotifier/RegisterConfirmationsNtfn", opts...)
	if err != nil {
		return nil, err
	}
	x := &chainNotifierRegisterConfirmationsNtfnClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ChainNotifier_RegisterConfirmationsNtfnClient interface {
	Recv() (*ConfEvent, error)
	grpc.ClientStream
}

type chainNotifierRegisterConfirmationsNtfnClient struct {
	grpc.ClientStream
}

func (x *chainNotifierRegisterConfirmationsNtfnClient) Recv() (*ConfEvent, error) {
	m := new(ConfEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *chainNotifierClient) RegisterSpendNtfn(ctx context.Context, in *SpendRequest, opts ...grpc.CallOption) (ChainNotifier_RegisterSpendNtfnClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ChainNotifier_serviceDesc.Streams[1], c.cc, "/chainrpc.ChainNotifier/RegisterSpendNtfn", opts...)
	if err != nil {
		return nil, err
	}
	x := &chainNotifierRegisterSpendNtfnClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ChainNotifier_RegisterSpendNtfnClient interface {
	Recv() (*SpendEvent, error)
	grpc.ClientStream
}

type chainNotifierRegisterSpendNtfnClient struct {
	grpc.ClientStream
}

func (x *chainNotifierRegisterSpendNtfnClient) Recv() (*SpendEvent, error) {
	m := new(SpendEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *chainNotifierClient) RegisterBlockEpochNtfn(ctx context.Context, in *BlockEpoch, opts ...grpc.CallOption) (ChainNotifier_RegisterBlockEpochNtfnClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ChainNotifier_serviceDesc.Streams[2], c.cc, "/chainrpc.ChainNotifier/RegisterBlockEpochNtfn", opts...)
	if err != nil {
		return nil, err
	}
	x := &chainNotifierRegisterBlockEpochNtfnClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ChainNotifier_RegisterBlockEpochNtfnClient interface {
	Recv() (*BlockEpoch, error)
	grpc.ClientStream
}

type chainNotifierRegisterBlockEpochNtfnClient struct {
	grpc.ClientStream
}

func (x *chainNotifierRegisterBlockEpochNtfnClient) Recv() (*BlockEpoch, error) {
	m := new(BlockEpoch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ChainNotifier service

type ChainNotifierServer interface {
	//
	// RegisterConfirmationsNtfn is a synchronous response-streaming RPC that
	// registers an intent for a client to be notified once a confirmation request
	// has reached its required number of confirmations on-chain.
	//
	// A client can specify whether the confirmation request should be for a
	// particular transaction by its hash or for an output script by specifying a
	// zero hash.
	RegisterConfirmationsNtfn(*ConfRequest, ChainNotifier_RegisterConfirmationsNtfnServer) error
	//
	// RegisterSpendNtfn is a synchronous response-streaming RPC that registers an
	// intent for a client to be notification once a spend request has been spent
	// by a transaction that has confirmed on-chain.
	//
	// A client can specify whether the spend request should be for a particular
	// outpoint  or for an output script by specifying a zero outpoint.
	RegisterSpendNtfn(*SpendRequest, ChainNotifier_RegisterSpendNtfnServer) error
	//
	// RegisterBlockEpochNtfn is a synchronous response-streaming RPC that
	// registers an intent for a client to be notified of blocks in the chain. The
	// stream will return a hash and height tuple of a block for each new/stale
	// block in the chain. It is the client's responsibility to determine whether
	// the tuple returned is for a new or stale block in the chain.
	//
	// A client can also request a historical backlog of blocks from a particular
	// point. This allows clients to be idempotent by ensuring that they do not
	// missing processing a single block within the chain.
	RegisterBlockEpochNtfn(*BlockEpoch, ChainNotifier_RegisterBlockEpochNtfnServer) error
}

func RegisterChainNotifierServer(s *grpc.Server, srv ChainNotifierServer) {
	s.RegisterService(&_ChainNotifier_serviceDesc, srv)
}

func _ChainNotifier_RegisterConfirmationsNtfn_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConfRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChainNotifierServer).RegisterConfirmationsNtfn(m, &chainNotifierRegisterConfirmationsNtfnServer{stream})
}

type ChainNotifier_RegisterConfirmationsNtfnServer interface {
	Send(*ConfEvent) error
	grpc.ServerStream
}

type chainNotifierRegisterConfirmationsNtfnServer struct {
	grpc.ServerStream
}

func (x *chainNotifierRegisterConfirmationsNtfnServer) Send(m *ConfEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _ChainNotifier_RegisterSpendNtfn_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SpendRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChainNotifierServer).RegisterSpendNtfn(m, &chainNotifierRegisterSpendNtfnServer{stream})
}

type ChainNotifier_RegisterSpendNtfnServer interface {
	Send(*SpendEvent) error
	grpc.ServerStream
}

type chainNotifierRegisterSpendNtfnServer struct {
	grpc.ServerStream
}

func (x *chainNotifierRegisterSpendNtfnServer) Send(m *SpendEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _ChainNotifier_RegisterBlockEpochNtfn_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockEpoch)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChainNotifierServer).RegisterBlockEpochNtfn(m, &chainNotifierRegisterBlockEpochNtfnServer{stream})
}

type ChainNotifier_RegisterBlockEpochNtfnServer interface {
	Send(*BlockEpoch) error
	grpc.ServerStream
}

type chainNotifierRegisterBlockEpochNtfnServer struct {
	grpc.ServerStream
}

func (x *chainNotifierRegisterBlockEpochNtfnServer) Send(m *BlockEpoch) error {
	return x.ServerStream.SendMsg(m)
}

var _ChainNotifier_serviceDesc = grpc.ServiceDesc{
	ServiceName: "chainrpc.ChainNotifier",
	HandlerType: (*ChainNotifierServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RegisterConfirmationsNtfn",
			Handler:       _ChainNotifier_RegisterConfirmationsNtfn_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RegisterSpendNtfn",
			Handler:       _ChainNotifier_RegisterSpendNtfn_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RegisterBlockEpochNtfn",
			Handler:       _ChainNotifier_RegisterBlockEpochNtfn_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "chainrpc/chainnotifier.proto",
}

func init() { proto.RegisterFile("chainrpc/chainnotifier.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 574 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0x4f, 0x6f, 0x13, 0x3f,
	0x10, 0xed, 0xb6, 0xdd, 0xfc, 0x99, 0x24, 0xbf, 0xb4, 0xfe, 0xa5, 0x51, 0x5a, 0x40, 0x94, 0x3d,
	0xd0, 0x48, 0x48, 0x21, 0x0a, 0x1c, 0xb8, 0x21, 0x35, 0x14, 0x25, 0x97, 0x22, 0x6d, 0x7b, 0x5f,
	0x6d, 0x37, 0x4e, 0xd6, 0xd0, 0xd8, 0x8b, 0xed, 0x90, 0xbd, 0xf2, 0x69, 0xf9, 0x12, 0x1c, 0x90,
	0x67, 0xed, 0x4d, 0x1a, 0x8a, 0x84, 0xb8, 0x79, 0x66, 0xde, 0x3e, 0xbf, 0xf1, 0x7b, 0x09, 0x3c,
	0x4d, 0xd2, 0x98, 0x71, 0x99, 0x25, 0xaf, 0xf1, 0xc0, 0x85, 0x66, 0x73, 0x46, 0xe5, 0x20, 0x93,
	0x42, 0x0b, 0x52, 0x73, 0xd3, 0x60, 0x0d, 0x8d, 0xb1, 0xe0, 0xf3, 0x90, 0x7e, 0x5d, 0x51, 0xa5,
	0x09, 0x81, 0x43, 0x9d, 0xb3, 0x59, 0xcf, 0x3b, 0xf7, 0xfa, 0xcd, 0x10, 0xcf, 0xa4, 0x0b, 0x15,
	0x95, 0x48, 0x96, 0xe9, 0xde, 0x3e, 0x76, 0x6d, 0x45, 0x9e, 0x40, 0x9d, 0xaf, 0x96, 0x51, 0x22,
	0xf8, 0x5c, 0xf5, 0x0e, 0xce, 0xbd, 0x7e, 0x2b, 0xac, 0xf1, 0xd5, 0xd2, 0xd0, 0x29, 0xf2, 0x1c,
	0x1a, 0x29, 0x65, 0x8b, 0x54, 0x47, 0x29, 0xe3, 0xba, 0x77, 0x88, 0x63, 0x28, 0x5a, 0x13, 0xc6,
	0x75, 0xf0, 0xdd, 0x2b, 0x6e, 0xfe, 0x40, 0x75, 0xcc, 0xee, 0x15, 0x39, 0x81, 0x8a, 0x8c, 0xd7,
	0x91, 0xce, 0xed, 0xdd, 0xbe, 0x8c, 0xd7, 0xb7, 0x39, 0x79, 0x06, 0x70, 0x77, 0x2f, 0x92, 0x2f,
	0x51, 0x1a, 0xab, 0xd4, 0x0a, 0xa8, 0x63, 0x67, 0x12, 0xab, 0x94, 0xbc, 0x80, 0xa6, 0x1d, 0x23,
	0xb3, 0x95, 0xd1, 0x28, 0x00, 0xd8, 0x22, 0xa7, 0x50, 0xd3, 0x79, 0xc4, 0xf8, 0x8c, 0xe6, 0x56,
	0x46, 0x55, 0xe7, 0x53, 0x53, 0x06, 0x55, 0xf0, 0x43, 0x2a, 0xe4, 0x22, 0xf8, 0x0c, 0x75, 0xa3,
	0xe5, 0xea, 0x1b, 0xe5, 0x9a, 0xbc, 0x82, 0x43, 0xb3, 0x13, 0xea, 0x68, 0x8c, 0x4e, 0x06, 0xee,
	0xad, 0x06, 0x5b, 0x72, 0x27, 0x7b, 0x21, 0x82, 0xc8, 0x05, 0xf8, 0xd2, 0x50, 0xa0, 0xb4, 0xc6,
	0xa8, 0xbd, 0x41, 0x23, 0xf3, 0x64, 0x2f, 0x2c, 0xe6, 0x97, 0x55, 0xf0, 0xa9, 0xa1, 0x0f, 0xde,
	0x42, 0xed, 0xd3, 0x4a, 0x67, 0x82, 0x71, 0x7c, 0x6e, 0xdc, 0xcb, 0x3e, 0xb7, 0x39, 0x93, 0x0e,
	0xf8, 0x85, 0xd8, 0x7d, 0x14, 0x5b, 0x14, 0xc1, 0x1a, 0x9a, 0x37, 0x19, 0xe5, 0x33, 0x67, 0xd4,
	0x00, 0x6a, 0xc2, 0xb2, 0x58, 0xa1, 0x64, 0x73, 0xb5, 0xe3, 0x0f, 0x4b, 0xcc, 0x1f, 0x4d, 0xdc,
	0xf1, 0xe9, 0xe0, 0x37, 0x9f, 0x7e, 0x7a, 0xf6, 0x66, 0x67, 0xd4, 0x7b, 0x38, 0x56, 0xa6, 0x66,
	0x7c, 0x11, 0xfd, 0x85, 0x84, 0x23, 0x07, 0x2e, 0x97, 0x7e, 0x09, 0x6d, 0xe3, 0x74, 0x49, 0xa2,
	0x73, 0xab, 0xa9, 0x25, 0xe3, 0xf5, 0x8d, 0xed, 0xde, 0xe6, 0xa4, 0x0f, 0x47, 0x5b, 0x98, 0x22,
	0x00, 0x07, 0x08, 0xfc, 0x4f, 0x95, 0x28, 0x4c, 0xc1, 0x10, 0x3a, 0x25, 0x92, 0xf1, 0x6c, 0xa5,
	0x1f, 0xd8, 0x4d, 0xdc, 0x6c, 0x6a, 0x46, 0xe8, 0x3c, 0xb9, 0x80, 0x76, 0xf9, 0x85, 0x8d, 0x8e,
	0x8f, 0xe0, 0x92, 0xba, 0x48, 0x4f, 0xc0, 0x01, 0x50, 0x52, 0x11, 0x8d, 0x01, 0xf8, 0x38, 0xb7,
	0xfb, 0x76, 0x37, 0xfb, 0x6e, 0x3f, 0x91, 0x31, 0x1d, 0x61, 0xff, 0x90, 0x8e, 0x77, 0x00, 0x97,
	0x26, 0xbc, 0x57, 0x99, 0x48, 0xd2, 0x47, 0xf3, 0xd1, 0x85, 0x8a, 0x55, 0x5c, 0x04, 0xc4, 0x56,
	0xa3, 0x1f, 0x1e, 0xb4, 0xc6, 0x86, 0xfe, 0xda, 0xfe, 0xd6, 0xc9, 0x14, 0x4e, 0x43, 0xba, 0x60,
	0x4a, 0x53, 0x69, 0xa2, 0xcb, 0xe4, 0x32, 0xd6, 0x4c, 0x70, 0x75, 0xad, 0xe7, 0x9c, 0xec, 0xe4,
	0xda, 0xe6, 0xea, 0xec, 0xff, 0x87, 0x6d, 0x5c, 0x7b, 0xe8, 0x91, 0x31, 0x1c, 0x3b, 0x2a, 0xdc,
	0x14, 0x29, 0x76, 0xd7, 0x77, 0x1c, 0x9d, 0x9d, 0xbe, 0x23, 0xf9, 0x08, 0x5d, 0x47, 0xb2, 0xd9,
	0x11, 0x99, 0xb6, 0xbe, 0xd8, 0x4c, 0xce, 0x1e, 0xed, 0x0e, 0xbd, 0xbb, 0x0a, 0xfe, 0x89, 0xbd,
	0xf9, 0x15, 0x00, 0x00, 0xff, 0xff, 0x65, 0xe6, 0xc2, 0xe4, 0xe4, 0x04, 0x00, 0x00,
}
