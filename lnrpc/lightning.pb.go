// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.12
// source: lightning.proto

package lnrpc

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type OutputScriptType int32

const (
	OutputScriptType_SCRIPT_TYPE_PUBKEY_HASH            OutputScriptType = 0
	OutputScriptType_SCRIPT_TYPE_SCRIPT_HASH            OutputScriptType = 1
	OutputScriptType_SCRIPT_TYPE_WITNESS_V0_PUBKEY_HASH OutputScriptType = 2
	OutputScriptType_SCRIPT_TYPE_WITNESS_V0_SCRIPT_HASH OutputScriptType = 3
	OutputScriptType_SCRIPT_TYPE_PUBKEY                 OutputScriptType = 4
	OutputScriptType_SCRIPT_TYPE_MULTISIG               OutputScriptType = 5
	OutputScriptType_SCRIPT_TYPE_NULLDATA               OutputScriptType = 6
	OutputScriptType_SCRIPT_TYPE_NON_STANDARD           OutputScriptType = 7
	OutputScriptType_SCRIPT_TYPE_WITNESS_UNKNOWN        OutputScriptType = 8
	OutputScriptType_SCRIPT_TYPE_WITNESS_V1_TAPROOT     OutputScriptType = 9
)

// Enum value maps for OutputScriptType.
var (
	OutputScriptType_name = map[int32]string{
		0: "SCRIPT_TYPE_PUBKEY_HASH",
		1: "SCRIPT_TYPE_SCRIPT_HASH",
		2: "SCRIPT_TYPE_WITNESS_V0_PUBKEY_HASH",
		3: "SCRIPT_TYPE_WITNESS_V0_SCRIPT_HASH",
		4: "SCRIPT_TYPE_PUBKEY",
		5: "SCRIPT_TYPE_MULTISIG",
		6: "SCRIPT_TYPE_NULLDATA",
		7: "SCRIPT_TYPE_NON_STANDARD",
		8: "SCRIPT_TYPE_WITNESS_UNKNOWN",
		9: "SCRIPT_TYPE_WITNESS_V1_TAPROOT",
	}
	OutputScriptType_value = map[string]int32{
		"SCRIPT_TYPE_PUBKEY_HASH":            0,
		"SCRIPT_TYPE_SCRIPT_HASH":            1,
		"SCRIPT_TYPE_WITNESS_V0_PUBKEY_HASH": 2,
		"SCRIPT_TYPE_WITNESS_V0_SCRIPT_HASH": 3,
		"SCRIPT_TYPE_PUBKEY":                 4,
		"SCRIPT_TYPE_MULTISIG":               5,
		"SCRIPT_TYPE_NULLDATA":               6,
		"SCRIPT_TYPE_NON_STANDARD":           7,
		"SCRIPT_TYPE_WITNESS_UNKNOWN":        8,
		"SCRIPT_TYPE_WITNESS_V1_TAPROOT":     9,
	}
)

func (x OutputScriptType) Enum() *OutputScriptType {
	p := new(OutputScriptType)
	*p = x
	return p
}

func (x OutputScriptType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OutputScriptType) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[0].Descriptor()
}

func (OutputScriptType) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[0]
}

func (x OutputScriptType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OutputScriptType.Descriptor instead.
func (OutputScriptType) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{0}
}

type CoinSelectionStrategy int32

const (
	// Use the coin selection strategy defined in the global configuration
	// (lnd.conf).
	CoinSelectionStrategy_STRATEGY_USE_GLOBAL_CONFIG CoinSelectionStrategy = 0
	// Select the largest available coins first during coin selection.
	CoinSelectionStrategy_STRATEGY_LARGEST CoinSelectionStrategy = 1
	// Randomly select the available coins during coin selection.
	CoinSelectionStrategy_STRATEGY_RANDOM CoinSelectionStrategy = 2
)

// Enum value maps for CoinSelectionStrategy.
var (
	CoinSelectionStrategy_name = map[int32]string{
		0: "STRATEGY_USE_GLOBAL_CONFIG",
		1: "STRATEGY_LARGEST",
		2: "STRATEGY_RANDOM",
	}
	CoinSelectionStrategy_value = map[string]int32{
		"STRATEGY_USE_GLOBAL_CONFIG": 0,
		"STRATEGY_LARGEST":           1,
		"STRATEGY_RANDOM":            2,
	}
)

func (x CoinSelectionStrategy) Enum() *CoinSelectionStrategy {
	p := new(CoinSelectionStrategy)
	*p = x
	return p
}

func (x CoinSelectionStrategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CoinSelectionStrategy) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[1].Descriptor()
}

func (CoinSelectionStrategy) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[1]
}

func (x CoinSelectionStrategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CoinSelectionStrategy.Descriptor instead.
func (CoinSelectionStrategy) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{1}
}

// `AddressType` has to be one of:
//
// - `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)
// - `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)
// - `p2tr`: Pay to taproot pubkey (`TAPROOT_PUBKEY` = 4)
type AddressType int32

const (
	AddressType_WITNESS_PUBKEY_HASH        AddressType = 0
	AddressType_NESTED_PUBKEY_HASH         AddressType = 1
	AddressType_UNUSED_WITNESS_PUBKEY_HASH AddressType = 2
	AddressType_UNUSED_NESTED_PUBKEY_HASH  AddressType = 3
	AddressType_TAPROOT_PUBKEY             AddressType = 4
	AddressType_UNUSED_TAPROOT_PUBKEY      AddressType = 5
)

// Enum value maps for AddressType.
var (
	AddressType_name = map[int32]string{
		0: "WITNESS_PUBKEY_HASH",
		1: "NESTED_PUBKEY_HASH",
		2: "UNUSED_WITNESS_PUBKEY_HASH",
		3: "UNUSED_NESTED_PUBKEY_HASH",
		4: "TAPROOT_PUBKEY",
		5: "UNUSED_TAPROOT_PUBKEY",
	}
	AddressType_value = map[string]int32{
		"WITNESS_PUBKEY_HASH":        0,
		"NESTED_PUBKEY_HASH":         1,
		"UNUSED_WITNESS_PUBKEY_HASH": 2,
		"UNUSED_NESTED_PUBKEY_HASH":  3,
		"TAPROOT_PUBKEY":             4,
		"UNUSED_TAPROOT_PUBKEY":      5,
	}
)

func (x AddressType) Enum() *AddressType {
	p := new(AddressType)
	*p = x
	return p
}

func (x AddressType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AddressType) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[2].Descriptor()
}

func (AddressType) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[2]
}

func (x AddressType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AddressType.Descriptor instead.
func (AddressType) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{2}
}

type CommitmentType int32

const (
	// Returned when the commitment type isn't known or unavailable.
	CommitmentType_UNKNOWN_COMMITMENT_TYPE CommitmentType = 0
	// A channel using the legacy commitment format having tweaked to_remote
	// keys.
	CommitmentType_LEGACY CommitmentType = 1
	// A channel that uses the modern commitment format where the key in the
	// output of the remote party does not change each state. This makes back
	// up and recovery easier as when the channel is closed, the funds go
	// directly to that key.
	CommitmentType_STATIC_REMOTE_KEY CommitmentType = 2
	// A channel that uses a commitment format that has anchor outputs on the
	// commitments, allowing fee bumping after a force close transaction has
	// been broadcast.
	CommitmentType_ANCHORS CommitmentType = 3
	// A channel that uses a commitment type that builds upon the anchors
	// commitment format, but in addition requires a CLTV clause to spend outputs
	// paying to the channel initiator. This is intended for use on leased channels
	// to guarantee that the channel initiator has no incentives to close a leased
	// channel before its maturity date.
	CommitmentType_SCRIPT_ENFORCED_LEASE CommitmentType = 4
	// A channel that uses musig2 for the funding output, and the new tapscript
	// features where relevant.
	CommitmentType_SIMPLE_TAPROOT CommitmentType = 5
	// Identical to the SIMPLE_TAPROOT channel type, but with extra functionality.
	// This channel type also commits to additional meta data in the tapscript
	// leaves for the scripts in a channel.
	CommitmentType_SIMPLE_TAPROOT_OVERLAY CommitmentType = 6
	// A channel that uses v3 transactions with zero-fee commitment and HTLC
	// transactions. Fee bumping is done via CPFP on the shared P2A (pay-to-anchor)
	// output. This commitment type follows the zero_fee_commitments feature as
	// defined in BOLT PR #1228.
	CommitmentType_ZERO_FEE CommitmentType = 7
)

// Enum value maps for CommitmentType.
var (
	CommitmentType_name = map[int32]string{
		0: "UNKNOWN_COMMITMENT_TYPE",
		1: "LEGACY",
		2: "STATIC_REMOTE_KEY",
		3: "ANCHORS",
		4: "SCRIPT_ENFORCED_LEASE",
		5: "SIMPLE_TAPROOT",
		6: "SIMPLE_TAPROOT_OVERLAY",
		7: "ZERO_FEE",
	}
	CommitmentType_value = map[string]int32{
		"UNKNOWN_COMMITMENT_TYPE": 0,
		"LEGACY":                  1,
		"STATIC_REMOTE_KEY":       2,
		"ANCHORS":                 3,
		"SCRIPT_ENFORCED_LEASE":   4,
		"SIMPLE_TAPROOT":          5,
		"SIMPLE_TAPROOT_OVERLAY":  6,
		"ZERO_FEE":                7,
	}
)

func (x CommitmentType) Enum() *CommitmentType {
	p := new(CommitmentType)
	*p = x
	return p
}

func (x CommitmentType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CommitmentType) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[3].Descriptor()
}

func (CommitmentType) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[3]
}

func (x CommitmentType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CommitmentType.Descriptor instead.
func (CommitmentType) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{3}
}

type Initiator int32

const (
	Initiator_INITIATOR_UNKNOWN Initiator = 0
	Initiator_INITIATOR_LOCAL   Initiator = 1
	Initiator_INITIATOR_REMOTE  Initiator = 2
	Initiator_INITIATOR_BOTH    Initiator = 3
)

// Enum value maps for Initiator.
var (
	Initiator_name = map[int32]string{
		0: "INITIATOR_UNKNOWN",
		1: "INITIATOR_LOCAL",
		2: "INITIATOR_REMOTE",
		3: "INITIATOR_BOTH",
	}
	Initiator_value = map[string]int32{
		"INITIATOR_UNKNOWN": 0,
		"INITIATOR_LOCAL":   1,
		"INITIATOR_REMOTE":  2,
		"INITIATOR_BOTH":    3,
	}
)

func (x Initiator) Enum() *Initiator {
	p := new(Initiator)
	*p = x
	return p
}

func (x Initiator) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Initiator) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[4].Descriptor()
}

func (Initiator) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[4]
}

func (x Initiator) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Initiator.Descriptor instead.
func (Initiator) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{4}
}

type ResolutionType int32

const (
	ResolutionType_TYPE_UNKNOWN ResolutionType = 0
	// We resolved an anchor output.
	ResolutionType_ANCHOR ResolutionType = 1
	// We are resolving an incoming htlc on chain. This if this htlc is
	// claimed, we swept the incoming htlc with the preimage. If it is timed
	// out, our peer swept the timeout path.
	ResolutionType_INCOMING_HTLC ResolutionType = 2
	// We are resolving an outgoing htlc on chain. If this htlc is claimed,
	// the remote party swept the htlc with the preimage. If it is timed out,
	// we swept it with the timeout path.
	ResolutionType_OUTGOING_HTLC ResolutionType = 3
	// We force closed and need to sweep our time locked commitment output.
	ResolutionType_COMMIT ResolutionType = 4
)

// Enum value maps for ResolutionType.
var (
	ResolutionType_name = map[int32]string{
		0: "TYPE_UNKNOWN",
		1: "ANCHOR",
		2: "INCOMING_HTLC",
		3: "OUTGOING_HTLC",
		4: "COMMIT",
	}
	ResolutionType_value = map[string]int32{
		"TYPE_UNKNOWN":  0,
		"ANCHOR":        1,
		"INCOMING_HTLC": 2,
		"OUTGOING_HTLC": 3,
		"COMMIT":        4,
	}
)

func (x ResolutionType) Enum() *ResolutionType {
	p := new(ResolutionType)
	*p = x
	return p
}

func (x ResolutionType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ResolutionType) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[5].Descriptor()
}

func (ResolutionType) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[5]
}

func (x ResolutionType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ResolutionType.Descriptor instead.
func (ResolutionType) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{5}
}

type ResolutionOutcome int32

const (
	// Outcome unknown.
	ResolutionOutcome_OUTCOME_UNKNOWN ResolutionOutcome = 0
	// An output was claimed on chain.
	ResolutionOutcome_CLAIMED ResolutionOutcome = 1
	// An output was left unclaimed on chain.
	ResolutionOutcome_UNCLAIMED ResolutionOutcome = 2
	// ResolverOutcomeAbandoned indicates that an output that we did not
	// claim on chain, for example an anchor that we did not sweep and a
	// third party claimed on chain, or a htlc that we could not decode
	// so left unclaimed.
	ResolutionOutcome_ABANDONED ResolutionOutcome = 3
	// If we force closed our channel, our htlcs need to be claimed in two
	// stages. This outcome represents the broadcast of a timeout or success
	// transaction for this two stage htlc claim.
	ResolutionOutcome_FIRST_STAGE ResolutionOutcome = 4
	// A htlc was timed out on chain.
	ResolutionOutcome_TIMEOUT ResolutionOutcome = 5
)

// Enum value maps for ResolutionOutcome.
var (
	ResolutionOutcome_name = map[int32]string{
		0: "OUTCOME_UNKNOWN",
		1: "CLAIMED",
		2: "UNCLAIMED",
		3: "ABANDONED",
		4: "FIRST_STAGE",
		5: "TIMEOUT",
	}
	ResolutionOutcome_value = map[string]int32{
		"OUTCOME_UNKNOWN": 0,
		"CLAIMED":         1,
		"UNCLAIMED":       2,
		"ABANDONED":       3,
		"FIRST_STAGE":     4,
		"TIMEOUT":         5,
	}
)

func (x ResolutionOutcome) Enum() *ResolutionOutcome {
	p := new(ResolutionOutcome)
	*p = x
	return p
}

func (x ResolutionOutcome) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ResolutionOutcome) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[6].Descriptor()
}

func (ResolutionOutcome) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[6]
}

func (x ResolutionOutcome) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ResolutionOutcome.Descriptor instead.
func (ResolutionOutcome) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{6}
}

type NodeMetricType int32

const (
	NodeMetricType_UNKNOWN                NodeMetricType = 0
	NodeMetricType_BETWEENNESS_CENTRALITY NodeMetricType = 1
)

// Enum value maps for NodeMetricType.
var (
	NodeMetricType_name = map[int32]string{
		0: "UNKNOWN",
		1: "BETWEENNESS_CENTRALITY",
	}
	NodeMetricType_value = map[string]int32{
		"UNKNOWN":                0,
		"BETWEENNESS_CENTRALITY": 1,
	}
)

func (x NodeMetricType) Enum() *NodeMetricType {
	p := new(NodeMetricType)
	*p = x
	return p
}

func (x NodeMetricType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NodeMetricType) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[7].Descriptor()
}

func (NodeMetricType) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[7]
}

func (x NodeMetricType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NodeMetricType.Descriptor instead.
func (NodeMetricType) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{7}
}

type InvoiceHTLCState int32

const (
	InvoiceHTLCState_ACCEPTED InvoiceHTLCState = 0
	InvoiceHTLCState_SETTLED  InvoiceHTLCState = 1
	InvoiceHTLCState_CANCELED InvoiceHTLCState = 2
)

// Enum value maps for InvoiceHTLCState.
var (
	InvoiceHTLCState_name = map[int32]string{
		0: "ACCEPTED",
		1: "SETTLED",
		2: "CANCELED",
	}
	InvoiceHTLCState_value = map[string]int32{
		"ACCEPTED": 0,
		"SETTLED":  1,
		"CANCELED": 2,
	}
)

func (x InvoiceHTLCState) Enum() *InvoiceHTLCState {
	p := new(InvoiceHTLCState)
	*p = x
	return p
}

func (x InvoiceHTLCState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (InvoiceHTLCState) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[8].Descriptor()
}

func (InvoiceHTLCState) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[8]
}

func (x InvoiceHTLCState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use InvoiceHTLCState.Descriptor instead.
func (InvoiceHTLCState) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{8}
}

type PaymentFailureReason int32

const (
	// Payment isn't failed (yet).
	PaymentFailureReason_FAILURE_REASON_NONE PaymentFailureReason = 0
	// There are more routes to try, but the payment timeout was exceeded.
	PaymentFailureReason_FAILURE_REASON_TIMEOUT PaymentFailureReason = 1
	// All possible routes were tried and failed permanently. Or were no
	// routes to the destination at all.
	PaymentFailureReason_FAILURE_REASON_NO_ROUTE PaymentFailureReason = 2
	// A non-recoverable error has occured.
	PaymentFailureReason_FAILURE_REASON_ERROR PaymentFailureReason = 3
	// Payment details incorrect (unknown hash, invalid amt or
	// invalid final cltv delta)
	PaymentFailureReason_FAILURE_REASON_INCORRECT_PAYMENT_DETAILS PaymentFailureReason = 4
	// Insufficient local balance.
	PaymentFailureReason_FAILURE_REASON_INSUFFICIENT_BALANCE PaymentFailureReason = 5
	// The payment was canceled.
	PaymentFailureReason_FAILURE_REASON_CANCELED PaymentFailureReason = 6
)

// Enum value maps for PaymentFailureReason.
var (
	PaymentFailureReason_name = map[int32]string{
		0: "FAILURE_REASON_NONE",
		1: "FAILURE_REASON_TIMEOUT",
		2: "FAILURE_REASON_NO_ROUTE",
		3: "FAILURE_REASON_ERROR",
		4: "FAILURE_REASON_INCORRECT_PAYMENT_DETAILS",
		5: "FAILURE_REASON_INSUFFICIENT_BALANCE",
		6: "FAILURE_REASON_CANCELED",
	}
	PaymentFailureReason_value = map[string]int32{
		"FAILURE_REASON_NONE":                      0,
		"FAILURE_REASON_TIMEOUT":                   1,
		"FAILURE_REASON_NO_ROUTE":                  2,
		"FAILURE_REASON_ERROR":                     3,
		"FAILURE_REASON_INCORRECT_PAYMENT_DETAILS": 4,
		"FAILURE_REASON_INSUFFICIENT_BALANCE":      5,
		"FAILURE_REASON_CANCELED":                  6,
	}
)

func (x PaymentFailureReason) Enum() *PaymentFailureReason {
	p := new(PaymentFailureReason)
	*p = x
	return p
}

func (x PaymentFailureReason) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PaymentFailureReason) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[9].Descriptor()
}

func (PaymentFailureReason) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[9]
}

func (x PaymentFailureReason) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PaymentFailureReason.Descriptor instead.
func (PaymentFailureReason) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{9}
}

type FeatureBit int32

const (
	FeatureBit_DATALOSS_PROTECT_REQ        FeatureBit = 0
	FeatureBit_DATALOSS_PROTECT_OPT        FeatureBit = 1
	FeatureBit_INITIAL_ROUING_SYNC         FeatureBit = 3
	FeatureBit_UPFRONT_SHUTDOWN_SCRIPT_REQ FeatureBit = 4
	FeatureBit_UPFRONT_SHUTDOWN_SCRIPT_OPT FeatureBit = 5
	FeatureBit_GOSSIP_QUERIES_REQ          FeatureBit = 6
	FeatureBit_GOSSIP_QUERIES_OPT          FeatureBit = 7
	FeatureBit_TLV_ONION_REQ               FeatureBit = 8
	FeatureBit_TLV_ONION_OPT               FeatureBit = 9
	FeatureBit_EXT_GOSSIP_QUERIES_REQ      FeatureBit = 10
	FeatureBit_EXT_GOSSIP_QUERIES_OPT      FeatureBit = 11
	FeatureBit_STATIC_REMOTE_KEY_REQ       FeatureBit = 12
	FeatureBit_STATIC_REMOTE_KEY_OPT       FeatureBit = 13
	FeatureBit_PAYMENT_ADDR_REQ            FeatureBit = 14
	FeatureBit_PAYMENT_ADDR_OPT            FeatureBit = 15
	FeatureBit_MPP_REQ                     FeatureBit = 16
	FeatureBit_MPP_OPT                     FeatureBit = 17
	FeatureBit_WUMBO_CHANNELS_REQ          FeatureBit = 18
	FeatureBit_WUMBO_CHANNELS_OPT          FeatureBit = 19
	FeatureBit_ANCHORS_REQ                 FeatureBit = 20
	FeatureBit_ANCHORS_OPT                 FeatureBit = 21
	FeatureBit_ANCHORS_ZERO_FEE_HTLC_REQ   FeatureBit = 22
	FeatureBit_ANCHORS_ZERO_FEE_HTLC_OPT   FeatureBit = 23
	FeatureBit_ROUTE_BLINDING_REQUIRED     FeatureBit = 24
	FeatureBit_ROUTE_BLINDING_OPTIONAL     FeatureBit = 25
	FeatureBit_AMP_REQ                     FeatureBit = 30
	FeatureBit_AMP_OPT                     FeatureBit = 31
)

// Enum value maps for FeatureBit.
var (
	FeatureBit_name = map[int32]string{
		0:  "DATALOSS_PROTECT_REQ",
		1:  "DATALOSS_PROTECT_OPT",
		3:  "INITIAL_ROUING_SYNC",
		4:  "UPFRONT_SHUTDOWN_SCRIPT_REQ",
		5:  "UPFRONT_SHUTDOWN_SCRIPT_OPT",
		6:  "GOSSIP_QUERIES_REQ",
		7:  "GOSSIP_QUERIES_OPT",
		8:  "TLV_ONION_REQ",
		9:  "TLV_ONION_OPT",
		10: "EXT_GOSSIP_QUERIES_REQ",
		11: "EXT_GOSSIP_QUERIES_OPT",
		12: "STATIC_REMOTE_KEY_REQ",
		13: "STATIC_REMOTE_KEY_OPT",
		14: "PAYMENT_ADDR_REQ",
		15: "PAYMENT_ADDR_OPT",
		16: "MPP_REQ",
		17: "MPP_OPT",
		18: "WUMBO_CHANNELS_REQ",
		19: "WUMBO_CHANNELS_OPT",
		20: "ANCHORS_REQ",
		21: "ANCHORS_OPT",
		22: "ANCHORS_ZERO_FEE_HTLC_REQ",
		23: "ANCHORS_ZERO_FEE_HTLC_OPT",
		24: "ROUTE_BLINDING_REQUIRED",
		25: "ROUTE_BLINDING_OPTIONAL",
		30: "AMP_REQ",
		31: "AMP_OPT",
	}
	FeatureBit_value = map[string]int32{
		"DATALOSS_PROTECT_REQ":        0,
		"DATALOSS_PROTECT_OPT":        1,
		"INITIAL_ROUING_SYNC":         3,
		"UPFRONT_SHUTDOWN_SCRIPT_REQ": 4,
		"UPFRONT_SHUTDOWN_SCRIPT_OPT": 5,
		"GOSSIP_QUERIES_REQ":          6,
		"GOSSIP_QUERIES_OPT":          7,
		"TLV_ONION_REQ":               8,
		"TLV_ONION_OPT":               9,
		"EXT_GOSSIP_QUERIES_REQ":      10,
		"EXT_GOSSIP_QUERIES_OPT":      11,
		"STATIC_REMOTE_KEY_REQ":       12,
		"STATIC_REMOTE_KEY_OPT":       13,
		"PAYMENT_ADDR_REQ":            14,
		"PAYMENT_ADDR_OPT":            15,
		"MPP_REQ":                     16,
		"MPP_OPT":                     17,
		"WUMBO_CHANNELS_REQ":          18,
		"WUMBO_CHANNELS_OPT":          19,
		"ANCHORS_REQ":                 20,
		"ANCHORS_OPT":                 21,
		"ANCHORS_ZERO_FEE_HTLC_REQ":   22,
		"ANCHORS_ZERO_FEE_HTLC_OPT":   23,
		"ROUTE_BLINDING_REQUIRED":     24,
		"ROUTE_BLINDING_OPTIONAL":     25,
		"AMP_REQ":                     30,
		"AMP_OPT":                     31,
	}
)

func (x FeatureBit) Enum() *FeatureBit {
	p := new(FeatureBit)
	*p = x
	return p
}

func (x FeatureBit) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FeatureBit) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[10].Descriptor()
}

func (FeatureBit) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[10]
}

func (x FeatureBit) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FeatureBit.Descriptor instead.
func (FeatureBit) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{10}
}

type UpdateFailure int32

const (
	UpdateFailure_UPDATE_FAILURE_UNKNOWN           UpdateFailure = 0
	UpdateFailure_UPDATE_FAILURE_PENDING           UpdateFailure = 1
	UpdateFailure_UPDATE_FAILURE_NOT_FOUND         UpdateFailure = 2
	UpdateFailure_UPDATE_FAILURE_INTERNAL_ERR      UpdateFailure = 3
	UpdateFailure_UPDATE_FAILURE_INVALID_PARAMETER UpdateFailure = 4
)

// Enum value maps for UpdateFailure.
var (
	UpdateFailure_name = map[int32]string{
		0: "UPDATE_FAILURE_UNKNOWN",
		1: "UPDATE_FAILURE_PENDING",
		2: "UPDATE_FAILURE_NOT_FOUND",
		3: "UPDATE_FAILURE_INTERNAL_ERR",
		4: "UPDATE_FAILURE_INVALID_PARAMETER",
	}
	UpdateFailure_value = map[string]int32{
		"UPDATE_FAILURE_UNKNOWN":           0,
		"UPDATE_FAILURE_PENDING":           1,
		"UPDATE_FAILURE_NOT_FOUND":         2,
		"UPDATE_FAILURE_INTERNAL_ERR":      3,
		"UPDATE_FAILURE_INVALID_PARAMETER": 4,
	}
)

func (x UpdateFailure) Enum() *UpdateFailure {
	p := new(UpdateFailure)
	*p = x
	return p
}

func (x UpdateFailure) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (UpdateFailure) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[11].Descriptor()
}

func (UpdateFailure) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[11]
}

func (x UpdateFailure) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use UpdateFailure.Descriptor instead.
func (UpdateFailure) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{11}
}

type ChannelCloseSummary_ClosureType int32

const (
	ChannelCloseSummary_COOPERATIVE_CLOSE  ChannelCloseSummary_ClosureType = 0
	ChannelCloseSummary_LOCAL_FORCE_CLOSE  ChannelCloseSummary_ClosureType = 1
	ChannelCloseSummary_REMOTE_FORCE_CLOSE ChannelCloseSummary_ClosureType = 2
	ChannelCloseSummary_BREACH_CLOSE       ChannelCloseSummary_ClosureType = 3
	ChannelCloseSummary_FUNDING_CANCELED   ChannelCloseSummary_ClosureType = 4
	ChannelCloseSummary_ABANDONED          ChannelCloseSummary_ClosureType = 5
)

// Enum value maps for ChannelCloseSummary_ClosureType.
var (
	ChannelCloseSummary_ClosureType_name = map[int32]string{
		0: "COOPERATIVE_CLOSE",
		1: "LOCAL_FORCE_CLOSE",
		2: "REMOTE_FORCE_CLOSE",
		3: "BREACH_CLOSE",
		4: "FUNDING_CANCELED",
		5: "ABANDONED",
	}
	ChannelCloseSummary_ClosureType_value = map[string]int32{
		"COOPERATIVE_CLOSE":  0,
		"LOCAL_FORCE_CLOSE":  1,
		"REMOTE_FORCE_CLOSE": 2,
		"BREACH_CLOSE":       3,
		"FUNDING_CANCELED":   4,
		"ABANDONED":          5,
	}
)

func (x ChannelCloseSummary_ClosureType) Enum() *ChannelCloseSummary_ClosureType {
	p := new(ChannelCloseSummary_ClosureType)
	*p = x
	return p
}

func (x ChannelCloseSummary_ClosureType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ChannelCloseSummary_ClosureType) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[12].Descriptor()
}

func (ChannelCloseSummary_ClosureType) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[12]
}

func (x ChannelCloseSummary_ClosureType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ChannelCloseSummary_ClosureType.Descriptor instead.
func (ChannelCloseSummary_ClosureType) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{51, 0}
}

type Peer_SyncType int32

const (
	// Denotes that we cannot determine the peer's current sync type.
	Peer_UNKNOWN_SYNC Peer_SyncType = 0
	// Denotes that we are actively receiving new graph updates from the peer.
	Peer_ACTIVE_SYNC Peer_SyncType = 1
	// Denotes that we are not receiving new graph updates from the peer.
	Peer_PASSIVE_SYNC Peer_SyncType = 2
	// Denotes that this peer is pinned into an active sync.
	Peer_PINNED_SYNC Peer_SyncType = 3
)

// Enum value maps for Peer_SyncType.
var (
	Peer_SyncType_name = map[int32]string{
		0: "UNKNOWN_SYNC",
		1: "ACTIVE_SYNC",
		2: "PASSIVE_SYNC",
		3: "PINNED_SYNC",
	}
	Peer_SyncType_value = map[string]int32{
		"UNKNOWN_SYNC": 0,
		"ACTIVE_SYNC":  1,
		"PASSIVE_SYNC": 2,
		"PINNED_SYNC":  3,
	}
)

func (x Peer_SyncType) Enum() *Peer_SyncType {
	p := new(Peer_SyncType)
	*p = x
	return p
}

func (x Peer_SyncType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Peer_SyncType) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[13].Descriptor()
}

func (Peer_SyncType) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[13]
}

func (x Peer_SyncType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Peer_SyncType.Descriptor instead.
func (Peer_SyncType) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{55, 0}
}

type PeerEvent_EventType int32

const (
	PeerEvent_PEER_ONLINE  PeerEvent_EventType = 0
	PeerEvent_PEER_OFFLINE PeerEvent_EventType = 1
)

// Enum value maps for PeerEvent_EventType.
var (
	PeerEvent_EventType_name = map[int32]string{
		0: "PEER_ONLINE",
		1: "PEER_OFFLINE",
	}
	PeerEvent_EventType_value = map[string]int32{
		"PEER_ONLINE":  0,
		"PEER_OFFLINE": 1,
	}
)

func (x PeerEvent_EventType) Enum() *PeerEvent_EventType {
	p := new(PeerEvent_EventType)
	*p = x
	return p
}

func (x PeerEvent_EventType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PeerEvent_EventType) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[14].Descriptor()
}

func (PeerEvent_EventType) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[14]
}

func (x PeerEvent_EventType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PeerEvent_EventType.Descriptor instead.
func (PeerEvent_EventType) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{60, 0}
}

// There are three resolution states for the anchor:
// limbo, lost and recovered. Derive the current state
// from the limbo and recovered balances.
type PendingChannelsResponse_ForceClosedChannel_AnchorState int32

const (
	// The recovered_balance is zero and limbo_balance is non-zero.
	PendingChannelsResponse_ForceClosedChannel_LIMBO PendingChannelsResponse_ForceClosedChannel_AnchorState = 0
	// The recovered_balance is non-zero.
	PendingChannelsResponse_ForceClosedChannel_RECOVERED PendingChannelsResponse_ForceClosedChannel_AnchorState = 1
	// A state that is neither LIMBO nor RECOVERED.
	PendingChannelsResponse_ForceClosedChannel_LOST PendingChannelsResponse_ForceClosedChannel_AnchorState = 2
)

// Enum value maps for PendingChannelsResponse_ForceClosedChannel_AnchorState.
var (
	PendingChannelsResponse_ForceClosedChannel_AnchorState_name = map[int32]string{
		0: "LIMBO",
		1: "RECOVERED",
		2: "LOST",
	}
	PendingChannelsResponse_ForceClosedChannel_AnchorState_value = map[string]int32{
		"LIMBO":     0,
		"RECOVERED": 1,
		"LOST":      2,
	}
)

func (x PendingChannelsResponse_ForceClosedChannel_AnchorState) Enum() *PendingChannelsResponse_ForceClosedChannel_AnchorState {
	p := new(PendingChannelsResponse_ForceClosedChannel_AnchorState)
	*p = x
	return p
}

func (x PendingChannelsResponse_ForceClosedChannel_AnchorState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PendingChannelsResponse_ForceClosedChannel_AnchorState) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[15].Descriptor()
}

func (PendingChannelsResponse_ForceClosedChannel_AnchorState) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[15]
}

func (x PendingChannelsResponse_ForceClosedChannel_AnchorState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PendingChannelsResponse_ForceClosedChannel_AnchorState.Descriptor instead.
func (PendingChannelsResponse_ForceClosedChannel_AnchorState) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{93, 5, 0}
}

type ChannelEventUpdate_UpdateType int32

const (
	ChannelEventUpdate_OPEN_CHANNEL            ChannelEventUpdate_UpdateType = 0
	ChannelEventUpdate_CLOSED_CHANNEL          ChannelEventUpdate_UpdateType = 1
	ChannelEventUpdate_ACTIVE_CHANNEL          ChannelEventUpdate_UpdateType = 2
	ChannelEventUpdate_INACTIVE_CHANNEL        ChannelEventUpdate_UpdateType = 3
	ChannelEventUpdate_PENDING_OPEN_CHANNEL    ChannelEventUpdate_UpdateType = 4
	ChannelEventUpdate_FULLY_RESOLVED_CHANNEL  ChannelEventUpdate_UpdateType = 5
	ChannelEventUpdate_CHANNEL_FUNDING_TIMEOUT ChannelEventUpdate_UpdateType = 6
)

// Enum value maps for ChannelEventUpdate_UpdateType.
var (
	ChannelEventUpdate_UpdateType_name = map[int32]string{
		0: "OPEN_CHANNEL",
		1: "CLOSED_CHANNEL",
		2: "ACTIVE_CHANNEL",
		3: "INACTIVE_CHANNEL",
		4: "PENDING_OPEN_CHANNEL",
		5: "FULLY_RESOLVED_CHANNEL",
		6: "CHANNEL_FUNDING_TIMEOUT",
	}
	ChannelEventUpdate_UpdateType_value = map[string]int32{
		"OPEN_CHANNEL":            0,
		"CLOSED_CHANNEL":          1,
		"ACTIVE_CHANNEL":          2,
		"INACTIVE_CHANNEL":        3,
		"PENDING_OPEN_CHANNEL":    4,
		"FULLY_RESOLVED_CHANNEL":  5,
		"CHANNEL_FUNDING_TIMEOUT": 6,
	}
)

func (x ChannelEventUpdate_UpdateType) Enum() *ChannelEventUpdate_UpdateType {
	p := new(ChannelEventUpdate_UpdateType)
	*p = x
	return p
}

func (x ChannelEventUpdate_UpdateType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ChannelEventUpdate_UpdateType) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[16].Descriptor()
}

func (ChannelEventUpdate_UpdateType) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[16]
}

func (x ChannelEventUpdate_UpdateType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ChannelEventUpdate_UpdateType.Descriptor instead.
func (ChannelEventUpdate_UpdateType) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{95, 0}
}

type Invoice_InvoiceState int32

const (
	Invoice_OPEN     Invoice_InvoiceState = 0
	Invoice_SETTLED  Invoice_InvoiceState = 1
	Invoice_CANCELED Invoice_InvoiceState = 2
	Invoice_ACCEPTED Invoice_InvoiceState = 3
)

// Enum value maps for Invoice_InvoiceState.
var (
	Invoice_InvoiceState_name = map[int32]string{
		0: "OPEN",
		1: "SETTLED",
		2: "CANCELED",
		3: "ACCEPTED",
	}
	Invoice_InvoiceState_value = map[string]int32{
		"OPEN":     0,
		"SETTLED":  1,
		"CANCELED": 2,
		"ACCEPTED": 3,
	}
)

func (x Invoice_InvoiceState) Enum() *Invoice_InvoiceState {
	p := new(Invoice_InvoiceState)
	*p = x
	return p
}

func (x Invoice_InvoiceState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Invoice_InvoiceState) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[17].Descriptor()
}

func (Invoice_InvoiceState) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[17]
}

func (x Invoice_InvoiceState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Invoice_InvoiceState.Descriptor instead.
func (Invoice_InvoiceState) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{139, 0}
}

type Payment_PaymentStatus int32

const (
	// Deprecated. This status will never be returned.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	Payment_UNKNOWN Payment_PaymentStatus = 0
	// Payment has inflight HTLCs.
	Payment_IN_FLIGHT Payment_PaymentStatus = 1
	// Payment is settled.
	Payment_SUCCEEDED Payment_PaymentStatus = 2
	// Payment is failed.
	Payment_FAILED Payment_PaymentStatus = 3
	// Payment is created and has not attempted any HTLCs.
	Payment_INITIATED Payment_PaymentStatus = 4
)

// Enum value maps for Payment_PaymentStatus.
var (
	Payment_PaymentStatus_name = map[int32]string{
		0: "UNKNOWN",
		1: "IN_FLIGHT",
		2: "SUCCEEDED",
		3: "FAILED",
		4: "INITIATED",
	}
	Payment_PaymentStatus_value = map[string]int32{
		"UNKNOWN":   0,
		"IN_FLIGHT": 1,
		"SUCCEEDED": 2,
		"FAILED":    3,
		"INITIATED": 4,
	}
)

func (x Payment_PaymentStatus) Enum() *Payment_PaymentStatus {
	p := new(Payment_PaymentStatus)
	*p = x
	return p
}

func (x Payment_PaymentStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Payment_PaymentStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[18].Descriptor()
}

func (Payment_PaymentStatus) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[18]
}

func (x Payment_PaymentStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Payment_PaymentStatus.Descriptor instead.
func (Payment_PaymentStatus) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{150, 0}
}

type HTLCAttempt_HTLCStatus int32

const (
	HTLCAttempt_IN_FLIGHT HTLCAttempt_HTLCStatus = 0
	HTLCAttempt_SUCCEEDED HTLCAttempt_HTLCStatus = 1
	HTLCAttempt_FAILED    HTLCAttempt_HTLCStatus = 2
)

// Enum value maps for HTLCAttempt_HTLCStatus.
var (
	HTLCAttempt_HTLCStatus_name = map[int32]string{
		0: "IN_FLIGHT",
		1: "SUCCEEDED",
		2: "FAILED",
	}
	HTLCAttempt_HTLCStatus_value = map[string]int32{
		"IN_FLIGHT": 0,
		"SUCCEEDED": 1,
		"FAILED":    2,
	}
)

func (x HTLCAttempt_HTLCStatus) Enum() *HTLCAttempt_HTLCStatus {
	p := new(HTLCAttempt_HTLCStatus)
	*p = x
	return p
}

func (x HTLCAttempt_HTLCStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HTLCAttempt_HTLCStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[19].Descriptor()
}

func (HTLCAttempt_HTLCStatus) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[19]
}

func (x HTLCAttempt_HTLCStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HTLCAttempt_HTLCStatus.Descriptor instead.
func (HTLCAttempt_HTLCStatus) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{151, 0}
}

type Failure_FailureCode int32

const (
	// The numbers assigned in this enumeration match the failure codes as
	// defined in BOLT #4. Because protobuf 3 requires enums to start with 0,
	// a RESERVED value is added.
	Failure_RESERVED                             Failure_FailureCode = 0
	Failure_INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS Failure_FailureCode = 1
	Failure_INCORRECT_PAYMENT_AMOUNT             Failure_FailureCode = 2
	Failure_FINAL_INCORRECT_CLTV_EXPIRY          Failure_FailureCode = 3
	Failure_FINAL_INCORRECT_HTLC_AMOUNT          Failure_FailureCode = 4
	Failure_FINAL_EXPIRY_TOO_SOON                Failure_FailureCode = 5
	Failure_INVALID_REALM                        Failure_FailureCode = 6
	Failure_EXPIRY_TOO_SOON                      Failure_FailureCode = 7
	Failure_INVALID_ONION_VERSION                Failure_FailureCode = 8
	Failure_INVALID_ONION_HMAC                   Failure_FailureCode = 9
	Failure_INVALID_ONION_KEY                    Failure_FailureCode = 10
	Failure_AMOUNT_BELOW_MINIMUM                 Failure_FailureCode = 11
	Failure_FEE_INSUFFICIENT                     Failure_FailureCode = 12
	Failure_INCORRECT_CLTV_EXPIRY                Failure_FailureCode = 13
	Failure_CHANNEL_DISABLED                     Failure_FailureCode = 14
	Failure_TEMPORARY_CHANNEL_FAILURE            Failure_FailureCode = 15
	Failure_REQUIRED_NODE_FEATURE_MISSING        Failure_FailureCode = 16
	Failure_REQUIRED_CHANNEL_FEATURE_MISSING     Failure_FailureCode = 17
	Failure_UNKNOWN_NEXT_PEER                    Failure_FailureCode = 18
	Failure_TEMPORARY_NODE_FAILURE               Failure_FailureCode = 19
	Failure_PERMANENT_NODE_FAILURE               Failure_FailureCode = 20
	Failure_PERMANENT_CHANNEL_FAILURE            Failure_FailureCode = 21
	Failure_EXPIRY_TOO_FAR                       Failure_FailureCode = 22
	Failure_MPP_TIMEOUT                          Failure_FailureCode = 23
	Failure_INVALID_ONION_PAYLOAD                Failure_FailureCode = 24
	Failure_INVALID_ONION_BLINDING               Failure_FailureCode = 25
	// An internal error occurred.
	Failure_INTERNAL_FAILURE Failure_FailureCode = 997
	// The error source is known, but the failure itself couldn't be decoded.
	Failure_UNKNOWN_FAILURE Failure_FailureCode = 998
	// An unreadable failure result is returned if the received failure message
	// cannot be decrypted. In that case the error source is unknown.
	Failure_UNREADABLE_FAILURE Failure_FailureCode = 999
)

// Enum value maps for Failure_FailureCode.
var (
	Failure_FailureCode_name = map[int32]string{
		0:   "RESERVED",
		1:   "INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS",
		2:   "INCORRECT_PAYMENT_AMOUNT",
		3:   "FINAL_INCORRECT_CLTV_EXPIRY",
		4:   "FINAL_INCORRECT_HTLC_AMOUNT",
		5:   "FINAL_EXPIRY_TOO_SOON",
		6:   "INVALID_REALM",
		7:   "EXPIRY_TOO_SOON",
		8:   "INVALID_ONION_VERSION",
		9:   "INVALID_ONION_HMAC",
		10:  "INVALID_ONION_KEY",
		11:  "AMOUNT_BELOW_MINIMUM",
		12:  "FEE_INSUFFICIENT",
		13:  "INCORRECT_CLTV_EXPIRY",
		14:  "CHANNEL_DISABLED",
		15:  "TEMPORARY_CHANNEL_FAILURE",
		16:  "REQUIRED_NODE_FEATURE_MISSING",
		17:  "REQUIRED_CHANNEL_FEATURE_MISSING",
		18:  "UNKNOWN_NEXT_PEER",
		19:  "TEMPORARY_NODE_FAILURE",
		20:  "PERMANENT_NODE_FAILURE",
		21:  "PERMANENT_CHANNEL_FAILURE",
		22:  "EXPIRY_TOO_FAR",
		23:  "MPP_TIMEOUT",
		24:  "INVALID_ONION_PAYLOAD",
		25:  "INVALID_ONION_BLINDING",
		997: "INTERNAL_FAILURE",
		998: "UNKNOWN_FAILURE",
		999: "UNREADABLE_FAILURE",
	}
	Failure_FailureCode_value = map[string]int32{
		"RESERVED":                             0,
		"INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS": 1,
		"INCORRECT_PAYMENT_AMOUNT":             2,
		"FINAL_INCORRECT_CLTV_EXPIRY":          3,
		"FINAL_INCORRECT_HTLC_AMOUNT":          4,
		"FINAL_EXPIRY_TOO_SOON":                5,
		"INVALID_REALM":                        6,
		"EXPIRY_TOO_SOON":                      7,
		"INVALID_ONION_VERSION":                8,
		"INVALID_ONION_HMAC":                   9,
		"INVALID_ONION_KEY":                    10,
		"AMOUNT_BELOW_MINIMUM":                 11,
		"FEE_INSUFFICIENT":                     12,
		"INCORRECT_CLTV_EXPIRY":                13,
		"CHANNEL_DISABLED":                     14,
		"TEMPORARY_CHANNEL_FAILURE":            15,
		"REQUIRED_NODE_FEATURE_MISSING":        16,
		"REQUIRED_CHANNEL_FEATURE_MISSING":     17,
		"UNKNOWN_NEXT_PEER":                    18,
		"TEMPORARY_NODE_FAILURE":               19,
		"PERMANENT_NODE_FAILURE":               20,
		"PERMANENT_CHANNEL_FAILURE":            21,
		"EXPIRY_TOO_FAR":                       22,
		"MPP_TIMEOUT":                          23,
		"INVALID_ONION_PAYLOAD":                24,
		"INVALID_ONION_BLINDING":               25,
		"INTERNAL_FAILURE":                     997,
		"UNKNOWN_FAILURE":                      998,
		"UNREADABLE_FAILURE":                   999,
	}
)

func (x Failure_FailureCode) Enum() *Failure_FailureCode {
	p := new(Failure_FailureCode)
	*p = x
	return p
}

func (x Failure_FailureCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Failure_FailureCode) Descriptor() protoreflect.EnumDescriptor {
	return file_lightning_proto_enumTypes[20].Descriptor()
}

func (Failure_FailureCode) Type() protoreflect.EnumType {
	return &file_lightning_proto_enumTypes[20]
}

func (x Failure_FailureCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Failure_FailureCode.Descriptor instead.
func (Failure_FailureCode) EnumDescriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{195, 0}
}

type LookupHtlcResolutionRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ChanId        uint64                 `protobuf:"varint,1,opt,name=chan_id,json=chanId,proto3" json:"chan_id,omitempty"`
	HtlcIndex     uint64                 `protobuf:"varint,2,opt,name=htlc_index,json=htlcIndex,proto3" json:"htlc_index,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LookupHtlcResolutionRequest) Reset() {
	*x = LookupHtlcResolutionRequest{}
	mi := &file_lightning_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LookupHtlcResolutionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LookupHtlcResolutionRequest) ProtoMessage() {}

func (x *LookupHtlcResolutionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LookupHtlcResolutionRequest.ProtoReflect.Descriptor instead.
func (*LookupHtlcResolutionRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{0}
}

func (x *LookupHtlcResolutionRequest) GetChanId() uint64 {
	if x != nil {
		return x.ChanId
	}
	return 0
}

func (x *LookupHtlcResolutionRequest) GetHtlcIndex() uint64 {
	if x != nil {
		return x.HtlcIndex
	}
	return 0
}

type LookupHtlcResolutionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Settled is true is the htlc was settled. If false, the htlc was failed.
	Settled bool `protobuf:"varint,1,opt,name=settled,proto3" json:"settled,omitempty"`
	// Offchain indicates whether the htlc was resolved off-chain or on-chain.
	Offchain      bool `protobuf:"varint,2,opt,name=offchain,proto3" json:"offchain,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LookupHtlcResolutionResponse) Reset() {
	*x = LookupHtlcResolutionResponse{}
	mi := &file_lightning_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LookupHtlcResolutionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LookupHtlcResolutionResponse) ProtoMessage() {}

func (x *LookupHtlcResolutionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LookupHtlcResolutionResponse.ProtoReflect.Descriptor instead.
func (*LookupHtlcResolutionResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{1}
}

func (x *LookupHtlcResolutionResponse) GetSettled() bool {
	if x != nil {
		return x.Settled
	}
	return false
}

func (x *LookupHtlcResolutionResponse) GetOffchain() bool {
	if x != nil {
		return x.Offchain
	}
	return false
}

type SubscribeCustomMessagesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubscribeCustomMessagesRequest) Reset() {
	*x = SubscribeCustomMessagesRequest{}
	mi := &file_lightning_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscribeCustomMessagesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeCustomMessagesRequest) ProtoMessage() {}

func (x *SubscribeCustomMessagesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeCustomMessagesRequest.ProtoReflect.Descriptor instead.
func (*SubscribeCustomMessagesRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{2}
}

type CustomMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Peer from which the message originates
	Peer []byte `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	// Message type. This value will be in the custom range (>= 32768).
	Type uint32 `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	// Raw message data
	Data          []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CustomMessage) Reset() {
	*x = CustomMessage{}
	mi := &file_lightning_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CustomMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CustomMessage) ProtoMessage() {}

func (x *CustomMessage) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CustomMessage.ProtoReflect.Descriptor instead.
func (*CustomMessage) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{3}
}

func (x *CustomMessage) GetPeer() []byte {
	if x != nil {
		return x.Peer
	}
	return nil
}

func (x *CustomMessage) GetType() uint32 {
	if x != nil {
		return x.Type
	}
	return 0
}

func (x *CustomMessage) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

type SendCustomMessageRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Peer to which the message will be sent. Represented as a byte-encoded
	// public key
	Peer []byte `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	// Message type. This value needs to be in the custom range (>= 32768).
	// To send a type < custom range, lnd needs to be compiled with the `dev`
	// build tag, and the message type to override should be specified in lnd's
	// experimental protocol configuration.
	Type uint32 `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	// Raw message data.
	Data          []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SendCustomMessageRequest) Reset() {
	*x = SendCustomMessageRequest{}
	mi := &file_lightning_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendCustomMessageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendCustomMessageRequest) ProtoMessage() {}

func (x *SendCustomMessageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendCustomMessageRequest.ProtoReflect.Descriptor instead.
func (*SendCustomMessageRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{4}
}

func (x *SendCustomMessageRequest) GetPeer() []byte {
	if x != nil {
		return x.Peer
	}
	return nil
}

func (x *SendCustomMessageRequest) GetType() uint32 {
	if x != nil {
		return x.Type
	}
	return 0
}

func (x *SendCustomMessageRequest) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

type SendCustomMessageResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The status of the send operation.
	Status        string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SendCustomMessageResponse) Reset() {
	*x = SendCustomMessageResponse{}
	mi := &file_lightning_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendCustomMessageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendCustomMessageResponse) ProtoMessage() {}

func (x *SendCustomMessageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendCustomMessageResponse.ProtoReflect.Descriptor instead.
func (*SendCustomMessageResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{5}
}

func (x *SendCustomMessageResponse) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

type SubscribeOnionMessagesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubscribeOnionMessagesRequest) Reset() {
	*x = SubscribeOnionMessagesRequest{}
	mi := &file_lightning_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscribeOnionMessagesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeOnionMessagesRequest) ProtoMessage() {}

func (x *SubscribeOnionMessagesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeOnionMessagesRequest.ProtoReflect.Descriptor instead.
func (*SubscribeOnionMessagesRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{6}
}

type OnionMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Peer from which this message originates. Represented as a byte-encoded
	// public key.
	Peer []byte `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	// PathKey is used to derive the blinded node id by tweaking the hop's
	// static public key. The hop uses the corresponding blinded private key
	// together with the sender's ephemeral key to perform ECDH and obtain the
	// shared secret for decrypting the onion payload. Separately, for
	// decrypting `encrypted_recipient_data`, the recipient performs ECDH
	// between its static node private key and the path_key to derive the
	// decryption key.
	PathKey []byte `protobuf:"bytes,2,opt,name=path_key,json=pathKey,proto3" json:"path_key,omitempty"`
	// Serialized Sphinx onion packet (BOLT 4) containing the layered, per-hop
	// encrypted payloads and routing instructions used to forward this message
	// along its designated path.
	Onion         []byte `protobuf:"bytes,3,opt,name=onion,proto3" json:"onion,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OnionMessage) Reset() {
	*x = OnionMessage{}
	mi := &file_lightning_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OnionMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OnionMessage) ProtoMessage() {}

func (x *OnionMessage) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OnionMessage.ProtoReflect.Descriptor instead.
func (*OnionMessage) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{7}
}

func (x *OnionMessage) GetPeer() []byte {
	if x != nil {
		return x.Peer
	}
	return nil
}

func (x *OnionMessage) GetPathKey() []byte {
	if x != nil {
		return x.PathKey
	}
	return nil
}

func (x *OnionMessage) GetOnion() []byte {
	if x != nil {
		return x.Onion
	}
	return nil
}

type SendOnionMessageRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Peer to send the message to
	Peer []byte `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	// PathKey is used to derive the blinded node id by tweaking the hop's
	// static public key. The hop uses the corresponding blinded private key
	// together with the sender's ephemeral key to perform ECDH and obtain the
	// shared secret for decrypting the onion payload. Separately, for
	// decrypting `encrypted_recipient_data`, the recipient performs ECDH
	// between its static node private key and the path_key to derive the
	// decryption key.
	PathKey []byte `protobuf:"bytes,2,opt,name=path_key,json=pathKey,proto3" json:"path_key,omitempty"`
	// Serialized Sphinx onion packet (BOLT 4) containing the layered, per-hop
	// encrypted payloads and routing instructions used to forward this message
	// along its designated path.
	Onion         []byte `protobuf:"bytes,3,opt,name=onion,proto3" json:"onion,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SendOnionMessageRequest) Reset() {
	*x = SendOnionMessageRequest{}
	mi := &file_lightning_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendOnionMessageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendOnionMessageRequest) ProtoMessage() {}

func (x *SendOnionMessageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendOnionMessageRequest.ProtoReflect.Descriptor instead.
func (*SendOnionMessageRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{8}
}

func (x *SendOnionMessageRequest) GetPeer() []byte {
	if x != nil {
		return x.Peer
	}
	return nil
}

func (x *SendOnionMessageRequest) GetPathKey() []byte {
	if x != nil {
		return x.PathKey
	}
	return nil
}

func (x *SendOnionMessageRequest) GetOnion() []byte {
	if x != nil {
		return x.Onion
	}
	return nil
}

type SendOnionMessageResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The status of the onion message send operation.
	Status        string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SendOnionMessageResponse) Reset() {
	*x = SendOnionMessageResponse{}
	mi := &file_lightning_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendOnionMessageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendOnionMessageResponse) ProtoMessage() {}

func (x *SendOnionMessageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendOnionMessageResponse.ProtoReflect.Descriptor instead.
func (*SendOnionMessageResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{9}
}

func (x *SendOnionMessageResponse) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

type Utxo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of address
	AddressType AddressType `protobuf:"varint,1,opt,name=address_type,json=addressType,proto3,enum=lnrpc.AddressType" json:"address_type,omitempty"`
	// The address
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// The value of the unspent coin in satoshis
	AmountSat int64 `protobuf:"varint,3,opt,name=amount_sat,json=amountSat,proto3" json:"amount_sat,omitempty"`
	// The pkscript in hex
	PkScript string `protobuf:"bytes,4,opt,name=pk_script,json=pkScript,proto3" json:"pk_script,omitempty"`
	// The outpoint in format txid:n
	Outpoint *OutPoint `protobuf:"bytes,5,opt,name=outpoint,proto3" json:"outpoint,omitempty"`
	// The number of confirmations for the Utxo
	Confirmations int64 `protobuf:"varint,6,opt,name=confirmations,proto3" json:"confirmations,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Utxo) Reset() {
	*x = Utxo{}
	mi := &file_lightning_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Utxo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Utxo) ProtoMessage() {}

func (x *Utxo) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Utxo.ProtoReflect.Descriptor instead.
func (*Utxo) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{10}
}

func (x *Utxo) GetAddressType() AddressType {
	if x != nil {
		return x.AddressType
	}
	return AddressType_WITNESS_PUBKEY_HASH
}

func (x *Utxo) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *Utxo) GetAmountSat() int64 {
	if x != nil {
		return x.AmountSat
	}
	return 0
}

func (x *Utxo) GetPkScript() string {
	if x != nil {
		return x.PkScript
	}
	return ""
}

func (x *Utxo) GetOutpoint() *OutPoint {
	if x != nil {
		return x.Outpoint
	}
	return nil
}

func (x *Utxo) GetConfirmations() int64 {
	if x != nil {
		return x.Confirmations
	}
	return 0
}

type OutputDetail struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of the output
	OutputType OutputScriptType `protobuf:"varint,1,opt,name=output_type,json=outputType,proto3,enum=lnrpc.OutputScriptType" json:"output_type,omitempty"`
	// The address
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// The pkscript in hex
	PkScript string `protobuf:"bytes,3,opt,name=pk_script,json=pkScript,proto3" json:"pk_script,omitempty"`
	// The output index used in the raw transaction
	OutputIndex int64 `protobuf:"varint,4,opt,name=output_index,json=outputIndex,proto3" json:"output_index,omitempty"`
	// The value of the output coin in satoshis
	Amount int64 `protobuf:"varint,5,opt,name=amount,proto3" json:"amount,omitempty"`
	// Denotes if the output is controlled by the internal wallet
	IsOurAddress  bool `protobuf:"varint,6,opt,name=is_our_address,json=isOurAddress,proto3" json:"is_our_address,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OutputDetail) Reset() {
	*x = OutputDetail{}
	mi := &file_lightning_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutputDetail) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutputDetail) ProtoMessage() {}

func (x *OutputDetail) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutputDetail.ProtoReflect.Descriptor instead.
func (*OutputDetail) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{11}
}

func (x *OutputDetail) GetOutputType() OutputScriptType {
	if x != nil {
		return x.OutputType
	}
	return OutputScriptType_SCRIPT_TYPE_PUBKEY_HASH
}

func (x *OutputDetail) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *OutputDetail) GetPkScript() string {
	if x != nil {
		return x.PkScript
	}
	return ""
}

func (x *OutputDetail) GetOutputIndex() int64 {
	if x != nil {
		return x.OutputIndex
	}
	return 0
}

func (x *OutputDetail) GetAmount() int64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

func (x *OutputDetail) GetIsOurAddress() bool {
	if x != nil {
		return x.IsOurAddress
	}
	return false
}

type Transaction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The transaction hash
	TxHash string `protobuf:"bytes,1,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	// The transaction amount, denominated in satoshis
	Amount int64 `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
	// The number of confirmations
	NumConfirmations int32 `protobuf:"varint,3,opt,name=num_confirmations,json=numConfirmations,proto3" json:"num_confirmations,omitempty"`
	// The hash of the block this transaction was included in
	BlockHash string `protobuf:"bytes,4,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	// The height of the block this transaction was included in
	BlockHeight int32 `protobuf:"varint,5,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// Timestamp of this transaction
	TimeStamp int64 `protobuf:"varint,6,opt,name=time_stamp,json=timeStamp,proto3" json:"time_stamp,omitempty"`
	// Fees paid for this transaction
	TotalFees int64 `protobuf:"varint,7,opt,name=total_fees,json=totalFees,proto3" json:"total_fees,omitempty"`
	// Addresses that received funds for this transaction. Deprecated as it is
	// now incorporated in the output_details field.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	DestAddresses []string `protobuf:"bytes,8,rep,name=dest_addresses,json=destAddresses,proto3" json:"dest_addresses,omitempty"`
	// Outputs that received funds for this transaction
	OutputDetails []*OutputDetail `protobuf:"bytes,11,rep,name=output_details,json=outputDetails,proto3" json:"output_details,omitempty"`
	// The raw transaction hex.
	RawTxHex string `protobuf:"bytes,9,opt,name=raw_tx_hex,json=rawTxHex,proto3" json:"raw_tx_hex,omitempty"`
	// A label that was optionally set on transaction broadcast.
	Label string `protobuf:"bytes,10,opt,name=label,proto3" json:"label,omitempty"`
	// PreviousOutpoints/Inputs of this transaction.
	PreviousOutpoints []*PreviousOutPoint `protobuf:"bytes,12,rep,name=previous_outpoints,json=previousOutpoints,proto3" json:"previous_outpoints,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *Transaction) Reset() {
	*x = Transaction{}
	mi := &file_lightning_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transaction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transaction) ProtoMessage() {}

func (x *Transaction) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transaction.ProtoReflect.Descriptor instead.
func (*Transaction) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{12}
}

func (x *Transaction) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *Transaction) GetAmount() int64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

func (x *Transaction) GetNumConfirmations() int32 {
	if x != nil {
		return x.NumConfirmations
	}
	return 0
}

func (x *Transaction) GetBlockHash() string {
	if x != nil {
		return x.BlockHash
	}
	return ""
}

func (x *Transaction) GetBlockHeight() int32 {
	if x != nil {
		return x.BlockHeight
	}
	return 0
}

func (x *Transaction) GetTimeStamp() int64 {
	if x != nil {
		return x.TimeStamp
	}
	return 0
}

func (x *Transaction) GetTotalFees() int64 {
	if x != nil {
		return x.TotalFees
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *Transaction) GetDestAddresses() []string {
	if x != nil {
		return x.DestAddresses
	}
	return nil
}

func (x *Transaction) GetOutputDetails() []*OutputDetail {
	if x != nil {
		return x.OutputDetails
	}
	return nil
}

func (x *Transaction) GetRawTxHex() string {
	if x != nil {
		return x.RawTxHex
	}
	return ""
}

func (x *Transaction) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *Transaction) GetPreviousOutpoints() []*PreviousOutPoint {
	if x != nil {
		return x.PreviousOutpoints
	}
	return nil
}

type GetTransactionsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The height from which to list transactions, inclusive. If this value is
	// greater than end_height, transactions will be read in reverse.
	StartHeight int32 `protobuf:"varint,1,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	// The height until which to list transactions, inclusive. To include
	// unconfirmed transactions, this value should be set to -1, which will
	// return transactions from start_height until the current chain tip and
	// unconfirmed transactions. If no end_height is provided, the call will
	// default to this option.
	EndHeight int32 `protobuf:"varint,2,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
	// An optional filter to only include transactions relevant to an account.
	Account string `protobuf:"bytes,3,opt,name=account,proto3" json:"account,omitempty"`
	// The index of a transaction that will be used in a query to determine which
	// transaction should be returned in the response.
	IndexOffset uint32 `protobuf:"varint,4,opt,name=index_offset,json=indexOffset,proto3" json:"index_offset,omitempty"`
	// The maximal number of transactions returned in the response to this query.
	// This value should be set to 0 to return all transactions.
	MaxTransactions uint32 `protobuf:"varint,5,opt,name=max_transactions,json=maxTransactions,proto3" json:"max_transactions,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *GetTransactionsRequest) Reset() {
	*x = GetTransactionsRequest{}
	mi := &file_lightning_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetTransactionsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetTransactionsRequest) ProtoMessage() {}

func (x *GetTransactionsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetTransactionsRequest.ProtoReflect.Descriptor instead.
func (*GetTransactionsRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{13}
}

func (x *GetTransactionsRequest) GetStartHeight() int32 {
	if x != nil {
		return x.StartHeight
	}
	return 0
}

func (x *GetTransactionsRequest) GetEndHeight() int32 {
	if x != nil {
		return x.EndHeight
	}
	return 0
}

func (x *GetTransactionsRequest) GetAccount() string {
	if x != nil {
		return x.Account
	}
	return ""
}

func (x *GetTransactionsRequest) GetIndexOffset() uint32 {
	if x != nil {
		return x.IndexOffset
	}
	return 0
}

func (x *GetTransactionsRequest) GetMaxTransactions() uint32 {
	if x != nil {
		return x.MaxTransactions
	}
	return 0
}

type TransactionDetails struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The list of transactions relevant to the wallet.
	Transactions []*Transaction `protobuf:"bytes,1,rep,name=transactions,proto3" json:"transactions,omitempty"`
	// The index of the last item in the set of returned transactions. This can be
	// used to seek further, pagination style.
	LastIndex uint64 `protobuf:"varint,2,opt,name=last_index,json=lastIndex,proto3" json:"last_index,omitempty"`
	// The index of the last item in the set of returned transactions. This can be
	// used to seek backwards, pagination style.
	FirstIndex    uint64 `protobuf:"varint,3,opt,name=first_index,json=firstIndex,proto3" json:"first_index,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransactionDetails) Reset() {
	*x = TransactionDetails{}
	mi := &file_lightning_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransactionDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransactionDetails) ProtoMessage() {}

func (x *TransactionDetails) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransactionDetails.ProtoReflect.Descriptor instead.
func (*TransactionDetails) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{14}
}

func (x *TransactionDetails) GetTransactions() []*Transaction {
	if x != nil {
		return x.Transactions
	}
	return nil
}

func (x *TransactionDetails) GetLastIndex() uint64 {
	if x != nil {
		return x.LastIndex
	}
	return 0
}

func (x *TransactionDetails) GetFirstIndex() uint64 {
	if x != nil {
		return x.FirstIndex
	}
	return 0
}

type FeeLimit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Limit:
	//
	//	*FeeLimit_Fixed
	//	*FeeLimit_FixedMsat
	//	*FeeLimit_Percent
	Limit         isFeeLimit_Limit `protobuf_oneof:"limit"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FeeLimit) Reset() {
	*x = FeeLimit{}
	mi := &file_lightning_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FeeLimit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FeeLimit) ProtoMessage() {}

func (x *FeeLimit) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FeeLimit.ProtoReflect.Descriptor instead.
func (*FeeLimit) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{15}
}

func (x *FeeLimit) GetLimit() isFeeLimit_Limit {
	if x != nil {
		return x.Limit
	}
	return nil
}

func (x *FeeLimit) GetFixed() int64 {
	if x != nil {
		if x, ok := x.Limit.(*FeeLimit_Fixed); ok {
			return x.Fixed
		}
	}
	return 0
}

func (x *FeeLimit) GetFixedMsat() int64 {
	if x != nil {
		if x, ok := x.Limit.(*FeeLimit_FixedMsat); ok {
			return x.FixedMsat
		}
	}
	return 0
}

func (x *FeeLimit) GetPercent() int64 {
	if x != nil {
		if x, ok := x.Limit.(*FeeLimit_Percent); ok {
			return x.Percent
		}
	}
	return 0
}

type isFeeLimit_Limit interface {
	isFeeLimit_Limit()
}

type FeeLimit_Fixed struct {
	// The fee limit expressed as a fixed amount of satoshis.
	//
	// The fields fixed and fixed_msat are mutually exclusive.
	Fixed int64 `protobuf:"varint,1,opt,name=fixed,proto3,oneof"`
}

type FeeLimit_FixedMsat struct {
	// The fee limit expressed as a fixed amount of millisatoshis.
	//
	// The fields fixed and fixed_msat are mutually exclusive.
	FixedMsat int64 `protobuf:"varint,3,opt,name=fixed_msat,json=fixedMsat,proto3,oneof"`
}

type FeeLimit_Percent struct {
	// The fee limit expressed as a percentage of the payment amount.
	Percent int64 `protobuf:"varint,2,opt,name=percent,proto3,oneof"`
}

func (*FeeLimit_Fixed) isFeeLimit_Limit() {}

func (*FeeLimit_FixedMsat) isFeeLimit_Limit() {}

func (*FeeLimit_Percent) isFeeLimit_Limit() {}

type SendRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identity pubkey of the payment recipient. When using REST, this field
	// must be encoded as base64.
	Dest []byte `protobuf:"bytes,1,opt,name=dest,proto3" json:"dest,omitempty"`
	// The hex-encoded identity pubkey of the payment recipient. Deprecated now
	// that the REST gateway supports base64 encoding of bytes fields.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	DestString string `protobuf:"bytes,2,opt,name=dest_string,json=destString,proto3" json:"dest_string,omitempty"`
	// The amount to send expressed in satoshis.
	//
	// The fields amt and amt_msat are mutually exclusive.
	Amt int64 `protobuf:"varint,3,opt,name=amt,proto3" json:"amt,omitempty"`
	// The amount to send expressed in millisatoshis.
	//
	// The fields amt and amt_msat are mutually exclusive.
	AmtMsat int64 `protobuf:"varint,12,opt,name=amt_msat,json=amtMsat,proto3" json:"amt_msat,omitempty"`
	// The hash to use within the payment's HTLC. When using REST, this field
	// must be encoded as base64.
	PaymentHash []byte `protobuf:"bytes,4,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	// The hex-encoded hash to use within the payment's HTLC. Deprecated now
	// that the REST gateway supports base64 encoding of bytes fields.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	PaymentHashString string `protobuf:"bytes,5,opt,name=payment_hash_string,json=paymentHashString,proto3" json:"payment_hash_string,omitempty"`
	// A bare-bones invoice for a payment within the Lightning Network. With the
	// details of the invoice, the sender has all the data necessary to send a
	// payment to the recipient.
	PaymentRequest string `protobuf:"bytes,6,opt,name=payment_request,json=paymentRequest,proto3" json:"payment_request,omitempty"`
	// The CLTV delta from the current height that should be used to set the
	// timelock for the final hop.
	FinalCltvDelta int32 `protobuf:"varint,7,opt,name=final_cltv_delta,json=finalCltvDelta,proto3" json:"final_cltv_delta,omitempty"`
	// The maximum number of satoshis that will be paid as a fee of the payment.
	// This value can be represented either as a percentage of the amount being
	// sent, or as a fixed amount of the maximum fee the user is willing the pay to
	// send the payment. If not specified, lnd will use a default value of 100%
	// fees for small amounts (<=1k sat) or 5% fees for larger amounts.
	FeeLimit *FeeLimit `protobuf:"bytes,8,opt,name=fee_limit,json=feeLimit,proto3" json:"fee_limit,omitempty"`
	// The channel id of the channel that must be taken to the first hop. If zero,
	// any channel may be used.
	OutgoingChanId uint64 `protobuf:"varint,9,opt,name=outgoing_chan_id,json=outgoingChanId,proto3" json:"outgoing_chan_id,omitempty"`
	// The pubkey of the last hop of the route. If empty, any hop may be used.
	LastHopPubkey []byte `protobuf:"bytes,13,opt,name=last_hop_pubkey,json=lastHopPubkey,proto3" json:"last_hop_pubkey,omitempty"`
	// An optional maximum total time lock for the route. This should not exceed
	// lnd's `--max-cltv-expiry` setting. If zero, then the value of
	// `--max-cltv-expiry` is enforced.
	CltvLimit uint32 `protobuf:"varint,10,opt,name=cltv_limit,json=cltvLimit,proto3" json:"cltv_limit,omitempty"`
	// An optional field that can be used to pass an arbitrary set of TLV records
	// to a peer which understands the new records. This can be used to pass
	// application specific data during the payment attempt. Record types are
	// required to be in the custom range >= 65536. When using REST, the values
	// must be encoded as base64.
	DestCustomRecords map[uint64][]byte `protobuf:"bytes,11,rep,name=dest_custom_records,json=destCustomRecords,proto3" json:"dest_custom_records,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// If set, circular payments to self are permitted.
	AllowSelfPayment bool `protobuf:"varint,14,opt,name=allow_self_payment,json=allowSelfPayment,proto3" json:"allow_self_payment,omitempty"`
	// Features assumed to be supported by the final node. All transitive feature
	// dependencies must also be set properly. For a given feature bit pair, either
	// optional or remote may be set, but not both. If this field is nil or empty,
	// the router will try to load destination features from the graph as a
	// fallback.
	DestFeatures []FeatureBit `protobuf:"varint,15,rep,packed,name=dest_features,json=destFeatures,proto3,enum=lnrpc.FeatureBit" json:"dest_features,omitempty"`
	// The payment address of the generated invoice.  This is also called
	// payment secret in specifications (e.g. BOLT 11).
	PaymentAddr   []byte `protobuf:"bytes,16,opt,name=payment_addr,json=paymentAddr,proto3" json:"payment_addr,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SendRequest) Reset() {
	*x = SendRequest{}
	mi := &file_lightning_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendRequest) ProtoMessage() {}

func (x *SendRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendRequest.ProtoReflect.Descriptor instead.
func (*SendRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{16}
}

func (x *SendRequest) GetDest() []byte {
	if x != nil {
		return x.Dest
	}
	return nil
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *SendRequest) GetDestString() string {
	if x != nil {
		return x.DestString
	}
	return ""
}

func (x *SendRequest) GetAmt() int64 {
	if x != nil {
		return x.Amt
	}
	return 0
}

func (x *SendRequest) GetAmtMsat() int64 {
	if x != nil {
		return x.AmtMsat
	}
	return 0
}

func (x *SendRequest) GetPaymentHash() []byte {
	if x != nil {
		return x.PaymentHash
	}
	return nil
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *SendRequest) GetPaymentHashString() string {
	if x != nil {
		return x.PaymentHashString
	}
	return ""
}

func (x *SendRequest) GetPaymentRequest() string {
	if x != nil {
		return x.PaymentRequest
	}
	return ""
}

func (x *SendRequest) GetFinalCltvDelta() int32 {
	if x != nil {
		return x.FinalCltvDelta
	}
	return 0
}

func (x *SendRequest) GetFeeLimit() *FeeLimit {
	if x != nil {
		return x.FeeLimit
	}
	return nil
}

func (x *SendRequest) GetOutgoingChanId() uint64 {
	if x != nil {
		return x.OutgoingChanId
	}
	return 0
}

func (x *SendRequest) GetLastHopPubkey() []byte {
	if x != nil {
		return x.LastHopPubkey
	}
	return nil
}

func (x *SendRequest) GetCltvLimit() uint32 {
	if x != nil {
		return x.CltvLimit
	}
	return 0
}

func (x *SendRequest) GetDestCustomRecords() map[uint64][]byte {
	if x != nil {
		return x.DestCustomRecords
	}
	return nil
}

func (x *SendRequest) GetAllowSelfPayment() bool {
	if x != nil {
		return x.AllowSelfPayment
	}
	return false
}

func (x *SendRequest) GetDestFeatures() []FeatureBit {
	if x != nil {
		return x.DestFeatures
	}
	return nil
}

func (x *SendRequest) GetPaymentAddr() []byte {
	if x != nil {
		return x.PaymentAddr
	}
	return nil
}

type SendResponse struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	PaymentError    string                 `protobuf:"bytes,1,opt,name=payment_error,json=paymentError,proto3" json:"payment_error,omitempty"`
	PaymentPreimage []byte                 `protobuf:"bytes,2,opt,name=payment_preimage,json=paymentPreimage,proto3" json:"payment_preimage,omitempty"`
	PaymentRoute    *Route                 `protobuf:"bytes,3,opt,name=payment_route,json=paymentRoute,proto3" json:"payment_route,omitempty"`
	PaymentHash     []byte                 `protobuf:"bytes,4,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SendResponse) Reset() {
	*x = SendResponse{}
	mi := &file_lightning_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendResponse) ProtoMessage() {}

func (x *SendResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendResponse.ProtoReflect.Descriptor instead.
func (*SendResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{17}
}

func (x *SendResponse) GetPaymentError() string {
	if x != nil {
		return x.PaymentError
	}
	return ""
}

func (x *SendResponse) GetPaymentPreimage() []byte {
	if x != nil {
		return x.PaymentPreimage
	}
	return nil
}

func (x *SendResponse) GetPaymentRoute() *Route {
	if x != nil {
		return x.PaymentRoute
	}
	return nil
}

func (x *SendResponse) GetPaymentHash() []byte {
	if x != nil {
		return x.PaymentHash
	}
	return nil
}

type SendToRouteRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The payment hash to use for the HTLC. When using REST, this field must be
	// encoded as base64.
	PaymentHash []byte `protobuf:"bytes,1,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	// An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
	// that the REST gateway supports base64 encoding of bytes fields.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	PaymentHashString string `protobuf:"bytes,2,opt,name=payment_hash_string,json=paymentHashString,proto3" json:"payment_hash_string,omitempty"`
	// Route that should be used to attempt to complete the payment.
	Route         *Route `protobuf:"bytes,4,opt,name=route,proto3" json:"route,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SendToRouteRequest) Reset() {
	*x = SendToRouteRequest{}
	mi := &file_lightning_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendToRouteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendToRouteRequest) ProtoMessage() {}

func (x *SendToRouteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendToRouteRequest.ProtoReflect.Descriptor instead.
func (*SendToRouteRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{18}
}

func (x *SendToRouteRequest) GetPaymentHash() []byte {
	if x != nil {
		return x.PaymentHash
	}
	return nil
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *SendToRouteRequest) GetPaymentHashString() string {
	if x != nil {
		return x.PaymentHashString
	}
	return ""
}

func (x *SendToRouteRequest) GetRoute() *Route {
	if x != nil {
		return x.Route
	}
	return nil
}

type ChannelAcceptRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The pubkey of the node that wishes to open an inbound channel.
	NodePubkey []byte `protobuf:"bytes,1,opt,name=node_pubkey,json=nodePubkey,proto3" json:"node_pubkey,omitempty"`
	// The hash of the genesis block that the proposed channel resides in.
	ChainHash []byte `protobuf:"bytes,2,opt,name=chain_hash,json=chainHash,proto3" json:"chain_hash,omitempty"`
	// The pending channel id.
	PendingChanId []byte `protobuf:"bytes,3,opt,name=pending_chan_id,json=pendingChanId,proto3" json:"pending_chan_id,omitempty"`
	// The funding amount in satoshis that initiator wishes to use in the
	// channel.
	FundingAmt uint64 `protobuf:"varint,4,opt,name=funding_amt,json=fundingAmt,proto3" json:"funding_amt,omitempty"`
	// The push amount of the proposed channel in millisatoshis.
	PushAmt uint64 `protobuf:"varint,5,opt,name=push_amt,json=pushAmt,proto3" json:"push_amt,omitempty"`
	// The dust limit of the initiator's commitment tx.
	DustLimit uint64 `protobuf:"varint,6,opt,name=dust_limit,json=dustLimit,proto3" json:"dust_limit,omitempty"`
	// The maximum amount of coins in millisatoshis that can be pending in this
	// channel.
	MaxValueInFlight uint64 `protobuf:"varint,7,opt,name=max_value_in_flight,json=maxValueInFlight,proto3" json:"max_value_in_flight,omitempty"`
	// The minimum amount of satoshis the initiator requires us to have at all
	// times.
	ChannelReserve uint64 `protobuf:"varint,8,opt,name=channel_reserve,json=channelReserve,proto3" json:"channel_reserve,omitempty"`
	// The smallest HTLC in millisatoshis that the initiator will accept.
	MinHtlc uint64 `protobuf:"varint,9,opt,name=min_htlc,json=minHtlc,proto3" json:"min_htlc,omitempty"`
	// The initial fee rate that the initiator suggests for both commitment
	// transactions.
	FeePerKw uint64 `protobuf:"varint,10,opt,name=fee_per_kw,json=feePerKw,proto3" json:"fee_per_kw,omitempty"`
	// The number of blocks to use for the relative time lock in the pay-to-self
	// output of both commitment transactions.
	CsvDelay uint32 `protobuf:"varint,11,opt,name=csv_delay,json=csvDelay,proto3" json:"csv_delay,omitempty"`
	// The total number of incoming HTLC's that the initiator will accept.
	MaxAcceptedHtlcs uint32 `protobuf:"varint,12,opt,name=max_accepted_htlcs,json=maxAcceptedHtlcs,proto3" json:"max_accepted_htlcs,omitempty"`
	// A bit-field which the initiator uses to specify proposed channel
	// behavior.
	ChannelFlags uint32 `protobuf:"varint,13,opt,name=channel_flags,json=channelFlags,proto3" json:"channel_flags,omitempty"`
	// The commitment type the initiator wishes to use for the proposed channel.
	CommitmentType CommitmentType `protobuf:"varint,14,opt,name=commitment_type,json=commitmentType,proto3,enum=lnrpc.CommitmentType" json:"commitment_type,omitempty"`
	// Whether the initiator wants to open a zero-conf channel via the channel
	// type.
	WantsZeroConf bool `protobuf:"varint,15,opt,name=wants_zero_conf,json=wantsZeroConf,proto3" json:"wants_zero_conf,omitempty"`
	// Whether the initiator wants to use the scid-alias channel type. This is
	// separate from the feature bit.
	WantsScidAlias bool `protobuf:"varint,16,opt,name=wants_scid_alias,json=wantsScidAlias,proto3" json:"wants_scid_alias,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ChannelAcceptRequest) Reset() {
	*x = ChannelAcceptRequest{}
	mi := &file_lightning_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelAcceptRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelAcceptRequest) ProtoMessage() {}

func (x *ChannelAcceptRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelAcceptRequest.ProtoReflect.Descriptor instead.
func (*ChannelAcceptRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{19}
}

func (x *ChannelAcceptRequest) GetNodePubkey() []byte {
	if x != nil {
		return x.NodePubkey
	}
	return nil
}

func (x *ChannelAcceptRequest) GetChainHash() []byte {
	if x != nil {
		return x.ChainHash
	}
	return nil
}

func (x *ChannelAcceptRequest) GetPendingChanId() []byte {
	if x != nil {
		return x.PendingChanId
	}
	return nil
}

func (x *ChannelAcceptRequest) GetFundingAmt() uint64 {
	if x != nil {
		return x.FundingAmt
	}
	return 0
}

func (x *ChannelAcceptRequest) GetPushAmt() uint64 {
	if x != nil {
		return x.PushAmt
	}
	return 0
}

func (x *ChannelAcceptRequest) GetDustLimit() uint64 {
	if x != nil {
		return x.DustLimit
	}
	return 0
}

func (x *ChannelAcceptRequest) GetMaxValueInFlight() uint64 {
	if x != nil {
		return x.MaxValueInFlight
	}
	return 0
}

func (x *ChannelAcceptRequest) GetChannelReserve() uint64 {
	if x != nil {
		return x.ChannelReserve
	}
	return 0
}

func (x *ChannelAcceptRequest) GetMinHtlc() uint64 {
	if x != nil {
		return x.MinHtlc
	}
	return 0
}

func (x *ChannelAcceptRequest) GetFeePerKw() uint64 {
	if x != nil {
		return x.FeePerKw
	}
	return 0
}

func (x *ChannelAcceptRequest) GetCsvDelay() uint32 {
	if x != nil {
		return x.CsvDelay
	}
	return 0
}

func (x *ChannelAcceptRequest) GetMaxAcceptedHtlcs() uint32 {
	if x != nil {
		return x.MaxAcceptedHtlcs
	}
	return 0
}

func (x *ChannelAcceptRequest) GetChannelFlags() uint32 {
	if x != nil {
		return x.ChannelFlags
	}
	return 0
}

func (x *ChannelAcceptRequest) GetCommitmentType() CommitmentType {
	if x != nil {
		return x.CommitmentType
	}
	return CommitmentType_UNKNOWN_COMMITMENT_TYPE
}

func (x *ChannelAcceptRequest) GetWantsZeroConf() bool {
	if x != nil {
		return x.WantsZeroConf
	}
	return false
}

func (x *ChannelAcceptRequest) GetWantsScidAlias() bool {
	if x != nil {
		return x.WantsScidAlias
	}
	return false
}

type ChannelAcceptResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether or not the client accepts the channel.
	Accept bool `protobuf:"varint,1,opt,name=accept,proto3" json:"accept,omitempty"`
	// The pending channel id to which this response applies.
	PendingChanId []byte `protobuf:"bytes,2,opt,name=pending_chan_id,json=pendingChanId,proto3" json:"pending_chan_id,omitempty"`
	// An optional error to send the initiating party to indicate why the channel
	// was rejected. This field *should not* contain sensitive information, it will
	// be sent to the initiating party. This field should only be set if accept is
	// false, the channel will be rejected if an error is set with accept=true
	// because the meaning of this response is ambiguous. Limited to 500
	// characters.
	Error string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	// The upfront shutdown address to use if the initiating peer supports option
	// upfront shutdown script (see ListPeers for the features supported). Note
	// that the channel open will fail if this value is set for a peer that does
	// not support this feature bit.
	UpfrontShutdown string `protobuf:"bytes,4,opt,name=upfront_shutdown,json=upfrontShutdown,proto3" json:"upfront_shutdown,omitempty"`
	// The csv delay (in blocks) that we require for the remote party.
	CsvDelay uint32 `protobuf:"varint,5,opt,name=csv_delay,json=csvDelay,proto3" json:"csv_delay,omitempty"`
	// The reserve amount in satoshis that we require the remote peer to adhere to.
	// We require that the remote peer always have some reserve amount allocated to
	// them so that there is always a disincentive to broadcast old state (if they
	// hold 0 sats on their side of the channel, there is nothing to lose).
	ReserveSat uint64 `protobuf:"varint,6,opt,name=reserve_sat,json=reserveSat,proto3" json:"reserve_sat,omitempty"`
	// The maximum amount of funds in millisatoshis that we allow the remote peer
	// to have in outstanding htlcs.
	InFlightMaxMsat uint64 `protobuf:"varint,7,opt,name=in_flight_max_msat,json=inFlightMaxMsat,proto3" json:"in_flight_max_msat,omitempty"`
	// The maximum number of htlcs that the remote peer can offer us.
	MaxHtlcCount uint32 `protobuf:"varint,8,opt,name=max_htlc_count,json=maxHtlcCount,proto3" json:"max_htlc_count,omitempty"`
	// The minimum value in millisatoshis for incoming htlcs on the channel.
	MinHtlcIn uint64 `protobuf:"varint,9,opt,name=min_htlc_in,json=minHtlcIn,proto3" json:"min_htlc_in,omitempty"`
	// The number of confirmations we require before we consider the channel open.
	MinAcceptDepth uint32 `protobuf:"varint,10,opt,name=min_accept_depth,json=minAcceptDepth,proto3" json:"min_accept_depth,omitempty"`
	// Whether the responder wants this to be a zero-conf channel. This will fail
	// if either side does not have the scid-alias feature bit set. The minimum
	// depth field must be zero if this is true.
	ZeroConf      bool `protobuf:"varint,11,opt,name=zero_conf,json=zeroConf,proto3" json:"zero_conf,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChannelAcceptResponse) Reset() {
	*x = ChannelAcceptResponse{}
	mi := &file_lightning_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelAcceptResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelAcceptResponse) ProtoMessage() {}

func (x *ChannelAcceptResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelAcceptResponse.ProtoReflect.Descriptor instead.
func (*ChannelAcceptResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{20}
}

func (x *ChannelAcceptResponse) GetAccept() bool {
	if x != nil {
		return x.Accept
	}
	return false
}

func (x *ChannelAcceptResponse) GetPendingChanId() []byte {
	if x != nil {
		return x.PendingChanId
	}
	return nil
}

func (x *ChannelAcceptResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *ChannelAcceptResponse) GetUpfrontShutdown() string {
	if x != nil {
		return x.UpfrontShutdown
	}
	return ""
}

func (x *ChannelAcceptResponse) GetCsvDelay() uint32 {
	if x != nil {
		return x.CsvDelay
	}
	return 0
}

func (x *ChannelAcceptResponse) GetReserveSat() uint64 {
	if x != nil {
		return x.ReserveSat
	}
	return 0
}

func (x *ChannelAcceptResponse) GetInFlightMaxMsat() uint64 {
	if x != nil {
		return x.InFlightMaxMsat
	}
	return 0
}

func (x *ChannelAcceptResponse) GetMaxHtlcCount() uint32 {
	if x != nil {
		return x.MaxHtlcCount
	}
	return 0
}

func (x *ChannelAcceptResponse) GetMinHtlcIn() uint64 {
	if x != nil {
		return x.MinHtlcIn
	}
	return 0
}

func (x *ChannelAcceptResponse) GetMinAcceptDepth() uint32 {
	if x != nil {
		return x.MinAcceptDepth
	}
	return 0
}

func (x *ChannelAcceptResponse) GetZeroConf() bool {
	if x != nil {
		return x.ZeroConf
	}
	return false
}

type ChannelPoint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to FundingTxid:
	//
	//	*ChannelPoint_FundingTxidBytes
	//	*ChannelPoint_FundingTxidStr
	FundingTxid isChannelPoint_FundingTxid `protobuf_oneof:"funding_txid"`
	// The index of the output of the funding transaction
	OutputIndex   uint32 `protobuf:"varint,3,opt,name=output_index,json=outputIndex,proto3" json:"output_index,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChannelPoint) Reset() {
	*x = ChannelPoint{}
	mi := &file_lightning_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelPoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelPoint) ProtoMessage() {}

func (x *ChannelPoint) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelPoint.ProtoReflect.Descriptor instead.
func (*ChannelPoint) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{21}
}

func (x *ChannelPoint) GetFundingTxid() isChannelPoint_FundingTxid {
	if x != nil {
		return x.FundingTxid
	}
	return nil
}

func (x *ChannelPoint) GetFundingTxidBytes() []byte {
	if x != nil {
		if x, ok := x.FundingTxid.(*ChannelPoint_FundingTxidBytes); ok {
			return x.FundingTxidBytes
		}
	}
	return nil
}

func (x *ChannelPoint) GetFundingTxidStr() string {
	if x != nil {
		if x, ok := x.FundingTxid.(*ChannelPoint_FundingTxidStr); ok {
			return x.FundingTxidStr
		}
	}
	return ""
}

func (x *ChannelPoint) GetOutputIndex() uint32 {
	if x != nil {
		return x.OutputIndex
	}
	return 0
}

type isChannelPoint_FundingTxid interface {
	isChannelPoint_FundingTxid()
}

type ChannelPoint_FundingTxidBytes struct {
	// Txid of the funding transaction. When using REST, this field must be
	// encoded as base64.
	FundingTxidBytes []byte `protobuf:"bytes,1,opt,name=funding_txid_bytes,json=fundingTxidBytes,proto3,oneof"`
}

type ChannelPoint_FundingTxidStr struct {
	// Hex-encoded string representing the byte-reversed hash of the funding
	// transaction.
	FundingTxidStr string `protobuf:"bytes,2,opt,name=funding_txid_str,json=fundingTxidStr,proto3,oneof"`
}

func (*ChannelPoint_FundingTxidBytes) isChannelPoint_FundingTxid() {}

func (*ChannelPoint_FundingTxidStr) isChannelPoint_FundingTxid() {}

type OutPoint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Raw bytes representing the transaction id.
	TxidBytes []byte `protobuf:"bytes,1,opt,name=txid_bytes,json=txidBytes,proto3" json:"txid_bytes,omitempty"`
	// Reversed, hex-encoded string representing the transaction id.
	TxidStr string `protobuf:"bytes,2,opt,name=txid_str,json=txidStr,proto3" json:"txid_str,omitempty"`
	// The index of the output on the transaction.
	OutputIndex   uint32 `protobuf:"varint,3,opt,name=output_index,json=outputIndex,proto3" json:"output_index,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OutPoint) Reset() {
	*x = OutPoint{}
	mi := &file_lightning_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutPoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutPoint) ProtoMessage() {}

func (x *OutPoint) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutPoint.ProtoReflect.Descriptor instead.
func (*OutPoint) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{22}
}

func (x *OutPoint) GetTxidBytes() []byte {
	if x != nil {
		return x.TxidBytes
	}
	return nil
}

func (x *OutPoint) GetTxidStr() string {
	if x != nil {
		return x.TxidStr
	}
	return ""
}

func (x *OutPoint) GetOutputIndex() uint32 {
	if x != nil {
		return x.OutputIndex
	}
	return 0
}

type PreviousOutPoint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The outpoint in format txid:n.
	Outpoint string `protobuf:"bytes,1,opt,name=outpoint,proto3" json:"outpoint,omitempty"`
	// Denotes if the outpoint is controlled by the internal wallet.
	// The flag will only detect p2wkh, np2wkh and p2tr inputs as its own.
	IsOurOutput   bool `protobuf:"varint,2,opt,name=is_our_output,json=isOurOutput,proto3" json:"is_our_output,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PreviousOutPoint) Reset() {
	*x = PreviousOutPoint{}
	mi := &file_lightning_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PreviousOutPoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PreviousOutPoint) ProtoMessage() {}

func (x *PreviousOutPoint) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PreviousOutPoint.ProtoReflect.Descriptor instead.
func (*PreviousOutPoint) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{23}
}

func (x *PreviousOutPoint) GetOutpoint() string {
	if x != nil {
		return x.Outpoint
	}
	return ""
}

func (x *PreviousOutPoint) GetIsOurOutput() bool {
	if x != nil {
		return x.IsOurOutput
	}
	return false
}

type LightningAddress struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identity pubkey of the Lightning node.
	Pubkey string `protobuf:"bytes,1,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
	// The network location of the lightning node, e.g. `69.69.69.69:1337` or
	// `localhost:10011`.
	Host          string `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LightningAddress) Reset() {
	*x = LightningAddress{}
	mi := &file_lightning_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LightningAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LightningAddress) ProtoMessage() {}

func (x *LightningAddress) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LightningAddress.ProtoReflect.Descriptor instead.
func (*LightningAddress) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{24}
}

func (x *LightningAddress) GetPubkey() string {
	if x != nil {
		return x.Pubkey
	}
	return ""
}

func (x *LightningAddress) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

type EstimateFeeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The map from addresses to amounts for the transaction.
	AddrToAmount map[string]int64 `protobuf:"bytes,1,rep,name=AddrToAmount,proto3" json:"AddrToAmount,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// The target number of blocks that this transaction should be confirmed
	// by.
	TargetConf int32 `protobuf:"varint,2,opt,name=target_conf,json=targetConf,proto3" json:"target_conf,omitempty"`
	// The minimum number of confirmations each one of your outputs used for
	// the transaction must satisfy.
	MinConfs int32 `protobuf:"varint,3,opt,name=min_confs,json=minConfs,proto3" json:"min_confs,omitempty"`
	// Whether unconfirmed outputs should be used as inputs for the transaction.
	SpendUnconfirmed bool `protobuf:"varint,4,opt,name=spend_unconfirmed,json=spendUnconfirmed,proto3" json:"spend_unconfirmed,omitempty"`
	// The strategy to use for selecting coins during fees estimation.
	CoinSelectionStrategy CoinSelectionStrategy `protobuf:"varint,5,opt,name=coin_selection_strategy,json=coinSelectionStrategy,proto3,enum=lnrpc.CoinSelectionStrategy" json:"coin_selection_strategy,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *EstimateFeeRequest) Reset() {
	*x = EstimateFeeRequest{}
	mi := &file_lightning_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EstimateFeeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EstimateFeeRequest) ProtoMessage() {}

func (x *EstimateFeeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EstimateFeeRequest.ProtoReflect.Descriptor instead.
func (*EstimateFeeRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{25}
}

func (x *EstimateFeeRequest) GetAddrToAmount() map[string]int64 {
	if x != nil {
		return x.AddrToAmount
	}
	return nil
}

func (x *EstimateFeeRequest) GetTargetConf() int32 {
	if x != nil {
		return x.TargetConf
	}
	return 0
}

func (x *EstimateFeeRequest) GetMinConfs() int32 {
	if x != nil {
		return x.MinConfs
	}
	return 0
}

func (x *EstimateFeeRequest) GetSpendUnconfirmed() bool {
	if x != nil {
		return x.SpendUnconfirmed
	}
	return false
}

func (x *EstimateFeeRequest) GetCoinSelectionStrategy() CoinSelectionStrategy {
	if x != nil {
		return x.CoinSelectionStrategy
	}
	return CoinSelectionStrategy_STRATEGY_USE_GLOBAL_CONFIG
}

type EstimateFeeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The total fee in satoshis.
	FeeSat int64 `protobuf:"varint,1,opt,name=fee_sat,json=feeSat,proto3" json:"fee_sat,omitempty"`
	// Deprecated, use sat_per_vbyte.
	// The fee rate in satoshi/vbyte.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	FeerateSatPerByte int64 `protobuf:"varint,2,opt,name=feerate_sat_per_byte,json=feerateSatPerByte,proto3" json:"feerate_sat_per_byte,omitempty"`
	// The fee rate in satoshi/vbyte.
	SatPerVbyte   uint64 `protobuf:"varint,3,opt,name=sat_per_vbyte,json=satPerVbyte,proto3" json:"sat_per_vbyte,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EstimateFeeResponse) Reset() {
	*x = EstimateFeeResponse{}
	mi := &file_lightning_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EstimateFeeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EstimateFeeResponse) ProtoMessage() {}

func (x *EstimateFeeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EstimateFeeResponse.ProtoReflect.Descriptor instead.
func (*EstimateFeeResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{26}
}

func (x *EstimateFeeResponse) GetFeeSat() int64 {
	if x != nil {
		return x.FeeSat
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *EstimateFeeResponse) GetFeerateSatPerByte() int64 {
	if x != nil {
		return x.FeerateSatPerByte
	}
	return 0
}

func (x *EstimateFeeResponse) GetSatPerVbyte() uint64 {
	if x != nil {
		return x.SatPerVbyte
	}
	return 0
}

type SendManyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The map from addresses to amounts
	AddrToAmount map[string]int64 `protobuf:"bytes,1,rep,name=AddrToAmount,proto3" json:"AddrToAmount,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// The target number of blocks that this transaction should be confirmed
	// by.
	TargetConf int32 `protobuf:"varint,3,opt,name=target_conf,json=targetConf,proto3" json:"target_conf,omitempty"`
	// A manual fee rate set in sat/vbyte that should be used when crafting the
	// transaction.
	SatPerVbyte uint64 `protobuf:"varint,4,opt,name=sat_per_vbyte,json=satPerVbyte,proto3" json:"sat_per_vbyte,omitempty"`
	// Deprecated, use sat_per_vbyte.
	// A manual fee rate set in sat/vbyte that should be used when crafting the
	// transaction.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	SatPerByte int64 `protobuf:"varint,5,opt,name=sat_per_byte,json=satPerByte,proto3" json:"sat_per_byte,omitempty"`
	// An optional label for the transaction, limited to 500 characters.
	Label string `protobuf:"bytes,6,opt,name=label,proto3" json:"label,omitempty"`
	// The minimum number of confirmations each one of your outputs used for
	// the transaction must satisfy.
	MinConfs int32 `protobuf:"varint,7,opt,name=min_confs,json=minConfs,proto3" json:"min_confs,omitempty"`
	// Whether unconfirmed outputs should be used as inputs for the transaction.
	SpendUnconfirmed bool `protobuf:"varint,8,opt,name=spend_unconfirmed,json=spendUnconfirmed,proto3" json:"spend_unconfirmed,omitempty"`
	// The strategy to use for selecting coins during sending many requests.
	CoinSelectionStrategy CoinSelectionStrategy `protobuf:"varint,9,opt,name=coin_selection_strategy,json=coinSelectionStrategy,proto3,enum=lnrpc.CoinSelectionStrategy" json:"coin_selection_strategy,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *SendManyRequest) Reset() {
	*x = SendManyRequest{}
	mi := &file_lightning_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendManyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendManyRequest) ProtoMessage() {}

func (x *SendManyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendManyRequest.ProtoReflect.Descriptor instead.
func (*SendManyRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{27}
}

func (x *SendManyRequest) GetAddrToAmount() map[string]int64 {
	if x != nil {
		return x.AddrToAmount
	}
	return nil
}

func (x *SendManyRequest) GetTargetConf() int32 {
	if x != nil {
		return x.TargetConf
	}
	return 0
}

func (x *SendManyRequest) GetSatPerVbyte() uint64 {
	if x != nil {
		return x.SatPerVbyte
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *SendManyRequest) GetSatPerByte() int64 {
	if x != nil {
		return x.SatPerByte
	}
	return 0
}

func (x *SendManyRequest) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *SendManyRequest) GetMinConfs() int32 {
	if x != nil {
		return x.MinConfs
	}
	return 0
}

func (x *SendManyRequest) GetSpendUnconfirmed() bool {
	if x != nil {
		return x.SpendUnconfirmed
	}
	return false
}

func (x *SendManyRequest) GetCoinSelectionStrategy() CoinSelectionStrategy {
	if x != nil {
		return x.CoinSelectionStrategy
	}
	return CoinSelectionStrategy_STRATEGY_USE_GLOBAL_CONFIG
}

type SendManyResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The id of the transaction
	Txid          string `protobuf:"bytes,1,opt,name=txid,proto3" json:"txid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SendManyResponse) Reset() {
	*x = SendManyResponse{}
	mi := &file_lightning_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendManyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendManyResponse) ProtoMessage() {}

func (x *SendManyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendManyResponse.ProtoReflect.Descriptor instead.
func (*SendManyResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{28}
}

func (x *SendManyResponse) GetTxid() string {
	if x != nil {
		return x.Txid
	}
	return ""
}

type SendCoinsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The address to send coins to
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	// The amount in satoshis to send
	Amount int64 `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
	// The target number of blocks that this transaction should be confirmed
	// by.
	TargetConf int32 `protobuf:"varint,3,opt,name=target_conf,json=targetConf,proto3" json:"target_conf,omitempty"`
	// A manual fee rate set in sat/vbyte that should be used when crafting the
	// transaction.
	SatPerVbyte uint64 `protobuf:"varint,4,opt,name=sat_per_vbyte,json=satPerVbyte,proto3" json:"sat_per_vbyte,omitempty"`
	// Deprecated, use sat_per_vbyte.
	// A manual fee rate set in sat/vbyte that should be used when crafting the
	// transaction.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	SatPerByte int64 `protobuf:"varint,5,opt,name=sat_per_byte,json=satPerByte,proto3" json:"sat_per_byte,omitempty"`
	// If set, the amount field should be unset. It indicates lnd will send all
	// wallet coins or all selected coins to the specified address.
	SendAll bool `protobuf:"varint,6,opt,name=send_all,json=sendAll,proto3" json:"send_all,omitempty"`
	// An optional label for the transaction, limited to 500 characters.
	Label string `protobuf:"bytes,7,opt,name=label,proto3" json:"label,omitempty"`
	// The minimum number of confirmations each one of your outputs used for
	// the transaction must satisfy.
	MinConfs int32 `protobuf:"varint,8,opt,name=min_confs,json=minConfs,proto3" json:"min_confs,omitempty"`
	// Whether unconfirmed outputs should be used as inputs for the transaction.
	SpendUnconfirmed bool `protobuf:"varint,9,opt,name=spend_unconfirmed,json=spendUnconfirmed,proto3" json:"spend_unconfirmed,omitempty"`
	// The strategy to use for selecting coins.
	CoinSelectionStrategy CoinSelectionStrategy `protobuf:"varint,10,opt,name=coin_selection_strategy,json=coinSelectionStrategy,proto3,enum=lnrpc.CoinSelectionStrategy" json:"coin_selection_strategy,omitempty"`
	// A list of selected outpoints as inputs for the transaction.
	Outpoints     []*OutPoint `protobuf:"bytes,11,rep,name=outpoints,proto3" json:"outpoints,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SendCoinsRequest) Reset() {
	*x = SendCoinsRequest{}
	mi := &file_lightning_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendCoinsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendCoinsRequest) ProtoMessage() {}

func (x *SendCoinsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendCoinsRequest.ProtoReflect.Descriptor instead.
func (*SendCoinsRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{29}
}

func (x *SendCoinsRequest) GetAddr() string {
	if x != nil {
		return x.Addr
	}
	return ""
}

func (x *SendCoinsRequest) GetAmount() int64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

func (x *SendCoinsRequest) GetTargetConf() int32 {
	if x != nil {
		return x.TargetConf
	}
	return 0
}

func (x *SendCoinsRequest) GetSatPerVbyte() uint64 {
	if x != nil {
		return x.SatPerVbyte
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *SendCoinsRequest) GetSatPerByte() int64 {
	if x != nil {
		return x.SatPerByte
	}
	return 0
}

func (x *SendCoinsRequest) GetSendAll() bool {
	if x != nil {
		return x.SendAll
	}
	return false
}

func (x *SendCoinsRequest) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *SendCoinsRequest) GetMinConfs() int32 {
	if x != nil {
		return x.MinConfs
	}
	return 0
}

func (x *SendCoinsRequest) GetSpendUnconfirmed() bool {
	if x != nil {
		return x.SpendUnconfirmed
	}
	return false
}

func (x *SendCoinsRequest) GetCoinSelectionStrategy() CoinSelectionStrategy {
	if x != nil {
		return x.CoinSelectionStrategy
	}
	return CoinSelectionStrategy_STRATEGY_USE_GLOBAL_CONFIG
}

func (x *SendCoinsRequest) GetOutpoints() []*OutPoint {
	if x != nil {
		return x.Outpoints
	}
	return nil
}

type SendCoinsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The transaction ID of the transaction
	Txid          string `protobuf:"bytes,1,opt,name=txid,proto3" json:"txid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SendCoinsResponse) Reset() {
	*x = SendCoinsResponse{}
	mi := &file_lightning_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendCoinsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendCoinsResponse) ProtoMessage() {}

func (x *SendCoinsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendCoinsResponse.ProtoReflect.Descriptor instead.
func (*SendCoinsResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{30}
}

func (x *SendCoinsResponse) GetTxid() string {
	if x != nil {
		return x.Txid
	}
	return ""
}

type ListUnspentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The minimum number of confirmations to be included.
	MinConfs int32 `protobuf:"varint,1,opt,name=min_confs,json=minConfs,proto3" json:"min_confs,omitempty"`
	// The maximum number of confirmations to be included.
	MaxConfs int32 `protobuf:"varint,2,opt,name=max_confs,json=maxConfs,proto3" json:"max_confs,omitempty"`
	// An optional filter to only include outputs belonging to an account.
	Account       string `protobuf:"bytes,3,opt,name=account,proto3" json:"account,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListUnspentRequest) Reset() {
	*x = ListUnspentRequest{}
	mi := &file_lightning_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListUnspentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListUnspentRequest) ProtoMessage() {}

func (x *ListUnspentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListUnspentRequest.ProtoReflect.Descriptor instead.
func (*ListUnspentRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{31}
}

func (x *ListUnspentRequest) GetMinConfs() int32 {
	if x != nil {
		return x.MinConfs
	}
	return 0
}

func (x *ListUnspentRequest) GetMaxConfs() int32 {
	if x != nil {
		return x.MaxConfs
	}
	return 0
}

func (x *ListUnspentRequest) GetAccount() string {
	if x != nil {
		return x.Account
	}
	return ""
}

type ListUnspentResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of utxos
	Utxos         []*Utxo `protobuf:"bytes,1,rep,name=utxos,proto3" json:"utxos,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListUnspentResponse) Reset() {
	*x = ListUnspentResponse{}
	mi := &file_lightning_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListUnspentResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListUnspentResponse) ProtoMessage() {}

func (x *ListUnspentResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListUnspentResponse.ProtoReflect.Descriptor instead.
func (*ListUnspentResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{32}
}

func (x *ListUnspentResponse) GetUtxos() []*Utxo {
	if x != nil {
		return x.Utxos
	}
	return nil
}

type NewAddressRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of address to generate.
	Type AddressType `protobuf:"varint,1,opt,name=type,proto3,enum=lnrpc.AddressType" json:"type,omitempty"`
	// The name of the account to generate a new address for. If empty, the
	// default wallet account is used.
	Account       string `protobuf:"bytes,2,opt,name=account,proto3" json:"account,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NewAddressRequest) Reset() {
	*x = NewAddressRequest{}
	mi := &file_lightning_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NewAddressRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NewAddressRequest) ProtoMessage() {}

func (x *NewAddressRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NewAddressRequest.ProtoReflect.Descriptor instead.
func (*NewAddressRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{33}
}

func (x *NewAddressRequest) GetType() AddressType {
	if x != nil {
		return x.Type
	}
	return AddressType_WITNESS_PUBKEY_HASH
}

func (x *NewAddressRequest) GetAccount() string {
	if x != nil {
		return x.Account
	}
	return ""
}

type NewAddressResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The newly generated wallet address
	Address       string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NewAddressResponse) Reset() {
	*x = NewAddressResponse{}
	mi := &file_lightning_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NewAddressResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NewAddressResponse) ProtoMessage() {}

func (x *NewAddressResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NewAddressResponse.ProtoReflect.Descriptor instead.
func (*NewAddressResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{34}
}

func (x *NewAddressResponse) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

type SignMessageRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The message to be signed. When using REST, this field must be encoded as
	// base64.
	Msg []byte `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	// Instead of the default double-SHA256 hashing of the message before signing,
	// only use one round of hashing instead.
	SingleHash    bool `protobuf:"varint,2,opt,name=single_hash,json=singleHash,proto3" json:"single_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SignMessageRequest) Reset() {
	*x = SignMessageRequest{}
	mi := &file_lightning_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignMessageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignMessageRequest) ProtoMessage() {}

func (x *SignMessageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignMessageRequest.ProtoReflect.Descriptor instead.
func (*SignMessageRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{35}
}

func (x *SignMessageRequest) GetMsg() []byte {
	if x != nil {
		return x.Msg
	}
	return nil
}

func (x *SignMessageRequest) GetSingleHash() bool {
	if x != nil {
		return x.SingleHash
	}
	return false
}

type SignMessageResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The signature for the given message
	Signature     string `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SignMessageResponse) Reset() {
	*x = SignMessageResponse{}
	mi := &file_lightning_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignMessageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignMessageResponse) ProtoMessage() {}

func (x *SignMessageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignMessageResponse.ProtoReflect.Descriptor instead.
func (*SignMessageResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{36}
}

func (x *SignMessageResponse) GetSignature() string {
	if x != nil {
		return x.Signature
	}
	return ""
}

type VerifyMessageRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The message over which the signature is to be verified. When using REST,
	// this field must be encoded as base64.
	Msg []byte `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	// The signature to be verified over the given message
	Signature     string `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VerifyMessageRequest) Reset() {
	*x = VerifyMessageRequest{}
	mi := &file_lightning_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VerifyMessageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerifyMessageRequest) ProtoMessage() {}

func (x *VerifyMessageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VerifyMessageRequest.ProtoReflect.Descriptor instead.
func (*VerifyMessageRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{37}
}

func (x *VerifyMessageRequest) GetMsg() []byte {
	if x != nil {
		return x.Msg
	}
	return nil
}

func (x *VerifyMessageRequest) GetSignature() string {
	if x != nil {
		return x.Signature
	}
	return ""
}

type VerifyMessageResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the signature was valid over the given message
	Valid bool `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
	// The pubkey recovered from the signature
	Pubkey        string `protobuf:"bytes,2,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VerifyMessageResponse) Reset() {
	*x = VerifyMessageResponse{}
	mi := &file_lightning_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VerifyMessageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerifyMessageResponse) ProtoMessage() {}

func (x *VerifyMessageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VerifyMessageResponse.ProtoReflect.Descriptor instead.
func (*VerifyMessageResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{38}
}

func (x *VerifyMessageResponse) GetValid() bool {
	if x != nil {
		return x.Valid
	}
	return false
}

func (x *VerifyMessageResponse) GetPubkey() string {
	if x != nil {
		return x.Pubkey
	}
	return ""
}

type ConnectPeerRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Lightning address of the peer to connect to.
	Addr *LightningAddress `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	// If set, the daemon will attempt to persistently connect to the target
	// peer. Otherwise, the call will be synchronous.
	Perm bool `protobuf:"varint,2,opt,name=perm,proto3" json:"perm,omitempty"`
	// The connection timeout value (in seconds) for this request. It won't affect
	// other requests.
	Timeout       uint64 `protobuf:"varint,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectPeerRequest) Reset() {
	*x = ConnectPeerRequest{}
	mi := &file_lightning_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectPeerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectPeerRequest) ProtoMessage() {}

func (x *ConnectPeerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectPeerRequest.ProtoReflect.Descriptor instead.
func (*ConnectPeerRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{39}
}

func (x *ConnectPeerRequest) GetAddr() *LightningAddress {
	if x != nil {
		return x.Addr
	}
	return nil
}

func (x *ConnectPeerRequest) GetPerm() bool {
	if x != nil {
		return x.Perm
	}
	return false
}

func (x *ConnectPeerRequest) GetTimeout() uint64 {
	if x != nil {
		return x.Timeout
	}
	return 0
}

type ConnectPeerResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The status of the connect operation.
	Status        string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectPeerResponse) Reset() {
	*x = ConnectPeerResponse{}
	mi := &file_lightning_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectPeerResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectPeerResponse) ProtoMessage() {}

func (x *ConnectPeerResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectPeerResponse.ProtoReflect.Descriptor instead.
func (*ConnectPeerResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{40}
}

func (x *ConnectPeerResponse) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

type DisconnectPeerRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The pubkey of the node to disconnect from
	PubKey        string `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DisconnectPeerRequest) Reset() {
	*x = DisconnectPeerRequest{}
	mi := &file_lightning_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DisconnectPeerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DisconnectPeerRequest) ProtoMessage() {}

func (x *DisconnectPeerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DisconnectPeerRequest.ProtoReflect.Descriptor instead.
func (*DisconnectPeerRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{41}
}

func (x *DisconnectPeerRequest) GetPubKey() string {
	if x != nil {
		return x.PubKey
	}
	return ""
}

type DisconnectPeerResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The status of the disconnect operation.
	Status        string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DisconnectPeerResponse) Reset() {
	*x = DisconnectPeerResponse{}
	mi := &file_lightning_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DisconnectPeerResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DisconnectPeerResponse) ProtoMessage() {}

func (x *DisconnectPeerResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DisconnectPeerResponse.ProtoReflect.Descriptor instead.
func (*DisconnectPeerResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{42}
}

func (x *DisconnectPeerResponse) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

type HTLC struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Incoming         bool                   `protobuf:"varint,1,opt,name=incoming,proto3" json:"incoming,omitempty"`
	Amount           int64                  `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
	HashLock         []byte                 `protobuf:"bytes,3,opt,name=hash_lock,json=hashLock,proto3" json:"hash_lock,omitempty"`
	ExpirationHeight uint32                 `protobuf:"varint,4,opt,name=expiration_height,json=expirationHeight,proto3" json:"expiration_height,omitempty"`
	// Index identifying the htlc on the channel.
	HtlcIndex uint64 `protobuf:"varint,5,opt,name=htlc_index,json=htlcIndex,proto3" json:"htlc_index,omitempty"`
	// If this HTLC is involved in a forwarding operation, this field indicates
	// the forwarding channel. For an outgoing htlc, it is the incoming channel.
	// For an incoming htlc, it is the outgoing channel. When the htlc
	// originates from this node or this node is the final destination,
	// forwarding_channel will be zero. The forwarding channel will also be zero
	// for htlcs that need to be forwarded but don't have a forwarding decision
	// persisted yet.
	ForwardingChannel uint64 `protobuf:"varint,6,opt,name=forwarding_channel,json=forwardingChannel,proto3" json:"forwarding_channel,omitempty"`
	// Index identifying the htlc on the forwarding channel.
	ForwardingHtlcIndex uint64 `protobuf:"varint,7,opt,name=forwarding_htlc_index,json=forwardingHtlcIndex,proto3" json:"forwarding_htlc_index,omitempty"`
	// Whether the HTLC is locked in. An HTLC is considered locked in when the
	// remote party has sent us the `revoke_and_ack` to irrevocably commit this
	// HTLC.
	LockedIn      bool `protobuf:"varint,8,opt,name=locked_in,json=lockedIn,proto3" json:"locked_in,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HTLC) Reset() {
	*x = HTLC{}
	mi := &file_lightning_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTLC) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTLC) ProtoMessage() {}

func (x *HTLC) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTLC.ProtoReflect.Descriptor instead.
func (*HTLC) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{43}
}

func (x *HTLC) GetIncoming() bool {
	if x != nil {
		return x.Incoming
	}
	return false
}

func (x *HTLC) GetAmount() int64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

func (x *HTLC) GetHashLock() []byte {
	if x != nil {
		return x.HashLock
	}
	return nil
}

func (x *HTLC) GetExpirationHeight() uint32 {
	if x != nil {
		return x.ExpirationHeight
	}
	return 0
}

func (x *HTLC) GetHtlcIndex() uint64 {
	if x != nil {
		return x.HtlcIndex
	}
	return 0
}

func (x *HTLC) GetForwardingChannel() uint64 {
	if x != nil {
		return x.ForwardingChannel
	}
	return 0
}

func (x *HTLC) GetForwardingHtlcIndex() uint64 {
	if x != nil {
		return x.ForwardingHtlcIndex
	}
	return 0
}

func (x *HTLC) GetLockedIn() bool {
	if x != nil {
		return x.LockedIn
	}
	return false
}

type ChannelConstraints struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The CSV delay expressed in relative blocks. If the channel is force closed,
	// we will need to wait for this many blocks before we can regain our funds.
	CsvDelay uint32 `protobuf:"varint,1,opt,name=csv_delay,json=csvDelay,proto3" json:"csv_delay,omitempty"`
	// The minimum satoshis this node is required to reserve in its balance.
	ChanReserveSat uint64 `protobuf:"varint,2,opt,name=chan_reserve_sat,json=chanReserveSat,proto3" json:"chan_reserve_sat,omitempty"`
	// The dust limit (in satoshis) of the initiator's commitment tx.
	DustLimitSat uint64 `protobuf:"varint,3,opt,name=dust_limit_sat,json=dustLimitSat,proto3" json:"dust_limit_sat,omitempty"`
	// The maximum amount of coins in millisatoshis that can be pending in this
	// channel.
	MaxPendingAmtMsat uint64 `protobuf:"varint,4,opt,name=max_pending_amt_msat,json=maxPendingAmtMsat,proto3" json:"max_pending_amt_msat,omitempty"`
	// The smallest HTLC in millisatoshis that the initiator will accept.
	MinHtlcMsat uint64 `protobuf:"varint,5,opt,name=min_htlc_msat,json=minHtlcMsat,proto3" json:"min_htlc_msat,omitempty"`
	// The total number of incoming HTLC's that the initiator will accept.
	MaxAcceptedHtlcs uint32 `protobuf:"varint,6,opt,name=max_accepted_htlcs,json=maxAcceptedHtlcs,proto3" json:"max_accepted_htlcs,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ChannelConstraints) Reset() {
	*x = ChannelConstraints{}
	mi := &file_lightning_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelConstraints) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelConstraints) ProtoMessage() {}

func (x *ChannelConstraints) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelConstraints.ProtoReflect.Descriptor instead.
func (*ChannelConstraints) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{44}
}

func (x *ChannelConstraints) GetCsvDelay() uint32 {
	if x != nil {
		return x.CsvDelay
	}
	return 0
}

func (x *ChannelConstraints) GetChanReserveSat() uint64 {
	if x != nil {
		return x.ChanReserveSat
	}
	return 0
}

func (x *ChannelConstraints) GetDustLimitSat() uint64 {
	if x != nil {
		return x.DustLimitSat
	}
	return 0
}

func (x *ChannelConstraints) GetMaxPendingAmtMsat() uint64 {
	if x != nil {
		return x.MaxPendingAmtMsat
	}
	return 0
}

func (x *ChannelConstraints) GetMinHtlcMsat() uint64 {
	if x != nil {
		return x.MinHtlcMsat
	}
	return 0
}

func (x *ChannelConstraints) GetMaxAcceptedHtlcs() uint32 {
	if x != nil {
		return x.MaxAcceptedHtlcs
	}
	return 0
}

type Channel struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether this channel is active or not
	Active bool `protobuf:"varint,1,opt,name=active,proto3" json:"active,omitempty"`
	// The identity pubkey of the remote node
	RemotePubkey string `protobuf:"bytes,2,opt,name=remote_pubkey,json=remotePubkey,proto3" json:"remote_pubkey,omitempty"`
	// The outpoint (txid:index) of the funding transaction. With this value, Bob
	// will be able to generate a signature for Alice's version of the commitment
	// transaction.
	ChannelPoint string `protobuf:"bytes,3,opt,name=channel_point,json=channelPoint,proto3" json:"channel_point,omitempty"`
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChanId uint64 `protobuf:"varint,4,opt,name=chan_id,json=chanId,proto3" json:"chan_id,omitempty"`
	// The total amount of funds held in this channel
	Capacity int64 `protobuf:"varint,5,opt,name=capacity,proto3" json:"capacity,omitempty"`
	// This node's current balance in this channel
	LocalBalance int64 `protobuf:"varint,6,opt,name=local_balance,json=localBalance,proto3" json:"local_balance,omitempty"`
	// The counterparty's current balance in this channel
	RemoteBalance int64 `protobuf:"varint,7,opt,name=remote_balance,json=remoteBalance,proto3" json:"remote_balance,omitempty"`
	// The amount calculated to be paid in fees for the current set of commitment
	// transactions. The fee amount is persisted with the channel in order to
	// allow the fee amount to be removed and recalculated with each channel state
	// update, including updates that happen after a system restart.
	CommitFee int64 `protobuf:"varint,8,opt,name=commit_fee,json=commitFee,proto3" json:"commit_fee,omitempty"`
	// The weight of the commitment transaction
	CommitWeight int64 `protobuf:"varint,9,opt,name=commit_weight,json=commitWeight,proto3" json:"commit_weight,omitempty"`
	// The required number of satoshis per kilo-weight that the requester will pay
	// at all times, for both the funding transaction and commitment transaction.
	// This value can later be updated once the channel is open.
	FeePerKw int64 `protobuf:"varint,10,opt,name=fee_per_kw,json=feePerKw,proto3" json:"fee_per_kw,omitempty"`
	// The unsettled balance in this channel
	UnsettledBalance int64 `protobuf:"varint,11,opt,name=unsettled_balance,json=unsettledBalance,proto3" json:"unsettled_balance,omitempty"`
	// The total number of satoshis we've sent within this channel.
	TotalSatoshisSent int64 `protobuf:"varint,12,opt,name=total_satoshis_sent,json=totalSatoshisSent,proto3" json:"total_satoshis_sent,omitempty"`
	// The total number of satoshis we've received within this channel.
	TotalSatoshisReceived int64 `protobuf:"varint,13,opt,name=total_satoshis_received,json=totalSatoshisReceived,proto3" json:"total_satoshis_received,omitempty"`
	// The total number of updates conducted within this channel.
	NumUpdates uint64 `protobuf:"varint,14,opt,name=num_updates,json=numUpdates,proto3" json:"num_updates,omitempty"`
	// The list of active, uncleared HTLCs currently pending within the channel.
	PendingHtlcs []*HTLC `protobuf:"bytes,15,rep,name=pending_htlcs,json=pendingHtlcs,proto3" json:"pending_htlcs,omitempty"`
	// Deprecated. The CSV delay expressed in relative blocks. If the channel is
	// force closed, we will need to wait for this many blocks before we can regain
	// our funds.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	CsvDelay uint32 `protobuf:"varint,16,opt,name=csv_delay,json=csvDelay,proto3" json:"csv_delay,omitempty"`
	// Whether this channel is advertised to the network or not.
	Private bool `protobuf:"varint,17,opt,name=private,proto3" json:"private,omitempty"`
	// True if we were the ones that created the channel.
	Initiator bool `protobuf:"varint,18,opt,name=initiator,proto3" json:"initiator,omitempty"`
	// A set of flags showing the current state of the channel.
	ChanStatusFlags string `protobuf:"bytes,19,opt,name=chan_status_flags,json=chanStatusFlags,proto3" json:"chan_status_flags,omitempty"`
	// Deprecated. The minimum satoshis this node is required to reserve in its
	// balance.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	LocalChanReserveSat int64 `protobuf:"varint,20,opt,name=local_chan_reserve_sat,json=localChanReserveSat,proto3" json:"local_chan_reserve_sat,omitempty"`
	// Deprecated. The minimum satoshis the other node is required to reserve in
	// its balance.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	RemoteChanReserveSat int64 `protobuf:"varint,21,opt,name=remote_chan_reserve_sat,json=remoteChanReserveSat,proto3" json:"remote_chan_reserve_sat,omitempty"`
	// Deprecated. Use commitment_type.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	StaticRemoteKey bool `protobuf:"varint,22,opt,name=static_remote_key,json=staticRemoteKey,proto3" json:"static_remote_key,omitempty"`
	// The commitment type used by this channel.
	CommitmentType CommitmentType `protobuf:"varint,26,opt,name=commitment_type,json=commitmentType,proto3,enum=lnrpc.CommitmentType" json:"commitment_type,omitempty"`
	// The number of seconds that the channel has been monitored by the channel
	// scoring system. Scores are currently not persisted, so this value may be
	// less than the lifetime of the channel [EXPERIMENTAL].
	Lifetime int64 `protobuf:"varint,23,opt,name=lifetime,proto3" json:"lifetime,omitempty"`
	// The number of seconds that the remote peer has been observed as being online
	// by the channel scoring system over the lifetime of the channel
	// [EXPERIMENTAL].
	Uptime int64 `protobuf:"varint,24,opt,name=uptime,proto3" json:"uptime,omitempty"`
	// Close address is the address that we will enforce payout to on cooperative
	// close if the channel was opened utilizing option upfront shutdown. This
	// value can be set on channel open by setting close_address in an open channel
	// request. If this value is not set, you can still choose a payout address by
	// cooperatively closing with the delivery_address field set.
	CloseAddress string `protobuf:"bytes,25,opt,name=close_address,json=closeAddress,proto3" json:"close_address,omitempty"`
	// The amount that the initiator of the channel optionally pushed to the remote
	// party on channel open. This amount will be zero if the channel initiator did
	// not push any funds to the remote peer. If the initiator field is true, we
	// pushed this amount to our peer, if it is false, the remote peer pushed this
	// amount to us.
	PushAmountSat uint64 `protobuf:"varint,27,opt,name=push_amount_sat,json=pushAmountSat,proto3" json:"push_amount_sat,omitempty"`
	// This uint32 indicates if this channel is to be considered 'frozen'. A
	// frozen channel doest not allow a cooperative channel close by the
	// initiator. The thaw_height is the height that this restriction stops
	// applying to the channel. This field is optional, not setting it or using a
	// value of zero will mean the channel has no additional restrictions. The
	// height can be interpreted in two ways: as a relative height if the value is
	// less than 500,000, or as an absolute height otherwise.
	ThawHeight uint32 `protobuf:"varint,28,opt,name=thaw_height,json=thawHeight,proto3" json:"thaw_height,omitempty"`
	// List constraints for the local node.
	LocalConstraints *ChannelConstraints `protobuf:"bytes,29,opt,name=local_constraints,json=localConstraints,proto3" json:"local_constraints,omitempty"`
	// List constraints for the remote node.
	RemoteConstraints *ChannelConstraints `protobuf:"bytes,30,opt,name=remote_constraints,json=remoteConstraints,proto3" json:"remote_constraints,omitempty"`
	// This lists out the set of alias short channel ids that exist for a channel.
	// This may be empty.
	AliasScids []uint64 `protobuf:"varint,31,rep,packed,name=alias_scids,json=aliasScids,proto3" json:"alias_scids,omitempty"`
	// Whether or not this is a zero-conf channel.
	ZeroConf bool `protobuf:"varint,32,opt,name=zero_conf,json=zeroConf,proto3" json:"zero_conf,omitempty"`
	// This is the confirmed / on-chain zero-conf SCID.
	ZeroConfConfirmedScid uint64 `protobuf:"varint,33,opt,name=zero_conf_confirmed_scid,json=zeroConfConfirmedScid,proto3" json:"zero_conf_confirmed_scid,omitempty"`
	// The configured alias name of our peer.
	PeerAlias string `protobuf:"bytes,34,opt,name=peer_alias,json=peerAlias,proto3" json:"peer_alias,omitempty"`
	// This is the peer SCID alias.
	PeerScidAlias uint64 `protobuf:"varint,35,opt,name=peer_scid_alias,json=peerScidAlias,proto3" json:"peer_scid_alias,omitempty"`
	// An optional note-to-self to go along with the channel containing some
	// useful information. This is only ever stored locally and in no way impacts
	// the channel's operation.
	Memo string `protobuf:"bytes,36,opt,name=memo,proto3" json:"memo,omitempty"`
	// Custom channel data that might be populated in custom channels.
	CustomChannelData []byte `protobuf:"bytes,37,opt,name=custom_channel_data,json=customChannelData,proto3" json:"custom_channel_data,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *Channel) Reset() {
	*x = Channel{}
	mi := &file_lightning_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Channel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Channel) ProtoMessage() {}

func (x *Channel) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Channel.ProtoReflect.Descriptor instead.
func (*Channel) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{45}
}

func (x *Channel) GetActive() bool {
	if x != nil {
		return x.Active
	}
	return false
}

func (x *Channel) GetRemotePubkey() string {
	if x != nil {
		return x.RemotePubkey
	}
	return ""
}

func (x *Channel) GetChannelPoint() string {
	if x != nil {
		return x.ChannelPoint
	}
	return ""
}

func (x *Channel) GetChanId() uint64 {
	if x != nil {
		return x.ChanId
	}
	return 0
}

func (x *Channel) GetCapacity() int64 {
	if x != nil {
		return x.Capacity
	}
	return 0
}

func (x *Channel) GetLocalBalance() int64 {
	if x != nil {
		return x.LocalBalance
	}
	return 0
}

func (x *Channel) GetRemoteBalance() int64 {
	if x != nil {
		return x.RemoteBalance
	}
	return 0
}

func (x *Channel) GetCommitFee() int64 {
	if x != nil {
		return x.CommitFee
	}
	return 0
}

func (x *Channel) GetCommitWeight() int64 {
	if x != nil {
		return x.CommitWeight
	}
	return 0
}

func (x *Channel) GetFeePerKw() int64 {
	if x != nil {
		return x.FeePerKw
	}
	return 0
}

func (x *Channel) GetUnsettledBalance() int64 {
	if x != nil {
		return x.UnsettledBalance
	}
	return 0
}

func (x *Channel) GetTotalSatoshisSent() int64 {
	if x != nil {
		return x.TotalSatoshisSent
	}
	return 0
}

func (x *Channel) GetTotalSatoshisReceived() int64 {
	if x != nil {
		return x.TotalSatoshisReceived
	}
	return 0
}

func (x *Channel) GetNumUpdates() uint64 {
	if x != nil {
		return x.NumUpdates
	}
	return 0
}

func (x *Channel) GetPendingHtlcs() []*HTLC {
	if x != nil {
		return x.PendingHtlcs
	}
	return nil
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *Channel) GetCsvDelay() uint32 {
	if x != nil {
		return x.CsvDelay
	}
	return 0
}

func (x *Channel) GetPrivate() bool {
	if x != nil {
		return x.Private
	}
	return false
}

func (x *Channel) GetInitiator() bool {
	if x != nil {
		return x.Initiator
	}
	return false
}

func (x *Channel) GetChanStatusFlags() string {
	if x != nil {
		return x.ChanStatusFlags
	}
	return ""
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *Channel) GetLocalChanReserveSat() int64 {
	if x != nil {
		return x.LocalChanReserveSat
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *Channel) GetRemoteChanReserveSat() int64 {
	if x != nil {
		return x.RemoteChanReserveSat
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *Channel) GetStaticRemoteKey() bool {
	if x != nil {
		return x.StaticRemoteKey
	}
	return false
}

func (x *Channel) GetCommitmentType() CommitmentType {
	if x != nil {
		return x.CommitmentType
	}
	return CommitmentType_UNKNOWN_COMMITMENT_TYPE
}

func (x *Channel) GetLifetime() int64 {
	if x != nil {
		return x.Lifetime
	}
	return 0
}

func (x *Channel) GetUptime() int64 {
	if x != nil {
		return x.Uptime
	}
	return 0
}

func (x *Channel) GetCloseAddress() string {
	if x != nil {
		return x.CloseAddress
	}
	return ""
}

func (x *Channel) GetPushAmountSat() uint64 {
	if x != nil {
		return x.PushAmountSat
	}
	return 0
}

func (x *Channel) GetThawHeight() uint32 {
	if x != nil {
		return x.ThawHeight
	}
	return 0
}

func (x *Channel) GetLocalConstraints() *ChannelConstraints {
	if x != nil {
		return x.LocalConstraints
	}
	return nil
}

func (x *Channel) GetRemoteConstraints() *ChannelConstraints {
	if x != nil {
		return x.RemoteConstraints
	}
	return nil
}

func (x *Channel) GetAliasScids() []uint64 {
	if x != nil {
		return x.AliasScids
	}
	return nil
}

func (x *Channel) GetZeroConf() bool {
	if x != nil {
		return x.ZeroConf
	}
	return false
}

func (x *Channel) GetZeroConfConfirmedScid() uint64 {
	if x != nil {
		return x.ZeroConfConfirmedScid
	}
	return 0
}

func (x *Channel) GetPeerAlias() string {
	if x != nil {
		return x.PeerAlias
	}
	return ""
}

func (x *Channel) GetPeerScidAlias() uint64 {
	if x != nil {
		return x.PeerScidAlias
	}
	return 0
}

func (x *Channel) GetMemo() string {
	if x != nil {
		return x.Memo
	}
	return ""
}

func (x *Channel) GetCustomChannelData() []byte {
	if x != nil {
		return x.CustomChannelData
	}
	return nil
}

type ListChannelsRequest struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	ActiveOnly   bool                   `protobuf:"varint,1,opt,name=active_only,json=activeOnly,proto3" json:"active_only,omitempty"`
	InactiveOnly bool                   `protobuf:"varint,2,opt,name=inactive_only,json=inactiveOnly,proto3" json:"inactive_only,omitempty"`
	PublicOnly   bool                   `protobuf:"varint,3,opt,name=public_only,json=publicOnly,proto3" json:"public_only,omitempty"`
	PrivateOnly  bool                   `protobuf:"varint,4,opt,name=private_only,json=privateOnly,proto3" json:"private_only,omitempty"`
	// Filters the response for channels with a target peer's pubkey. If peer is
	// empty, all channels will be returned.
	Peer []byte `protobuf:"bytes,5,opt,name=peer,proto3" json:"peer,omitempty"`
	// Informs the server if the peer alias lookup per channel should be
	// enabled. It is turned off by default in order to avoid degradation of
	// performance for existing clients.
	PeerAliasLookup bool `protobuf:"varint,6,opt,name=peer_alias_lookup,json=peerAliasLookup,proto3" json:"peer_alias_lookup,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ListChannelsRequest) Reset() {
	*x = ListChannelsRequest{}
	mi := &file_lightning_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListChannelsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListChannelsRequest) ProtoMessage() {}

func (x *ListChannelsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListChannelsRequest.ProtoReflect.Descriptor instead.
func (*ListChannelsRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{46}
}

func (x *ListChannelsRequest) GetActiveOnly() bool {
	if x != nil {
		return x.ActiveOnly
	}
	return false
}

func (x *ListChannelsRequest) GetInactiveOnly() bool {
	if x != nil {
		return x.InactiveOnly
	}
	return false
}

func (x *ListChannelsRequest) GetPublicOnly() bool {
	if x != nil {
		return x.PublicOnly
	}
	return false
}

func (x *ListChannelsRequest) GetPrivateOnly() bool {
	if x != nil {
		return x.PrivateOnly
	}
	return false
}

func (x *ListChannelsRequest) GetPeer() []byte {
	if x != nil {
		return x.Peer
	}
	return nil
}

func (x *ListChannelsRequest) GetPeerAliasLookup() bool {
	if x != nil {
		return x.PeerAliasLookup
	}
	return false
}

type ListChannelsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The list of active channels
	Channels      []*Channel `protobuf:"bytes,11,rep,name=channels,proto3" json:"channels,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListChannelsResponse) Reset() {
	*x = ListChannelsResponse{}
	mi := &file_lightning_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListChannelsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListChannelsResponse) ProtoMessage() {}

func (x *ListChannelsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListChannelsResponse.ProtoReflect.Descriptor instead.
func (*ListChannelsResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{47}
}

func (x *ListChannelsResponse) GetChannels() []*Channel {
	if x != nil {
		return x.Channels
	}
	return nil
}

type AliasMap struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// For non-zero-conf channels, this is the confirmed SCID. Otherwise, this is
	// the first assigned "base" alias.
	BaseScid uint64 `protobuf:"varint,1,opt,name=base_scid,json=baseScid,proto3" json:"base_scid,omitempty"`
	// The set of all aliases stored for the base SCID.
	Aliases       []uint64 `protobuf:"varint,2,rep,packed,name=aliases,proto3" json:"aliases,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AliasMap) Reset() {
	*x = AliasMap{}
	mi := &file_lightning_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AliasMap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AliasMap) ProtoMessage() {}

func (x *AliasMap) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AliasMap.ProtoReflect.Descriptor instead.
func (*AliasMap) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{48}
}

func (x *AliasMap) GetBaseScid() uint64 {
	if x != nil {
		return x.BaseScid
	}
	return 0
}

func (x *AliasMap) GetAliases() []uint64 {
	if x != nil {
		return x.Aliases
	}
	return nil
}

type ListAliasesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListAliasesRequest) Reset() {
	*x = ListAliasesRequest{}
	mi := &file_lightning_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListAliasesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListAliasesRequest) ProtoMessage() {}

func (x *ListAliasesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListAliasesRequest.ProtoReflect.Descriptor instead.
func (*ListAliasesRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{49}
}

type ListAliasesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	AliasMaps     []*AliasMap            `protobuf:"bytes,1,rep,name=alias_maps,json=aliasMaps,proto3" json:"alias_maps,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListAliasesResponse) Reset() {
	*x = ListAliasesResponse{}
	mi := &file_lightning_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListAliasesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListAliasesResponse) ProtoMessage() {}

func (x *ListAliasesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListAliasesResponse.ProtoReflect.Descriptor instead.
func (*ListAliasesResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{50}
}

func (x *ListAliasesResponse) GetAliasMaps() []*AliasMap {
	if x != nil {
		return x.AliasMaps
	}
	return nil
}

type ChannelCloseSummary struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The outpoint (txid:index) of the funding transaction.
	ChannelPoint string `protobuf:"bytes,1,opt,name=channel_point,json=channelPoint,proto3" json:"channel_point,omitempty"`
	// The unique channel ID for the channel.
	ChanId uint64 `protobuf:"varint,2,opt,name=chan_id,json=chanId,proto3" json:"chan_id,omitempty"`
	// The hash of the genesis block that this channel resides within.
	ChainHash string `protobuf:"bytes,3,opt,name=chain_hash,json=chainHash,proto3" json:"chain_hash,omitempty"`
	// The txid of the transaction which ultimately closed this channel.
	ClosingTxHash string `protobuf:"bytes,4,opt,name=closing_tx_hash,json=closingTxHash,proto3" json:"closing_tx_hash,omitempty"`
	// Public key of the remote peer that we formerly had a channel with.
	RemotePubkey string `protobuf:"bytes,5,opt,name=remote_pubkey,json=remotePubkey,proto3" json:"remote_pubkey,omitempty"`
	// Total capacity of the channel.
	Capacity int64 `protobuf:"varint,6,opt,name=capacity,proto3" json:"capacity,omitempty"`
	// Height at which the funding transaction was spent.
	CloseHeight uint32 `protobuf:"varint,7,opt,name=close_height,json=closeHeight,proto3" json:"close_height,omitempty"`
	// Settled balance at the time of channel closure
	SettledBalance int64 `protobuf:"varint,8,opt,name=settled_balance,json=settledBalance,proto3" json:"settled_balance,omitempty"`
	// The sum of all the time-locked outputs at the time of channel closure
	TimeLockedBalance int64 `protobuf:"varint,9,opt,name=time_locked_balance,json=timeLockedBalance,proto3" json:"time_locked_balance,omitempty"`
	// Details on how the channel was closed.
	CloseType ChannelCloseSummary_ClosureType `protobuf:"varint,10,opt,name=close_type,json=closeType,proto3,enum=lnrpc.ChannelCloseSummary_ClosureType" json:"close_type,omitempty"`
	// Open initiator is the party that initiated opening the channel. Note that
	// this value may be unknown if the channel was closed before we migrated to
	// store open channel information after close.
	OpenInitiator Initiator `protobuf:"varint,11,opt,name=open_initiator,json=openInitiator,proto3,enum=lnrpc.Initiator" json:"open_initiator,omitempty"`
	// Close initiator indicates which party initiated the close. This value will
	// be unknown for channels that were cooperatively closed before we started
	// tracking cooperative close initiators. Note that this indicates which party
	// initiated a close, and it is possible for both to initiate cooperative or
	// force closes, although only one party's close will be confirmed on chain.
	CloseInitiator Initiator     `protobuf:"varint,12,opt,name=close_initiator,json=closeInitiator,proto3,enum=lnrpc.Initiator" json:"close_initiator,omitempty"`
	Resolutions    []*Resolution `protobuf:"bytes,13,rep,name=resolutions,proto3" json:"resolutions,omitempty"`
	// This lists out the set of alias short channel ids that existed for the
	// closed channel. This may be empty.
	AliasScids []uint64 `protobuf:"varint,14,rep,packed,name=alias_scids,json=aliasScids,proto3" json:"alias_scids,omitempty"`
	// The confirmed SCID for a zero-conf channel.
	ZeroConfConfirmedScid uint64 `protobuf:"varint,15,opt,name=zero_conf_confirmed_scid,json=zeroConfConfirmedScid,proto3" json:"zero_conf_confirmed_scid,omitempty"`
	// The TLV encoded custom channel data records for this output, which might
	// be set for custom channels.
	CustomChannelData []byte `protobuf:"bytes,16,opt,name=custom_channel_data,json=customChannelData,proto3" json:"custom_channel_data,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ChannelCloseSummary) Reset() {
	*x = ChannelCloseSummary{}
	mi := &file_lightning_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelCloseSummary) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelCloseSummary) ProtoMessage() {}

func (x *ChannelCloseSummary) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelCloseSummary.ProtoReflect.Descriptor instead.
func (*ChannelCloseSummary) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{51}
}

func (x *ChannelCloseSummary) GetChannelPoint() string {
	if x != nil {
		return x.ChannelPoint
	}
	return ""
}

func (x *ChannelCloseSummary) GetChanId() uint64 {
	if x != nil {
		return x.ChanId
	}
	return 0
}

func (x *ChannelCloseSummary) GetChainHash() string {
	if x != nil {
		return x.ChainHash
	}
	return ""
}

func (x *ChannelCloseSummary) GetClosingTxHash() string {
	if x != nil {
		return x.ClosingTxHash
	}
	return ""
}

func (x *ChannelCloseSummary) GetRemotePubkey() string {
	if x != nil {
		return x.RemotePubkey
	}
	return ""
}

func (x *ChannelCloseSummary) GetCapacity() int64 {
	if x != nil {
		return x.Capacity
	}
	return 0
}

func (x *ChannelCloseSummary) GetCloseHeight() uint32 {
	if x != nil {
		return x.CloseHeight
	}
	return 0
}

func (x *ChannelCloseSummary) GetSettledBalance() int64 {
	if x != nil {
		return x.SettledBalance
	}
	return 0
}

func (x *ChannelCloseSummary) GetTimeLockedBalance() int64 {
	if x != nil {
		return x.TimeLockedBalance
	}
	return 0
}

func (x *ChannelCloseSummary) GetCloseType() ChannelCloseSummary_ClosureType {
	if x != nil {
		return x.CloseType
	}
	return ChannelCloseSummary_COOPERATIVE_CLOSE
}

func (x *ChannelCloseSummary) GetOpenInitiator() Initiator {
	if x != nil {
		return x.OpenInitiator
	}
	return Initiator_INITIATOR_UNKNOWN
}

func (x *ChannelCloseSummary) GetCloseInitiator() Initiator {
	if x != nil {
		return x.CloseInitiator
	}
	return Initiator_INITIATOR_UNKNOWN
}

func (x *ChannelCloseSummary) GetResolutions() []*Resolution {
	if x != nil {
		return x.Resolutions
	}
	return nil
}

func (x *ChannelCloseSummary) GetAliasScids() []uint64 {
	if x != nil {
		return x.AliasScids
	}
	return nil
}

func (x *ChannelCloseSummary) GetZeroConfConfirmedScid() uint64 {
	if x != nil {
		return x.ZeroConfConfirmedScid
	}
	return 0
}

func (x *ChannelCloseSummary) GetCustomChannelData() []byte {
	if x != nil {
		return x.CustomChannelData
	}
	return nil
}

type Resolution struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of output we are resolving.
	ResolutionType ResolutionType `protobuf:"varint,1,opt,name=resolution_type,json=resolutionType,proto3,enum=lnrpc.ResolutionType" json:"resolution_type,omitempty"`
	// The outcome of our on chain action that resolved the outpoint.
	Outcome ResolutionOutcome `protobuf:"varint,2,opt,name=outcome,proto3,enum=lnrpc.ResolutionOutcome" json:"outcome,omitempty"`
	// The outpoint that was spent by the resolution.
	Outpoint *OutPoint `protobuf:"bytes,3,opt,name=outpoint,proto3" json:"outpoint,omitempty"`
	// The amount that was claimed by the resolution.
	AmountSat uint64 `protobuf:"varint,4,opt,name=amount_sat,json=amountSat,proto3" json:"amount_sat,omitempty"`
	// The hex-encoded transaction ID of the sweep transaction that spent the
	// output.
	SweepTxid     string `protobuf:"bytes,5,opt,name=sweep_txid,json=sweepTxid,proto3" json:"sweep_txid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Resolution) Reset() {
	*x = Resolution{}
	mi := &file_lightning_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Resolution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Resolution) ProtoMessage() {}

func (x *Resolution) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Resolution.ProtoReflect.Descriptor instead.
func (*Resolution) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{52}
}

func (x *Resolution) GetResolutionType() ResolutionType {
	if x != nil {
		return x.ResolutionType
	}
	return ResolutionType_TYPE_UNKNOWN
}

func (x *Resolution) GetOutcome() ResolutionOutcome {
	if x != nil {
		return x.Outcome
	}
	return ResolutionOutcome_OUTCOME_UNKNOWN
}

func (x *Resolution) GetOutpoint() *OutPoint {
	if x != nil {
		return x.Outpoint
	}
	return nil
}

func (x *Resolution) GetAmountSat() uint64 {
	if x != nil {
		return x.AmountSat
	}
	return 0
}

func (x *Resolution) GetSweepTxid() string {
	if x != nil {
		return x.SweepTxid
	}
	return ""
}

type ClosedChannelsRequest struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Cooperative     bool                   `protobuf:"varint,1,opt,name=cooperative,proto3" json:"cooperative,omitempty"`
	LocalForce      bool                   `protobuf:"varint,2,opt,name=local_force,json=localForce,proto3" json:"local_force,omitempty"`
	RemoteForce     bool                   `protobuf:"varint,3,opt,name=remote_force,json=remoteForce,proto3" json:"remote_force,omitempty"`
	Breach          bool                   `protobuf:"varint,4,opt,name=breach,proto3" json:"breach,omitempty"`
	FundingCanceled bool                   `protobuf:"varint,5,opt,name=funding_canceled,json=fundingCanceled,proto3" json:"funding_canceled,omitempty"`
	Abandoned       bool                   `protobuf:"varint,6,opt,name=abandoned,proto3" json:"abandoned,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ClosedChannelsRequest) Reset() {
	*x = ClosedChannelsRequest{}
	mi := &file_lightning_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClosedChannelsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClosedChannelsRequest) ProtoMessage() {}

func (x *ClosedChannelsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClosedChannelsRequest.ProtoReflect.Descriptor instead.
func (*ClosedChannelsRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{53}
}

func (x *ClosedChannelsRequest) GetCooperative() bool {
	if x != nil {
		return x.Cooperative
	}
	return false
}

func (x *ClosedChannelsRequest) GetLocalForce() bool {
	if x != nil {
		return x.LocalForce
	}
	return false
}

func (x *ClosedChannelsRequest) GetRemoteForce() bool {
	if x != nil {
		return x.RemoteForce
	}
	return false
}

func (x *ClosedChannelsRequest) GetBreach() bool {
	if x != nil {
		return x.Breach
	}
	return false
}

func (x *ClosedChannelsRequest) GetFundingCanceled() bool {
	if x != nil {
		return x.FundingCanceled
	}
	return false
}

func (x *ClosedChannelsRequest) GetAbandoned() bool {
	if x != nil {
		return x.Abandoned
	}
	return false
}

type ClosedChannelsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Channels      []*ChannelCloseSummary `protobuf:"bytes,1,rep,name=channels,proto3" json:"channels,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClosedChannelsResponse) Reset() {
	*x = ClosedChannelsResponse{}
	mi := &file_lightning_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClosedChannelsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClosedChannelsResponse) ProtoMessage() {}

func (x *ClosedChannelsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClosedChannelsResponse.ProtoReflect.Descriptor instead.
func (*ClosedChannelsResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{54}
}

func (x *ClosedChannelsResponse) GetChannels() []*ChannelCloseSummary {
	if x != nil {
		return x.Channels
	}
	return nil
}

type Peer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identity pubkey of the peer
	PubKey string `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	// Network address of the peer; eg `127.0.0.1:10011`
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	// Bytes of data transmitted to this peer
	BytesSent uint64 `protobuf:"varint,4,opt,name=bytes_sent,json=bytesSent,proto3" json:"bytes_sent,omitempty"`
	// Bytes of data transmitted from this peer
	BytesRecv uint64 `protobuf:"varint,5,opt,name=bytes_recv,json=bytesRecv,proto3" json:"bytes_recv,omitempty"`
	// Satoshis sent to this peer
	SatSent int64 `protobuf:"varint,6,opt,name=sat_sent,json=satSent,proto3" json:"sat_sent,omitempty"`
	// Satoshis received from this peer
	SatRecv int64 `protobuf:"varint,7,opt,name=sat_recv,json=satRecv,proto3" json:"sat_recv,omitempty"`
	// A channel is inbound if the counterparty initiated the channel
	Inbound bool `protobuf:"varint,8,opt,name=inbound,proto3" json:"inbound,omitempty"`
	// Ping time to this peer
	PingTime int64 `protobuf:"varint,9,opt,name=ping_time,json=pingTime,proto3" json:"ping_time,omitempty"`
	// The type of sync we are currently performing with this peer.
	SyncType Peer_SyncType `protobuf:"varint,10,opt,name=sync_type,json=syncType,proto3,enum=lnrpc.Peer_SyncType" json:"sync_type,omitempty"`
	// Features advertised by the remote peer in their init message.
	Features map[uint32]*Feature `protobuf:"bytes,11,rep,name=features,proto3" json:"features,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The latest errors received from our peer with timestamps, limited to the 10
	// most recent errors. These errors are tracked across peer connections, but
	// are not persisted across lnd restarts. Note that these errors are only
	// stored for peers that we have channels open with, to prevent peers from
	// spamming us with errors at no cost.
	Errors []*TimestampedError `protobuf:"bytes,12,rep,name=errors,proto3" json:"errors,omitempty"`
	// This field is populated when the peer has at least one channel with us.
	// The number of times we have recorded this peer going offline or coming
	// online, recorded across restarts. Note that this value is decreased over
	// time if the peer has not recently flapped, so that we can forgive peers
	// with historically high flap counts.
	FlapCount int32 `protobuf:"varint,13,opt,name=flap_count,json=flapCount,proto3" json:"flap_count,omitempty"`
	// This field is populated when the peer has at least one channel with us.
	// The timestamp of the last flap we observed for this peer. If this value is
	// zero, we have not observed any flaps for this peer.
	LastFlapNs int64 `protobuf:"varint,14,opt,name=last_flap_ns,json=lastFlapNs,proto3" json:"last_flap_ns,omitempty"`
	// The last ping payload the peer has sent to us.
	LastPingPayload []byte `protobuf:"bytes,15,opt,name=last_ping_payload,json=lastPingPayload,proto3" json:"last_ping_payload,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Peer) Reset() {
	*x = Peer{}
	mi := &file_lightning_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Peer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Peer) ProtoMessage() {}

func (x *Peer) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Peer.ProtoReflect.Descriptor instead.
func (*Peer) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{55}
}

func (x *Peer) GetPubKey() string {
	if x != nil {
		return x.PubKey
	}
	return ""
}

func (x *Peer) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *Peer) GetBytesSent() uint64 {
	if x != nil {
		return x.BytesSent
	}
	return 0
}

func (x *Peer) GetBytesRecv() uint64 {
	if x != nil {
		return x.BytesRecv
	}
	return 0
}

func (x *Peer) GetSatSent() int64 {
	if x != nil {
		return x.SatSent
	}
	return 0
}

func (x *Peer) GetSatRecv() int64 {
	if x != nil {
		return x.SatRecv
	}
	return 0
}

func (x *Peer) GetInbound() bool {
	if x != nil {
		return x.Inbound
	}
	return false
}

func (x *Peer) GetPingTime() int64 {
	if x != nil {
		return x.PingTime
	}
	return 0
}

func (x *Peer) GetSyncType() Peer_SyncType {
	if x != nil {
		return x.SyncType
	}
	return Peer_UNKNOWN_SYNC
}

func (x *Peer) GetFeatures() map[uint32]*Feature {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *Peer) GetErrors() []*TimestampedError {
	if x != nil {
		return x.Errors
	}
	return nil
}

func (x *Peer) GetFlapCount() int32 {
	if x != nil {
		return x.FlapCount
	}
	return 0
}

func (x *Peer) GetLastFlapNs() int64 {
	if x != nil {
		return x.LastFlapNs
	}
	return 0
}

func (x *Peer) GetLastPingPayload() []byte {
	if x != nil {
		return x.LastPingPayload
	}
	return nil
}

type TimestampedError struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unix timestamp in seconds when the error occurred.
	Timestamp uint64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// The string representation of the error sent by our peer.
	Error         string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TimestampedError) Reset() {
	*x = TimestampedError{}
	mi := &file_lightning_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimestampedError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimestampedError) ProtoMessage() {}

func (x *TimestampedError) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimestampedError.ProtoReflect.Descriptor instead.
func (*TimestampedError) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{56}
}

func (x *TimestampedError) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *TimestampedError) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type ListPeersRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If true, only the last error that our peer sent us will be returned with
	// the peer's information, rather than the full set of historic errors we have
	// stored.
	LatestError   bool `protobuf:"varint,1,opt,name=latest_error,json=latestError,proto3" json:"latest_error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListPeersRequest) Reset() {
	*x = ListPeersRequest{}
	mi := &file_lightning_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPeersRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPeersRequest) ProtoMessage() {}

func (x *ListPeersRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPeersRequest.ProtoReflect.Descriptor instead.
func (*ListPeersRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{57}
}

func (x *ListPeersRequest) GetLatestError() bool {
	if x != nil {
		return x.LatestError
	}
	return false
}

type ListPeersResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The list of currently connected peers
	Peers         []*Peer `protobuf:"bytes,1,rep,name=peers,proto3" json:"peers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListPeersResponse) Reset() {
	*x = ListPeersResponse{}
	mi := &file_lightning_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPeersResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPeersResponse) ProtoMessage() {}

func (x *ListPeersResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPeersResponse.ProtoReflect.Descriptor instead.
func (*ListPeersResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{58}
}

func (x *ListPeersResponse) GetPeers() []*Peer {
	if x != nil {
		return x.Peers
	}
	return nil
}

type PeerEventSubscription struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PeerEventSubscription) Reset() {
	*x = PeerEventSubscription{}
	mi := &file_lightning_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PeerEventSubscription) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PeerEventSubscription) ProtoMessage() {}

func (x *PeerEventSubscription) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PeerEventSubscription.ProtoReflect.Descriptor instead.
func (*PeerEventSubscription) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{59}
}

type PeerEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identity pubkey of the peer.
	PubKey        string              `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	Type          PeerEvent_EventType `protobuf:"varint,2,opt,name=type,proto3,enum=lnrpc.PeerEvent_EventType" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PeerEvent) Reset() {
	*x = PeerEvent{}
	mi := &file_lightning_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PeerEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PeerEvent) ProtoMessage() {}

func (x *PeerEvent) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PeerEvent.ProtoReflect.Descriptor instead.
func (*PeerEvent) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{60}
}

func (x *PeerEvent) GetPubKey() string {
	if x != nil {
		return x.PubKey
	}
	return ""
}

func (x *PeerEvent) GetType() PeerEvent_EventType {
	if x != nil {
		return x.Type
	}
	return PeerEvent_PEER_ONLINE
}

type GetInfoRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetInfoRequest) Reset() {
	*x = GetInfoRequest{}
	mi := &file_lightning_proto_msgTypes[61]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetInfoRequest) ProtoMessage() {}

func (x *GetInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[61]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetInfoRequest.ProtoReflect.Descriptor instead.
func (*GetInfoRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{61}
}

type GetInfoResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The version of the LND software that the node is running.
	Version string `protobuf:"bytes,14,opt,name=version,proto3" json:"version,omitempty"`
	// The SHA1 commit hash that the daemon is compiled with.
	CommitHash string `protobuf:"bytes,20,opt,name=commit_hash,json=commitHash,proto3" json:"commit_hash,omitempty"`
	// The identity pubkey of the current node.
	IdentityPubkey string `protobuf:"bytes,1,opt,name=identity_pubkey,json=identityPubkey,proto3" json:"identity_pubkey,omitempty"`
	// If applicable, the alias of the current node, e.g. "bob"
	Alias string `protobuf:"bytes,2,opt,name=alias,proto3" json:"alias,omitempty"`
	// The color of the current node in hex code format
	Color string `protobuf:"bytes,17,opt,name=color,proto3" json:"color,omitempty"`
	// Number of pending channels
	NumPendingChannels uint32 `protobuf:"varint,3,opt,name=num_pending_channels,json=numPendingChannels,proto3" json:"num_pending_channels,omitempty"`
	// Number of active channels
	NumActiveChannels uint32 `protobuf:"varint,4,opt,name=num_active_channels,json=numActiveChannels,proto3" json:"num_active_channels,omitempty"`
	// Number of inactive channels
	NumInactiveChannels uint32 `protobuf:"varint,15,opt,name=num_inactive_channels,json=numInactiveChannels,proto3" json:"num_inactive_channels,omitempty"`
	// Number of peers
	NumPeers uint32 `protobuf:"varint,5,opt,name=num_peers,json=numPeers,proto3" json:"num_peers,omitempty"`
	// The node's current view of the height of the best block
	BlockHeight uint32 `protobuf:"varint,6,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// The node's current view of the hash of the best block
	BlockHash string `protobuf:"bytes,8,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	// Timestamp of the block best known to the wallet
	BestHeaderTimestamp int64 `protobuf:"varint,13,opt,name=best_header_timestamp,json=bestHeaderTimestamp,proto3" json:"best_header_timestamp,omitempty"`
	// Whether the wallet's view is synced to the main chain
	SyncedToChain bool `protobuf:"varint,9,opt,name=synced_to_chain,json=syncedToChain,proto3" json:"synced_to_chain,omitempty"`
	// Whether we consider ourselves synced with the public channel graph.
	SyncedToGraph bool `protobuf:"varint,18,opt,name=synced_to_graph,json=syncedToGraph,proto3" json:"synced_to_graph,omitempty"`
	// Whether the current node is connected to testnet or testnet4. This field is
	// deprecated and the network field should be used instead.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	Testnet bool `protobuf:"varint,10,opt,name=testnet,proto3" json:"testnet,omitempty"`
	// A list of active chains the node is connected to. This will only
	// ever contain a single entry since LND will only ever have a single
	// chain backend during its lifetime.
	Chains []*Chain `protobuf:"bytes,16,rep,name=chains,proto3" json:"chains,omitempty"`
	// The URIs of the current node.
	Uris []string `protobuf:"bytes,12,rep,name=uris,proto3" json:"uris,omitempty"`
	// Features that our node has advertised in our init message, node
	// announcements and invoices.
	Features map[uint32]*Feature `protobuf:"bytes,19,rep,name=features,proto3" json:"features,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Indicates whether the HTLC interceptor API is in always-on mode.
	RequireHtlcInterceptor bool `protobuf:"varint,21,opt,name=require_htlc_interceptor,json=requireHtlcInterceptor,proto3" json:"require_htlc_interceptor,omitempty"`
	// Indicates whether final htlc resolutions are stored on disk.
	StoreFinalHtlcResolutions bool `protobuf:"varint,22,opt,name=store_final_htlc_resolutions,json=storeFinalHtlcResolutions,proto3" json:"store_final_htlc_resolutions,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *GetInfoResponse) Reset() {
	*x = GetInfoResponse{}
	mi := &file_lightning_proto_msgTypes[62]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetInfoResponse) ProtoMessage() {}

func (x *GetInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[62]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetInfoResponse.ProtoReflect.Descriptor instead.
func (*GetInfoResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{62}
}

func (x *GetInfoResponse) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *GetInfoResponse) GetCommitHash() string {
	if x != nil {
		return x.CommitHash
	}
	return ""
}

func (x *GetInfoResponse) GetIdentityPubkey() string {
	if x != nil {
		return x.IdentityPubkey
	}
	return ""
}

func (x *GetInfoResponse) GetAlias() string {
	if x != nil {
		return x.Alias
	}
	return ""
}

func (x *GetInfoResponse) GetColor() string {
	if x != nil {
		return x.Color
	}
	return ""
}

func (x *GetInfoResponse) GetNumPendingChannels() uint32 {
	if x != nil {
		return x.NumPendingChannels
	}
	return 0
}

func (x *GetInfoResponse) GetNumActiveChannels() uint32 {
	if x != nil {
		return x.NumActiveChannels
	}
	return 0
}

func (x *GetInfoResponse) GetNumInactiveChannels() uint32 {
	if x != nil {
		return x.NumInactiveChannels
	}
	return 0
}

func (x *GetInfoResponse) GetNumPeers() uint32 {
	if x != nil {
		return x.NumPeers
	}
	return 0
}

func (x *GetInfoResponse) GetBlockHeight() uint32 {
	if x != nil {
		return x.BlockHeight
	}
	return 0
}

func (x *GetInfoResponse) GetBlockHash() string {
	if x != nil {
		return x.BlockHash
	}
	return ""
}

func (x *GetInfoResponse) GetBestHeaderTimestamp() int64 {
	if x != nil {
		return x.BestHeaderTimestamp
	}
	return 0
}

func (x *GetInfoResponse) GetSyncedToChain() bool {
	if x != nil {
		return x.SyncedToChain
	}
	return false
}

func (x *GetInfoResponse) GetSyncedToGraph() bool {
	if x != nil {
		return x.SyncedToGraph
	}
	return false
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *GetInfoResponse) GetTestnet() bool {
	if x != nil {
		return x.Testnet
	}
	return false
}

func (x *GetInfoResponse) GetChains() []*Chain {
	if x != nil {
		return x.Chains
	}
	return nil
}

func (x *GetInfoResponse) GetUris() []string {
	if x != nil {
		return x.Uris
	}
	return nil
}

func (x *GetInfoResponse) GetFeatures() map[uint32]*Feature {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *GetInfoResponse) GetRequireHtlcInterceptor() bool {
	if x != nil {
		return x.RequireHtlcInterceptor
	}
	return false
}

func (x *GetInfoResponse) GetStoreFinalHtlcResolutions() bool {
	if x != nil {
		return x.StoreFinalHtlcResolutions
	}
	return false
}

type GetDebugInfoRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetDebugInfoRequest) Reset() {
	*x = GetDebugInfoRequest{}
	mi := &file_lightning_proto_msgTypes[63]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetDebugInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetDebugInfoRequest) ProtoMessage() {}

func (x *GetDebugInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[63]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetDebugInfoRequest.ProtoReflect.Descriptor instead.
func (*GetDebugInfoRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{63}
}

type GetDebugInfoResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Config        map[string]string      `protobuf:"bytes,1,rep,name=config,proto3" json:"config,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Log           []string               `protobuf:"bytes,2,rep,name=log,proto3" json:"log,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetDebugInfoResponse) Reset() {
	*x = GetDebugInfoResponse{}
	mi := &file_lightning_proto_msgTypes[64]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetDebugInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetDebugInfoResponse) ProtoMessage() {}

func (x *GetDebugInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[64]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetDebugInfoResponse.ProtoReflect.Descriptor instead.
func (*GetDebugInfoResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{64}
}

func (x *GetDebugInfoResponse) GetConfig() map[string]string {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *GetDebugInfoResponse) GetLog() []string {
	if x != nil {
		return x.Log
	}
	return nil
}

type GetRecoveryInfoRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRecoveryInfoRequest) Reset() {
	*x = GetRecoveryInfoRequest{}
	mi := &file_lightning_proto_msgTypes[65]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRecoveryInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRecoveryInfoRequest) ProtoMessage() {}

func (x *GetRecoveryInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[65]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRecoveryInfoRequest.ProtoReflect.Descriptor instead.
func (*GetRecoveryInfoRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{65}
}

type GetRecoveryInfoResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the wallet is in recovery mode
	RecoveryMode bool `protobuf:"varint,1,opt,name=recovery_mode,json=recoveryMode,proto3" json:"recovery_mode,omitempty"`
	// Whether the wallet recovery progress is finished
	RecoveryFinished bool `protobuf:"varint,2,opt,name=recovery_finished,json=recoveryFinished,proto3" json:"recovery_finished,omitempty"`
	// The recovery progress, ranging from 0 to 1.
	Progress      float64 `protobuf:"fixed64,3,opt,name=progress,proto3" json:"progress,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRecoveryInfoResponse) Reset() {
	*x = GetRecoveryInfoResponse{}
	mi := &file_lightning_proto_msgTypes[66]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRecoveryInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRecoveryInfoResponse) ProtoMessage() {}

func (x *GetRecoveryInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[66]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRecoveryInfoResponse.ProtoReflect.Descriptor instead.
func (*GetRecoveryInfoResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{66}
}

func (x *GetRecoveryInfoResponse) GetRecoveryMode() bool {
	if x != nil {
		return x.RecoveryMode
	}
	return false
}

func (x *GetRecoveryInfoResponse) GetRecoveryFinished() bool {
	if x != nil {
		return x.RecoveryFinished
	}
	return false
}

func (x *GetRecoveryInfoResponse) GetProgress() float64 {
	if x != nil {
		return x.Progress
	}
	return 0
}

type Chain struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Deprecated. The chain is now always assumed to be bitcoin.
	// The blockchain the node is on (must be bitcoin)
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	Chain string `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	// The network the node is on (eg regtest, testnet, mainnet)
	Network       string `protobuf:"bytes,2,opt,name=network,proto3" json:"network,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Chain) Reset() {
	*x = Chain{}
	mi := &file_lightning_proto_msgTypes[67]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Chain) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Chain) ProtoMessage() {}

func (x *Chain) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[67]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Chain.ProtoReflect.Descriptor instead.
func (*Chain) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{67}
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *Chain) GetChain() string {
	if x != nil {
		return x.Chain
	}
	return ""
}

func (x *Chain) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

type ChannelOpenUpdate struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ChannelPoint  *ChannelPoint          `protobuf:"bytes,1,opt,name=channel_point,json=channelPoint,proto3" json:"channel_point,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChannelOpenUpdate) Reset() {
	*x = ChannelOpenUpdate{}
	mi := &file_lightning_proto_msgTypes[68]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelOpenUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelOpenUpdate) ProtoMessage() {}

func (x *ChannelOpenUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[68]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelOpenUpdate.ProtoReflect.Descriptor instead.
func (*ChannelOpenUpdate) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{68}
}

func (x *ChannelOpenUpdate) GetChannelPoint() *ChannelPoint {
	if x != nil {
		return x.ChannelPoint
	}
	return nil
}

type CloseOutput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The amount in satoshi of this close output. This amount is the final
	// commitment balance of the channel and the actual amount paid out on chain
	// might be smaller due to subtracted fees.
	AmountSat int64 `protobuf:"varint,1,opt,name=amount_sat,json=amountSat,proto3" json:"amount_sat,omitempty"`
	// The pkScript of the close output.
	PkScript []byte `protobuf:"bytes,2,opt,name=pk_script,json=pkScript,proto3" json:"pk_script,omitempty"`
	// Whether this output is for the local or remote node.
	IsLocal bool `protobuf:"varint,3,opt,name=is_local,json=isLocal,proto3" json:"is_local,omitempty"`
	// The TLV encoded custom channel data records for this output, which might
	// be set for custom channels.
	CustomChannelData []byte `protobuf:"bytes,4,opt,name=custom_channel_data,json=customChannelData,proto3" json:"custom_channel_data,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *CloseOutput) Reset() {
	*x = CloseOutput{}
	mi := &file_lightning_proto_msgTypes[69]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CloseOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CloseOutput) ProtoMessage() {}

func (x *CloseOutput) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[69]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CloseOutput.ProtoReflect.Descriptor instead.
func (*CloseOutput) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{69}
}

func (x *CloseOutput) GetAmountSat() int64 {
	if x != nil {
		return x.AmountSat
	}
	return 0
}

func (x *CloseOutput) GetPkScript() []byte {
	if x != nil {
		return x.PkScript
	}
	return nil
}

func (x *CloseOutput) GetIsLocal() bool {
	if x != nil {
		return x.IsLocal
	}
	return false
}

func (x *CloseOutput) GetCustomChannelData() []byte {
	if x != nil {
		return x.CustomChannelData
	}
	return nil
}

type ChannelCloseUpdate struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	ClosingTxid []byte                 `protobuf:"bytes,1,opt,name=closing_txid,json=closingTxid,proto3" json:"closing_txid,omitempty"`
	Success     bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	// The local channel close output. If the local channel balance was dust to
	// begin with, this output will not be set.
	LocalCloseOutput *CloseOutput `protobuf:"bytes,3,opt,name=local_close_output,json=localCloseOutput,proto3" json:"local_close_output,omitempty"`
	// The remote channel close output. If the remote channel balance was dust
	// to begin with, this output will not be set.
	RemoteCloseOutput *CloseOutput `protobuf:"bytes,4,opt,name=remote_close_output,json=remoteCloseOutput,proto3" json:"remote_close_output,omitempty"`
	// Any additional outputs that might be added for custom channel types.
	AdditionalOutputs []*CloseOutput `protobuf:"bytes,5,rep,name=additional_outputs,json=additionalOutputs,proto3" json:"additional_outputs,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ChannelCloseUpdate) Reset() {
	*x = ChannelCloseUpdate{}
	mi := &file_lightning_proto_msgTypes[70]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelCloseUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelCloseUpdate) ProtoMessage() {}

func (x *ChannelCloseUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[70]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelCloseUpdate.ProtoReflect.Descriptor instead.
func (*ChannelCloseUpdate) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{70}
}

func (x *ChannelCloseUpdate) GetClosingTxid() []byte {
	if x != nil {
		return x.ClosingTxid
	}
	return nil
}

func (x *ChannelCloseUpdate) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ChannelCloseUpdate) GetLocalCloseOutput() *CloseOutput {
	if x != nil {
		return x.LocalCloseOutput
	}
	return nil
}

func (x *ChannelCloseUpdate) GetRemoteCloseOutput() *CloseOutput {
	if x != nil {
		return x.RemoteCloseOutput
	}
	return nil
}

func (x *ChannelCloseUpdate) GetAdditionalOutputs() []*CloseOutput {
	if x != nil {
		return x.AdditionalOutputs
	}
	return nil
}

type CloseChannelRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The outpoint (txid:index) of the funding transaction. With this value, Bob
	// will be able to generate a signature for Alice's version of the commitment
	// transaction.
	ChannelPoint *ChannelPoint `protobuf:"bytes,1,opt,name=channel_point,json=channelPoint,proto3" json:"channel_point,omitempty"`
	// If true, then the channel will be closed forcibly. This means the
	// current commitment transaction will be signed and broadcast.
	Force bool `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	// The target number of blocks that the closure transaction should be
	// confirmed by.
	TargetConf int32 `protobuf:"varint,3,opt,name=target_conf,json=targetConf,proto3" json:"target_conf,omitempty"`
	// Deprecated, use sat_per_vbyte.
	// A manual fee rate set in sat/vbyte that should be used when crafting the
	// closure transaction.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	SatPerByte int64 `protobuf:"varint,4,opt,name=sat_per_byte,json=satPerByte,proto3" json:"sat_per_byte,omitempty"`
	// An optional address to send funds to in the case of a cooperative close.
	// If the channel was opened with an upfront shutdown script and this field
	// is set, the request to close will fail because the channel must pay out
	// to the upfront shutdown addresss.
	DeliveryAddress string `protobuf:"bytes,5,opt,name=delivery_address,json=deliveryAddress,proto3" json:"delivery_address,omitempty"`
	// A manual fee rate set in sat/vbyte that should be used when crafting the
	// closure transaction.
	SatPerVbyte uint64 `protobuf:"varint,6,opt,name=sat_per_vbyte,json=satPerVbyte,proto3" json:"sat_per_vbyte,omitempty"`
	// The maximum fee rate the closer is willing to pay.
	//
	// NOTE: This field is only respected if we're the initiator of the channel.
	MaxFeePerVbyte uint64 `protobuf:"varint,7,opt,name=max_fee_per_vbyte,json=maxFeePerVbyte,proto3" json:"max_fee_per_vbyte,omitempty"`
	// If true, then the rpc call will not block while it awaits a closing txid
	// to be broadcasted to the mempool. To obtain the closing tx one has to
	// listen to the stream for the particular updates. Moreover if a coop close
	// is specified and this flag is set to true the coop closing flow will be
	// initiated even if HTLCs are active on the channel. The channel will wait
	// until all HTLCs are resolved and then start the coop closing process. The
	// channel will be disabled in the meantime and will disallow any new HTLCs.
	NoWait        bool `protobuf:"varint,8,opt,name=no_wait,json=noWait,proto3" json:"no_wait,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CloseChannelRequest) Reset() {
	*x = CloseChannelRequest{}
	mi := &file_lightning_proto_msgTypes[71]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CloseChannelRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CloseChannelRequest) ProtoMessage() {}

func (x *CloseChannelRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[71]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CloseChannelRequest.ProtoReflect.Descriptor instead.
func (*CloseChannelRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{71}
}

func (x *CloseChannelRequest) GetChannelPoint() *ChannelPoint {
	if x != nil {
		return x.ChannelPoint
	}
	return nil
}

func (x *CloseChannelRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

func (x *CloseChannelRequest) GetTargetConf() int32 {
	if x != nil {
		return x.TargetConf
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *CloseChannelRequest) GetSatPerByte() int64 {
	if x != nil {
		return x.SatPerByte
	}
	return 0
}

func (x *CloseChannelRequest) GetDeliveryAddress() string {
	if x != nil {
		return x.DeliveryAddress
	}
	return ""
}

func (x *CloseChannelRequest) GetSatPerVbyte() uint64 {
	if x != nil {
		return x.SatPerVbyte
	}
	return 0
}

func (x *CloseChannelRequest) GetMaxFeePerVbyte() uint64 {
	if x != nil {
		return x.MaxFeePerVbyte
	}
	return 0
}

func (x *CloseChannelRequest) GetNoWait() bool {
	if x != nil {
		return x.NoWait
	}
	return false
}

type CloseStatusUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Update:
	//
	//	*CloseStatusUpdate_ClosePending
	//	*CloseStatusUpdate_ChanClose
	//	*CloseStatusUpdate_CloseInstant
	Update        isCloseStatusUpdate_Update `protobuf_oneof:"update"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CloseStatusUpdate) Reset() {
	*x = CloseStatusUpdate{}
	mi := &file_lightning_proto_msgTypes[72]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CloseStatusUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CloseStatusUpdate) ProtoMessage() {}

func (x *CloseStatusUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[72]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CloseStatusUpdate.ProtoReflect.Descriptor instead.
func (*CloseStatusUpdate) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{72}
}

func (x *CloseStatusUpdate) GetUpdate() isCloseStatusUpdate_Update {
	if x != nil {
		return x.Update
	}
	return nil
}

func (x *CloseStatusUpdate) GetClosePending() *PendingUpdate {
	if x != nil {
		if x, ok := x.Update.(*CloseStatusUpdate_ClosePending); ok {
			return x.ClosePending
		}
	}
	return nil
}

func (x *CloseStatusUpdate) GetChanClose() *ChannelCloseUpdate {
	if x != nil {
		if x, ok := x.Update.(*CloseStatusUpdate_ChanClose); ok {
			return x.ChanClose
		}
	}
	return nil
}

func (x *CloseStatusUpdate) GetCloseInstant() *InstantUpdate {
	if x != nil {
		if x, ok := x.Update.(*CloseStatusUpdate_CloseInstant); ok {
			return x.CloseInstant
		}
	}
	return nil
}

type isCloseStatusUpdate_Update interface {
	isCloseStatusUpdate_Update()
}

type CloseStatusUpdate_ClosePending struct {
	ClosePending *PendingUpdate `protobuf:"bytes,1,opt,name=close_pending,json=closePending,proto3,oneof"`
}

type CloseStatusUpdate_ChanClose struct {
	ChanClose *ChannelCloseUpdate `protobuf:"bytes,3,opt,name=chan_close,json=chanClose,proto3,oneof"`
}

type CloseStatusUpdate_CloseInstant struct {
	CloseInstant *InstantUpdate `protobuf:"bytes,4,opt,name=close_instant,json=closeInstant,proto3,oneof"`
}

func (*CloseStatusUpdate_ClosePending) isCloseStatusUpdate_Update() {}

func (*CloseStatusUpdate_ChanClose) isCloseStatusUpdate_Update() {}

func (*CloseStatusUpdate_CloseInstant) isCloseStatusUpdate_Update() {}

type PendingUpdate struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Txid          []byte                 `protobuf:"bytes,1,opt,name=txid,proto3" json:"txid,omitempty"`
	OutputIndex   uint32                 `protobuf:"varint,2,opt,name=output_index,json=outputIndex,proto3" json:"output_index,omitempty"`
	FeePerVbyte   int64                  `protobuf:"varint,3,opt,name=fee_per_vbyte,json=feePerVbyte,proto3" json:"fee_per_vbyte,omitempty"`
	LocalCloseTx  bool                   `protobuf:"varint,4,opt,name=local_close_tx,json=localCloseTx,proto3" json:"local_close_tx,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PendingUpdate) Reset() {
	*x = PendingUpdate{}
	mi := &file_lightning_proto_msgTypes[73]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PendingUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingUpdate) ProtoMessage() {}

func (x *PendingUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[73]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PendingUpdate.ProtoReflect.Descriptor instead.
func (*PendingUpdate) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{73}
}

func (x *PendingUpdate) GetTxid() []byte {
	if x != nil {
		return x.Txid
	}
	return nil
}

func (x *PendingUpdate) GetOutputIndex() uint32 {
	if x != nil {
		return x.OutputIndex
	}
	return 0
}

func (x *PendingUpdate) GetFeePerVbyte() int64 {
	if x != nil {
		return x.FeePerVbyte
	}
	return 0
}

func (x *PendingUpdate) GetLocalCloseTx() bool {
	if x != nil {
		return x.LocalCloseTx
	}
	return false
}

type InstantUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of pending HTLCs that are currently active on the channel.
	// These HTLCs need to be resolved before the channel can be closed
	// cooperatively.
	NumPendingHtlcs int32 `protobuf:"varint,1,opt,name=num_pending_htlcs,json=numPendingHtlcs,proto3" json:"num_pending_htlcs,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *InstantUpdate) Reset() {
	*x = InstantUpdate{}
	mi := &file_lightning_proto_msgTypes[74]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstantUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstantUpdate) ProtoMessage() {}

func (x *InstantUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[74]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstantUpdate.ProtoReflect.Descriptor instead.
func (*InstantUpdate) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{74}
}

func (x *InstantUpdate) GetNumPendingHtlcs() int32 {
	if x != nil {
		return x.NumPendingHtlcs
	}
	return 0
}

type ReadyForPsbtFunding struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The P2WSH address of the channel funding multisig address that the below
	// specified amount in satoshis needs to be sent to.
	FundingAddress string `protobuf:"bytes,1,opt,name=funding_address,json=fundingAddress,proto3" json:"funding_address,omitempty"`
	// The exact amount in satoshis that needs to be sent to the above address to
	// fund the pending channel.
	FundingAmount int64 `protobuf:"varint,2,opt,name=funding_amount,json=fundingAmount,proto3" json:"funding_amount,omitempty"`
	// A raw PSBT that contains the pending channel output. If a base PSBT was
	// provided in the PsbtShim, this is the base PSBT with one additional output.
	// If no base PSBT was specified, this is an otherwise empty PSBT with exactly
	// one output.
	Psbt          []byte `protobuf:"bytes,3,opt,name=psbt,proto3" json:"psbt,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadyForPsbtFunding) Reset() {
	*x = ReadyForPsbtFunding{}
	mi := &file_lightning_proto_msgTypes[75]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadyForPsbtFunding) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadyForPsbtFunding) ProtoMessage() {}

func (x *ReadyForPsbtFunding) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[75]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadyForPsbtFunding.ProtoReflect.Descriptor instead.
func (*ReadyForPsbtFunding) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{75}
}

func (x *ReadyForPsbtFunding) GetFundingAddress() string {
	if x != nil {
		return x.FundingAddress
	}
	return ""
}

func (x *ReadyForPsbtFunding) GetFundingAmount() int64 {
	if x != nil {
		return x.FundingAmount
	}
	return 0
}

func (x *ReadyForPsbtFunding) GetPsbt() []byte {
	if x != nil {
		return x.Psbt
	}
	return nil
}

type BatchOpenChannelRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The list of channels to open.
	Channels []*BatchOpenChannel `protobuf:"bytes,1,rep,name=channels,proto3" json:"channels,omitempty"`
	// The target number of blocks that the funding transaction should be
	// confirmed by.
	TargetConf int32 `protobuf:"varint,2,opt,name=target_conf,json=targetConf,proto3" json:"target_conf,omitempty"`
	// A manual fee rate set in sat/vByte that should be used when crafting the
	// funding transaction.
	SatPerVbyte int64 `protobuf:"varint,3,opt,name=sat_per_vbyte,json=satPerVbyte,proto3" json:"sat_per_vbyte,omitempty"`
	// The minimum number of confirmations each one of your outputs used for
	// the funding transaction must satisfy.
	MinConfs int32 `protobuf:"varint,4,opt,name=min_confs,json=minConfs,proto3" json:"min_confs,omitempty"`
	// Whether unconfirmed outputs should be used as inputs for the funding
	// transaction.
	SpendUnconfirmed bool `protobuf:"varint,5,opt,name=spend_unconfirmed,json=spendUnconfirmed,proto3" json:"spend_unconfirmed,omitempty"`
	// An optional label for the batch transaction, limited to 500 characters.
	Label string `protobuf:"bytes,6,opt,name=label,proto3" json:"label,omitempty"`
	// The strategy to use for selecting coins during batch opening channels.
	CoinSelectionStrategy CoinSelectionStrategy `protobuf:"varint,7,opt,name=coin_selection_strategy,json=coinSelectionStrategy,proto3,enum=lnrpc.CoinSelectionStrategy" json:"coin_selection_strategy,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *BatchOpenChannelRequest) Reset() {
	*x = BatchOpenChannelRequest{}
	mi := &file_lightning_proto_msgTypes[76]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchOpenChannelRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchOpenChannelRequest) ProtoMessage() {}

func (x *BatchOpenChannelRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[76]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchOpenChannelRequest.ProtoReflect.Descriptor instead.
func (*BatchOpenChannelRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{76}
}

func (x *BatchOpenChannelRequest) GetChannels() []*BatchOpenChannel {
	if x != nil {
		return x.Channels
	}
	return nil
}

func (x *BatchOpenChannelRequest) GetTargetConf() int32 {
	if x != nil {
		return x.TargetConf
	}
	return 0
}

func (x *BatchOpenChannelRequest) GetSatPerVbyte() int64 {
	if x != nil {
		return x.SatPerVbyte
	}
	return 0
}

func (x *BatchOpenChannelRequest) GetMinConfs() int32 {
	if x != nil {
		return x.MinConfs
	}
	return 0
}

func (x *BatchOpenChannelRequest) GetSpendUnconfirmed() bool {
	if x != nil {
		return x.SpendUnconfirmed
	}
	return false
}

func (x *BatchOpenChannelRequest) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *BatchOpenChannelRequest) GetCoinSelectionStrategy() CoinSelectionStrategy {
	if x != nil {
		return x.CoinSelectionStrategy
	}
	return CoinSelectionStrategy_STRATEGY_USE_GLOBAL_CONFIG
}

type BatchOpenChannel struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The pubkey of the node to open a channel with. When using REST, this
	// field must be encoded as base64.
	NodePubkey []byte `protobuf:"bytes,1,opt,name=node_pubkey,json=nodePubkey,proto3" json:"node_pubkey,omitempty"`
	// The number of satoshis the wallet should commit to the channel.
	LocalFundingAmount int64 `protobuf:"varint,2,opt,name=local_funding_amount,json=localFundingAmount,proto3" json:"local_funding_amount,omitempty"`
	// The number of satoshis to push to the remote side as part of the initial
	// commitment state.
	PushSat int64 `protobuf:"varint,3,opt,name=push_sat,json=pushSat,proto3" json:"push_sat,omitempty"`
	// Whether this channel should be private, not announced to the greater
	// network.
	Private bool `protobuf:"varint,4,opt,name=private,proto3" json:"private,omitempty"`
	// The minimum value in millisatoshi we will require for incoming HTLCs on
	// the channel.
	MinHtlcMsat int64 `protobuf:"varint,5,opt,name=min_htlc_msat,json=minHtlcMsat,proto3" json:"min_htlc_msat,omitempty"`
	// The delay we require on the remote's commitment transaction. If this is
	// not set, it will be scaled automatically with the channel size.
	RemoteCsvDelay uint32 `protobuf:"varint,6,opt,name=remote_csv_delay,json=remoteCsvDelay,proto3" json:"remote_csv_delay,omitempty"`
	// Close address is an optional address which specifies the address to which
	// funds should be paid out to upon cooperative close. This field may only be
	// set if the peer supports the option upfront feature bit (call listpeers
	// to check). The remote peer will only accept cooperative closes to this
	// address if it is set.
	//
	// Note: If this value is set on channel creation, you will *not* be able to
	// cooperatively close out to a different address.
	CloseAddress string `protobuf:"bytes,7,opt,name=close_address,json=closeAddress,proto3" json:"close_address,omitempty"`
	// An optional, unique identifier of 32 random bytes that will be used as the
	// pending channel ID to identify the channel while it is in the pre-pending
	// state.
	PendingChanId []byte `protobuf:"bytes,8,opt,name=pending_chan_id,json=pendingChanId,proto3" json:"pending_chan_id,omitempty"`
	// The explicit commitment type to use. Note this field will only be used if
	// the remote peer supports explicit channel negotiation.
	CommitmentType CommitmentType `protobuf:"varint,9,opt,name=commitment_type,json=commitmentType,proto3,enum=lnrpc.CommitmentType" json:"commitment_type,omitempty"`
	// The maximum amount of coins in millisatoshi that can be pending within
	// the channel. It only applies to the remote party.
	RemoteMaxValueInFlightMsat uint64 `protobuf:"varint,10,opt,name=remote_max_value_in_flight_msat,json=remoteMaxValueInFlightMsat,proto3" json:"remote_max_value_in_flight_msat,omitempty"`
	// The maximum number of concurrent HTLCs we will allow the remote party to add
	// to the commitment transaction.
	RemoteMaxHtlcs uint32 `protobuf:"varint,11,opt,name=remote_max_htlcs,json=remoteMaxHtlcs,proto3" json:"remote_max_htlcs,omitempty"`
	// Max local csv is the maximum csv delay we will allow for our own commitment
	// transaction.
	MaxLocalCsv uint32 `protobuf:"varint,12,opt,name=max_local_csv,json=maxLocalCsv,proto3" json:"max_local_csv,omitempty"`
	// If this is true, then a zero-conf channel open will be attempted.
	ZeroConf bool `protobuf:"varint,13,opt,name=zero_conf,json=zeroConf,proto3" json:"zero_conf,omitempty"`
	// If this is true, then an option-scid-alias channel-type open will be
	// attempted.
	ScidAlias bool `protobuf:"varint,14,opt,name=scid_alias,json=scidAlias,proto3" json:"scid_alias,omitempty"`
	// The base fee charged regardless of the number of milli-satoshis sent.
	BaseFee uint64 `protobuf:"varint,15,opt,name=base_fee,json=baseFee,proto3" json:"base_fee,omitempty"`
	// The fee rate in ppm (parts per million) that will be charged in
	// proportion of the value of each forwarded HTLC.
	FeeRate uint64 `protobuf:"varint,16,opt,name=fee_rate,json=feeRate,proto3" json:"fee_rate,omitempty"`
	// If use_base_fee is true the open channel announcement will update the
	// channel base fee with the value specified in base_fee. In the case of
	// a base_fee of 0 use_base_fee is needed downstream to distinguish whether
	// to use the default base fee value specified in the config or 0.
	UseBaseFee bool `protobuf:"varint,17,opt,name=use_base_fee,json=useBaseFee,proto3" json:"use_base_fee,omitempty"`
	// If use_fee_rate is true the open channel announcement will update the
	// channel fee rate with the value specified in fee_rate. In the case of
	// a fee_rate of 0 use_fee_rate is needed downstream to distinguish whether
	// to use the default fee rate value specified in the config or 0.
	UseFeeRate bool `protobuf:"varint,18,opt,name=use_fee_rate,json=useFeeRate,proto3" json:"use_fee_rate,omitempty"`
	// The number of satoshis we require the remote peer to reserve. This value,
	// if specified, must be above the dust limit and below 20% of the channel
	// capacity.
	RemoteChanReserveSat uint64 `protobuf:"varint,19,opt,name=remote_chan_reserve_sat,json=remoteChanReserveSat,proto3" json:"remote_chan_reserve_sat,omitempty"`
	// An optional note-to-self to go along with the channel containing some
	// useful information. This is only ever stored locally and in no way impacts
	// the channel's operation.
	Memo          string `protobuf:"bytes,20,opt,name=memo,proto3" json:"memo,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchOpenChannel) Reset() {
	*x = BatchOpenChannel{}
	mi := &file_lightning_proto_msgTypes[77]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchOpenChannel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchOpenChannel) ProtoMessage() {}

func (x *BatchOpenChannel) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[77]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchOpenChannel.ProtoReflect.Descriptor instead.
func (*BatchOpenChannel) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{77}
}

func (x *BatchOpenChannel) GetNodePubkey() []byte {
	if x != nil {
		return x.NodePubkey
	}
	return nil
}

func (x *BatchOpenChannel) GetLocalFundingAmount() int64 {
	if x != nil {
		return x.LocalFundingAmount
	}
	return 0
}

func (x *BatchOpenChannel) GetPushSat() int64 {
	if x != nil {
		return x.PushSat
	}
	return 0
}

func (x *BatchOpenChannel) GetPrivate() bool {
	if x != nil {
		return x.Private
	}
	return false
}

func (x *BatchOpenChannel) GetMinHtlcMsat() int64 {
	if x != nil {
		return x.MinHtlcMsat
	}
	return 0
}

func (x *BatchOpenChannel) GetRemoteCsvDelay() uint32 {
	if x != nil {
		return x.RemoteCsvDelay
	}
	return 0
}

func (x *BatchOpenChannel) GetCloseAddress() string {
	if x != nil {
		return x.CloseAddress
	}
	return ""
}

func (x *BatchOpenChannel) GetPendingChanId() []byte {
	if x != nil {
		return x.PendingChanId
	}
	return nil
}

func (x *BatchOpenChannel) GetCommitmentType() CommitmentType {
	if x != nil {
		return x.CommitmentType
	}
	return CommitmentType_UNKNOWN_COMMITMENT_TYPE
}

func (x *BatchOpenChannel) GetRemoteMaxValueInFlightMsat() uint64 {
	if x != nil {
		return x.RemoteMaxValueInFlightMsat
	}
	return 0
}

func (x *BatchOpenChannel) GetRemoteMaxHtlcs() uint32 {
	if x != nil {
		return x.RemoteMaxHtlcs
	}
	return 0
}

func (x *BatchOpenChannel) GetMaxLocalCsv() uint32 {
	if x != nil {
		return x.MaxLocalCsv
	}
	return 0
}

func (x *BatchOpenChannel) GetZeroConf() bool {
	if x != nil {
		return x.ZeroConf
	}
	return false
}

func (x *BatchOpenChannel) GetScidAlias() bool {
	if x != nil {
		return x.ScidAlias
	}
	return false
}

func (x *BatchOpenChannel) GetBaseFee() uint64 {
	if x != nil {
		return x.BaseFee
	}
	return 0
}

func (x *BatchOpenChannel) GetFeeRate() uint64 {
	if x != nil {
		return x.FeeRate
	}
	return 0
}

func (x *BatchOpenChannel) GetUseBaseFee() bool {
	if x != nil {
		return x.UseBaseFee
	}
	return false
}

func (x *BatchOpenChannel) GetUseFeeRate() bool {
	if x != nil {
		return x.UseFeeRate
	}
	return false
}

func (x *BatchOpenChannel) GetRemoteChanReserveSat() uint64 {
	if x != nil {
		return x.RemoteChanReserveSat
	}
	return 0
}

func (x *BatchOpenChannel) GetMemo() string {
	if x != nil {
		return x.Memo
	}
	return ""
}

type BatchOpenChannelResponse struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	PendingChannels []*PendingUpdate       `protobuf:"bytes,1,rep,name=pending_channels,json=pendingChannels,proto3" json:"pending_channels,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *BatchOpenChannelResponse) Reset() {
	*x = BatchOpenChannelResponse{}
	mi := &file_lightning_proto_msgTypes[78]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchOpenChannelResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchOpenChannelResponse) ProtoMessage() {}

func (x *BatchOpenChannelResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[78]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchOpenChannelResponse.ProtoReflect.Descriptor instead.
func (*BatchOpenChannelResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{78}
}

func (x *BatchOpenChannelResponse) GetPendingChannels() []*PendingUpdate {
	if x != nil {
		return x.PendingChannels
	}
	return nil
}

type OpenChannelRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A manual fee rate set in sat/vbyte that should be used when crafting the
	// funding transaction.
	SatPerVbyte uint64 `protobuf:"varint,1,opt,name=sat_per_vbyte,json=satPerVbyte,proto3" json:"sat_per_vbyte,omitempty"`
	// The pubkey of the node to open a channel with. When using REST, this field
	// must be encoded as base64.
	NodePubkey []byte `protobuf:"bytes,2,opt,name=node_pubkey,json=nodePubkey,proto3" json:"node_pubkey,omitempty"`
	// The hex encoded pubkey of the node to open a channel with. Deprecated now
	// that the REST gateway supports base64 encoding of bytes fields.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	NodePubkeyString string `protobuf:"bytes,3,opt,name=node_pubkey_string,json=nodePubkeyString,proto3" json:"node_pubkey_string,omitempty"`
	// The number of satoshis the wallet should commit to the channel
	LocalFundingAmount int64 `protobuf:"varint,4,opt,name=local_funding_amount,json=localFundingAmount,proto3" json:"local_funding_amount,omitempty"`
	// The number of satoshis to push to the remote side as part of the initial
	// commitment state
	PushSat int64 `protobuf:"varint,5,opt,name=push_sat,json=pushSat,proto3" json:"push_sat,omitempty"`
	// The target number of blocks that the funding transaction should be
	// confirmed by.
	TargetConf int32 `protobuf:"varint,6,opt,name=target_conf,json=targetConf,proto3" json:"target_conf,omitempty"`
	// Deprecated, use sat_per_vbyte.
	// A manual fee rate set in sat/vbyte that should be used when crafting the
	// funding transaction.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	SatPerByte int64 `protobuf:"varint,7,opt,name=sat_per_byte,json=satPerByte,proto3" json:"sat_per_byte,omitempty"`
	// Whether this channel should be private, not announced to the greater
	// network.
	Private bool `protobuf:"varint,8,opt,name=private,proto3" json:"private,omitempty"`
	// The minimum value in millisatoshi we will require for incoming HTLCs on
	// the channel.
	MinHtlcMsat int64 `protobuf:"varint,9,opt,name=min_htlc_msat,json=minHtlcMsat,proto3" json:"min_htlc_msat,omitempty"`
	// The delay we require on the remote's commitment transaction. If this is
	// not set, it will be scaled automatically with the channel size.
	RemoteCsvDelay uint32 `protobuf:"varint,10,opt,name=remote_csv_delay,json=remoteCsvDelay,proto3" json:"remote_csv_delay,omitempty"`
	// The minimum number of confirmations each one of your outputs used for
	// the funding transaction must satisfy.
	MinConfs int32 `protobuf:"varint,11,opt,name=min_confs,json=minConfs,proto3" json:"min_confs,omitempty"`
	// Whether unconfirmed outputs should be used as inputs for the funding
	// transaction.
	SpendUnconfirmed bool `protobuf:"varint,12,opt,name=spend_unconfirmed,json=spendUnconfirmed,proto3" json:"spend_unconfirmed,omitempty"`
	// Close address is an optional address which specifies the address to which
	// funds should be paid out to upon cooperative close. This field may only be
	// set if the peer supports the option upfront feature bit (call listpeers
	// to check). The remote peer will only accept cooperative closes to this
	// address if it is set.
	//
	// Note: If this value is set on channel creation, you will *not* be able to
	// cooperatively close out to a different address.
	CloseAddress string `protobuf:"bytes,13,opt,name=close_address,json=closeAddress,proto3" json:"close_address,omitempty"`
	// Funding shims are an optional argument that allow the caller to intercept
	// certain funding functionality. For example, a shim can be provided to use a
	// particular key for the commitment key (ideally cold) rather than use one
	// that is generated by the wallet as normal, or signal that signing will be
	// carried out in an interactive manner (PSBT based).
	FundingShim *FundingShim `protobuf:"bytes,14,opt,name=funding_shim,json=fundingShim,proto3" json:"funding_shim,omitempty"`
	// The maximum amount of coins in millisatoshi that can be pending within
	// the channel. It only applies to the remote party.
	RemoteMaxValueInFlightMsat uint64 `protobuf:"varint,15,opt,name=remote_max_value_in_flight_msat,json=remoteMaxValueInFlightMsat,proto3" json:"remote_max_value_in_flight_msat,omitempty"`
	// The maximum number of concurrent HTLCs we will allow the remote party to add
	// to the commitment transaction.
	RemoteMaxHtlcs uint32 `protobuf:"varint,16,opt,name=remote_max_htlcs,json=remoteMaxHtlcs,proto3" json:"remote_max_htlcs,omitempty"`
	// Max local csv is the maximum csv delay we will allow for our own commitment
	// transaction.
	MaxLocalCsv uint32 `protobuf:"varint,17,opt,name=max_local_csv,json=maxLocalCsv,proto3" json:"max_local_csv,omitempty"`
	// The explicit commitment type to use. Note this field will only be used if
	// the remote peer supports explicit channel negotiation.
	CommitmentType CommitmentType `protobuf:"varint,18,opt,name=commitment_type,json=commitmentType,proto3,enum=lnrpc.CommitmentType" json:"commitment_type,omitempty"`
	// If this is true, then a zero-conf channel open will be attempted.
	ZeroConf bool `protobuf:"varint,19,opt,name=zero_conf,json=zeroConf,proto3" json:"zero_conf,omitempty"`
	// If this is true, then an option-scid-alias channel-type open will be
	// attempted.
	ScidAlias bool `protobuf:"varint,20,opt,name=scid_alias,json=scidAlias,proto3" json:"scid_alias,omitempty"`
	// The base fee charged regardless of the number of milli-satoshis sent.
	BaseFee uint64 `protobuf:"varint,21,opt,name=base_fee,json=baseFee,proto3" json:"base_fee,omitempty"`
	// The fee rate in ppm (parts per million) that will be charged in
	// proportion of the value of each forwarded HTLC.
	FeeRate uint64 `protobuf:"varint,22,opt,name=fee_rate,json=feeRate,proto3" json:"fee_rate,omitempty"`
	// If use_base_fee is true the open channel announcement will update the
	// channel base fee with the value specified in base_fee. In the case of
	// a base_fee of 0 use_base_fee is needed downstream to distinguish whether
	// to use the default base fee value specified in the config or 0.
	UseBaseFee bool `protobuf:"varint,23,opt,name=use_base_fee,json=useBaseFee,proto3" json:"use_base_fee,omitempty"`
	// If use_fee_rate is true the open channel announcement will update the
	// channel fee rate with the value specified in fee_rate. In the case of
	// a fee_rate of 0 use_fee_rate is needed downstream to distinguish whether
	// to use the default fee rate value specified in the config or 0.
	UseFeeRate bool `protobuf:"varint,24,opt,name=use_fee_rate,json=useFeeRate,proto3" json:"use_fee_rate,omitempty"`
	// The number of satoshis we require the remote peer to reserve. This value,
	// if specified, must be above the dust limit and below 20% of the channel
	// capacity.
	RemoteChanReserveSat uint64 `protobuf:"varint,25,opt,name=remote_chan_reserve_sat,json=remoteChanReserveSat,proto3" json:"remote_chan_reserve_sat,omitempty"`
	// If set, then lnd will attempt to commit all the coins under control of the
	// internal wallet to open the channel, and the LocalFundingAmount field must
	// be zero and is ignored.
	FundMax bool `protobuf:"varint,26,opt,name=fund_max,json=fundMax,proto3" json:"fund_max,omitempty"`
	// An optional note-to-self to go along with the channel containing some
	// useful information. This is only ever stored locally and in no way impacts
	// the channel's operation.
	Memo string `protobuf:"bytes,27,opt,name=memo,proto3" json:"memo,omitempty"`
	// A list of selected outpoints that are allocated for channel funding.
	Outpoints     []*OutPoint `protobuf:"bytes,28,rep,name=outpoints,proto3" json:"outpoints,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OpenChannelRequest) Reset() {
	*x = OpenChannelRequest{}
	mi := &file_lightning_proto_msgTypes[79]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpenChannelRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpenChannelRequest) ProtoMessage() {}

func (x *OpenChannelRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[79]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpenChannelRequest.ProtoReflect.Descriptor instead.
func (*OpenChannelRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{79}
}

func (x *OpenChannelRequest) GetSatPerVbyte() uint64 {
	if x != nil {
		return x.SatPerVbyte
	}
	return 0
}

func (x *OpenChannelRequest) GetNodePubkey() []byte {
	if x != nil {
		return x.NodePubkey
	}
	return nil
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *OpenChannelRequest) GetNodePubkeyString() string {
	if x != nil {
		return x.NodePubkeyString
	}
	return ""
}

func (x *OpenChannelRequest) GetLocalFundingAmount() int64 {
	if x != nil {
		return x.LocalFundingAmount
	}
	return 0
}

func (x *OpenChannelRequest) GetPushSat() int64 {
	if x != nil {
		return x.PushSat
	}
	return 0
}

func (x *OpenChannelRequest) GetTargetConf() int32 {
	if x != nil {
		return x.TargetConf
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *OpenChannelRequest) GetSatPerByte() int64 {
	if x != nil {
		return x.SatPerByte
	}
	return 0
}

func (x *OpenChannelRequest) GetPrivate() bool {
	if x != nil {
		return x.Private
	}
	return false
}

func (x *OpenChannelRequest) GetMinHtlcMsat() int64 {
	if x != nil {
		return x.MinHtlcMsat
	}
	return 0
}

func (x *OpenChannelRequest) GetRemoteCsvDelay() uint32 {
	if x != nil {
		return x.RemoteCsvDelay
	}
	return 0
}

func (x *OpenChannelRequest) GetMinConfs() int32 {
	if x != nil {
		return x.MinConfs
	}
	return 0
}

func (x *OpenChannelRequest) GetSpendUnconfirmed() bool {
	if x != nil {
		return x.SpendUnconfirmed
	}
	return false
}

func (x *OpenChannelRequest) GetCloseAddress() string {
	if x != nil {
		return x.CloseAddress
	}
	return ""
}

func (x *OpenChannelRequest) GetFundingShim() *FundingShim {
	if x != nil {
		return x.FundingShim
	}
	return nil
}

func (x *OpenChannelRequest) GetRemoteMaxValueInFlightMsat() uint64 {
	if x != nil {
		return x.RemoteMaxValueInFlightMsat
	}
	return 0
}

func (x *OpenChannelRequest) GetRemoteMaxHtlcs() uint32 {
	if x != nil {
		return x.RemoteMaxHtlcs
	}
	return 0
}

func (x *OpenChannelRequest) GetMaxLocalCsv() uint32 {
	if x != nil {
		return x.MaxLocalCsv
	}
	return 0
}

func (x *OpenChannelRequest) GetCommitmentType() CommitmentType {
	if x != nil {
		return x.CommitmentType
	}
	return CommitmentType_UNKNOWN_COMMITMENT_TYPE
}

func (x *OpenChannelRequest) GetZeroConf() bool {
	if x != nil {
		return x.ZeroConf
	}
	return false
}

func (x *OpenChannelRequest) GetScidAlias() bool {
	if x != nil {
		return x.ScidAlias
	}
	return false
}

func (x *OpenChannelRequest) GetBaseFee() uint64 {
	if x != nil {
		return x.BaseFee
	}
	return 0
}

func (x *OpenChannelRequest) GetFeeRate() uint64 {
	if x != nil {
		return x.FeeRate
	}
	return 0
}

func (x *OpenChannelRequest) GetUseBaseFee() bool {
	if x != nil {
		return x.UseBaseFee
	}
	return false
}

func (x *OpenChannelRequest) GetUseFeeRate() bool {
	if x != nil {
		return x.UseFeeRate
	}
	return false
}

func (x *OpenChannelRequest) GetRemoteChanReserveSat() uint64 {
	if x != nil {
		return x.RemoteChanReserveSat
	}
	return 0
}

func (x *OpenChannelRequest) GetFundMax() bool {
	if x != nil {
		return x.FundMax
	}
	return false
}

func (x *OpenChannelRequest) GetMemo() string {
	if x != nil {
		return x.Memo
	}
	return ""
}

func (x *OpenChannelRequest) GetOutpoints() []*OutPoint {
	if x != nil {
		return x.Outpoints
	}
	return nil
}

type OpenStatusUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Update:
	//
	//	*OpenStatusUpdate_ChanPending
	//	*OpenStatusUpdate_ChanOpen
	//	*OpenStatusUpdate_PsbtFund
	Update isOpenStatusUpdate_Update `protobuf_oneof:"update"`
	// The pending channel ID of the created channel. This value may be used to
	// further the funding flow manually via the FundingStateStep method.
	PendingChanId []byte `protobuf:"bytes,4,opt,name=pending_chan_id,json=pendingChanId,proto3" json:"pending_chan_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OpenStatusUpdate) Reset() {
	*x = OpenStatusUpdate{}
	mi := &file_lightning_proto_msgTypes[80]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpenStatusUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpenStatusUpdate) ProtoMessage() {}

func (x *OpenStatusUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[80]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpenStatusUpdate.ProtoReflect.Descriptor instead.
func (*OpenStatusUpdate) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{80}
}

func (x *OpenStatusUpdate) GetUpdate() isOpenStatusUpdate_Update {
	if x != nil {
		return x.Update
	}
	return nil
}

func (x *OpenStatusUpdate) GetChanPending() *PendingUpdate {
	if x != nil {
		if x, ok := x.Update.(*OpenStatusUpdate_ChanPending); ok {
			return x.ChanPending
		}
	}
	return nil
}

func (x *OpenStatusUpdate) GetChanOpen() *ChannelOpenUpdate {
	if x != nil {
		if x, ok := x.Update.(*OpenStatusUpdate_ChanOpen); ok {
			return x.ChanOpen
		}
	}
	return nil
}

func (x *OpenStatusUpdate) GetPsbtFund() *ReadyForPsbtFunding {
	if x != nil {
		if x, ok := x.Update.(*OpenStatusUpdate_PsbtFund); ok {
			return x.PsbtFund
		}
	}
	return nil
}

func (x *OpenStatusUpdate) GetPendingChanId() []byte {
	if x != nil {
		return x.PendingChanId
	}
	return nil
}

type isOpenStatusUpdate_Update interface {
	isOpenStatusUpdate_Update()
}

type OpenStatusUpdate_ChanPending struct {
	// Signals that the channel is now fully negotiated and the funding
	// transaction published.
	ChanPending *PendingUpdate `protobuf:"bytes,1,opt,name=chan_pending,json=chanPending,proto3,oneof"`
}

type OpenStatusUpdate_ChanOpen struct {
	// Signals that the channel's funding transaction has now reached the
	// required number of confirmations on chain and can be used.
	ChanOpen *ChannelOpenUpdate `protobuf:"bytes,3,opt,name=chan_open,json=chanOpen,proto3,oneof"`
}

type OpenStatusUpdate_PsbtFund struct {
	// Signals that the funding process has been suspended and the construction
	// of a PSBT that funds the channel PK script is now required.
	PsbtFund *ReadyForPsbtFunding `protobuf:"bytes,5,opt,name=psbt_fund,json=psbtFund,proto3,oneof"`
}

func (*OpenStatusUpdate_ChanPending) isOpenStatusUpdate_Update() {}

func (*OpenStatusUpdate_ChanOpen) isOpenStatusUpdate_Update() {}

func (*OpenStatusUpdate_PsbtFund) isOpenStatusUpdate_Update() {}

type KeyLocator struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The family of key being identified.
	KeyFamily int32 `protobuf:"varint,1,opt,name=key_family,json=keyFamily,proto3" json:"key_family,omitempty"`
	// The precise index of the key being identified.
	KeyIndex      int32 `protobuf:"varint,2,opt,name=key_index,json=keyIndex,proto3" json:"key_index,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyLocator) Reset() {
	*x = KeyLocator{}
	mi := &file_lightning_proto_msgTypes[81]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyLocator) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyLocator) ProtoMessage() {}

func (x *KeyLocator) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[81]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyLocator.ProtoReflect.Descriptor instead.
func (*KeyLocator) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{81}
}

func (x *KeyLocator) GetKeyFamily() int32 {
	if x != nil {
		return x.KeyFamily
	}
	return 0
}

func (x *KeyLocator) GetKeyIndex() int32 {
	if x != nil {
		return x.KeyIndex
	}
	return 0
}

type KeyDescriptor struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The raw bytes of the key being identified.
	RawKeyBytes []byte `protobuf:"bytes,1,opt,name=raw_key_bytes,json=rawKeyBytes,proto3" json:"raw_key_bytes,omitempty"`
	// The key locator that identifies which key to use for signing.
	KeyLoc        *KeyLocator `protobuf:"bytes,2,opt,name=key_loc,json=keyLoc,proto3" json:"key_loc,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyDescriptor) Reset() {
	*x = KeyDescriptor{}
	mi := &file_lightning_proto_msgTypes[82]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyDescriptor) ProtoMessage() {}

func (x *KeyDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[82]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyDescriptor.ProtoReflect.Descriptor instead.
func (*KeyDescriptor) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{82}
}

func (x *KeyDescriptor) GetRawKeyBytes() []byte {
	if x != nil {
		return x.RawKeyBytes
	}
	return nil
}

func (x *KeyDescriptor) GetKeyLoc() *KeyLocator {
	if x != nil {
		return x.KeyLoc
	}
	return nil
}

type ChanPointShim struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The size of the pre-crafted output to be used as the channel point for this
	// channel funding.
	Amt int64 `protobuf:"varint,1,opt,name=amt,proto3" json:"amt,omitempty"`
	// The target channel point to refrence in created commitment transactions.
	ChanPoint *ChannelPoint `protobuf:"bytes,2,opt,name=chan_point,json=chanPoint,proto3" json:"chan_point,omitempty"`
	// Our local key to use when creating the multi-sig output.
	LocalKey *KeyDescriptor `protobuf:"bytes,3,opt,name=local_key,json=localKey,proto3" json:"local_key,omitempty"`
	// The key of the remote party to use when creating the multi-sig output.
	RemoteKey []byte `protobuf:"bytes,4,opt,name=remote_key,json=remoteKey,proto3" json:"remote_key,omitempty"`
	// If non-zero, then this will be used as the pending channel ID on the wire
	// protocol to initate the funding request. This is an optional field, and
	// should only be set if the responder is already expecting a specific pending
	// channel ID.
	PendingChanId []byte `protobuf:"bytes,5,opt,name=pending_chan_id,json=pendingChanId,proto3" json:"pending_chan_id,omitempty"`
	// This uint32 indicates if this channel is to be considered 'frozen'. A frozen
	// channel does not allow a cooperative channel close by the initiator. The
	// thaw_height is the height that this restriction stops applying to the
	// channel. The height can be interpreted in two ways: as a relative height if
	// the value is less than 500,000, or as an absolute height otherwise.
	ThawHeight uint32 `protobuf:"varint,6,opt,name=thaw_height,json=thawHeight,proto3" json:"thaw_height,omitempty"`
	// Indicates that the funding output is using a MuSig2 multi-sig output.
	Musig2        bool `protobuf:"varint,7,opt,name=musig2,proto3" json:"musig2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChanPointShim) Reset() {
	*x = ChanPointShim{}
	mi := &file_lightning_proto_msgTypes[83]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChanPointShim) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChanPointShim) ProtoMessage() {}

func (x *ChanPointShim) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[83]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChanPointShim.ProtoReflect.Descriptor instead.
func (*ChanPointShim) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{83}
}

func (x *ChanPointShim) GetAmt() int64 {
	if x != nil {
		return x.Amt
	}
	return 0
}

func (x *ChanPointShim) GetChanPoint() *ChannelPoint {
	if x != nil {
		return x.ChanPoint
	}
	return nil
}

func (x *ChanPointShim) GetLocalKey() *KeyDescriptor {
	if x != nil {
		return x.LocalKey
	}
	return nil
}

func (x *ChanPointShim) GetRemoteKey() []byte {
	if x != nil {
		return x.RemoteKey
	}
	return nil
}

func (x *ChanPointShim) GetPendingChanId() []byte {
	if x != nil {
		return x.PendingChanId
	}
	return nil
}

func (x *ChanPointShim) GetThawHeight() uint32 {
	if x != nil {
		return x.ThawHeight
	}
	return 0
}

func (x *ChanPointShim) GetMusig2() bool {
	if x != nil {
		return x.Musig2
	}
	return false
}

type PsbtShim struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A unique identifier of 32 random bytes that will be used as the pending
	// channel ID to identify the PSBT state machine when interacting with it and
	// on the wire protocol to initiate the funding request.
	PendingChanId []byte `protobuf:"bytes,1,opt,name=pending_chan_id,json=pendingChanId,proto3" json:"pending_chan_id,omitempty"`
	// An optional base PSBT the new channel output will be added to. If this is
	// non-empty, it must be a binary serialized PSBT.
	BasePsbt []byte `protobuf:"bytes,2,opt,name=base_psbt,json=basePsbt,proto3" json:"base_psbt,omitempty"`
	// If a channel should be part of a batch (multiple channel openings in one
	// transaction), it can be dangerous if the whole batch transaction is
	// published too early before all channel opening negotiations are completed.
	// This flag prevents this particular channel from broadcasting the transaction
	// after the negotiation with the remote peer. In a batch of channel openings
	// this flag should be set to true for every channel but the very last.
	NoPublish     bool `protobuf:"varint,3,opt,name=no_publish,json=noPublish,proto3" json:"no_publish,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PsbtShim) Reset() {
	*x = PsbtShim{}
	mi := &file_lightning_proto_msgTypes[84]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PsbtShim) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PsbtShim) ProtoMessage() {}

func (x *PsbtShim) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[84]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PsbtShim.ProtoReflect.Descriptor instead.
func (*PsbtShim) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{84}
}

func (x *PsbtShim) GetPendingChanId() []byte {
	if x != nil {
		return x.PendingChanId
	}
	return nil
}

func (x *PsbtShim) GetBasePsbt() []byte {
	if x != nil {
		return x.BasePsbt
	}
	return nil
}

func (x *PsbtShim) GetNoPublish() bool {
	if x != nil {
		return x.NoPublish
	}
	return false
}

type FundingShim struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Shim:
	//
	//	*FundingShim_ChanPointShim
	//	*FundingShim_PsbtShim
	Shim          isFundingShim_Shim `protobuf_oneof:"shim"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FundingShim) Reset() {
	*x = FundingShim{}
	mi := &file_lightning_proto_msgTypes[85]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FundingShim) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FundingShim) ProtoMessage() {}

func (x *FundingShim) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[85]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FundingShim.ProtoReflect.Descriptor instead.
func (*FundingShim) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{85}
}

func (x *FundingShim) GetShim() isFundingShim_Shim {
	if x != nil {
		return x.Shim
	}
	return nil
}

func (x *FundingShim) GetChanPointShim() *ChanPointShim {
	if x != nil {
		if x, ok := x.Shim.(*FundingShim_ChanPointShim); ok {
			return x.ChanPointShim
		}
	}
	return nil
}

func (x *FundingShim) GetPsbtShim() *PsbtShim {
	if x != nil {
		if x, ok := x.Shim.(*FundingShim_PsbtShim); ok {
			return x.PsbtShim
		}
	}
	return nil
}

type isFundingShim_Shim interface {
	isFundingShim_Shim()
}

type FundingShim_ChanPointShim struct {
	// A channel shim where the channel point was fully constructed outside
	// of lnd's wallet and the transaction might already be published.
	ChanPointShim *ChanPointShim `protobuf:"bytes,1,opt,name=chan_point_shim,json=chanPointShim,proto3,oneof"`
}

type FundingShim_PsbtShim struct {
	// A channel shim that uses a PSBT to fund and sign the channel funding
	// transaction.
	PsbtShim *PsbtShim `protobuf:"bytes,2,opt,name=psbt_shim,json=psbtShim,proto3,oneof"`
}

func (*FundingShim_ChanPointShim) isFundingShim_Shim() {}

func (*FundingShim_PsbtShim) isFundingShim_Shim() {}

type FundingShimCancel struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The pending channel ID of the channel to cancel the funding shim for.
	PendingChanId []byte `protobuf:"bytes,1,opt,name=pending_chan_id,json=pendingChanId,proto3" json:"pending_chan_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FundingShimCancel) Reset() {
	*x = FundingShimCancel{}
	mi := &file_lightning_proto_msgTypes[86]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FundingShimCancel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FundingShimCancel) ProtoMessage() {}

func (x *FundingShimCancel) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[86]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FundingShimCancel.ProtoReflect.Descriptor instead.
func (*FundingShimCancel) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{86}
}

func (x *FundingShimCancel) GetPendingChanId() []byte {
	if x != nil {
		return x.PendingChanId
	}
	return nil
}

type FundingPsbtVerify struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The funded but not yet signed PSBT that sends the exact channel capacity
	// amount to the PK script returned in the open channel message in a previous
	// step.
	FundedPsbt []byte `protobuf:"bytes,1,opt,name=funded_psbt,json=fundedPsbt,proto3" json:"funded_psbt,omitempty"`
	// The pending channel ID of the channel to get the PSBT for.
	PendingChanId []byte `protobuf:"bytes,2,opt,name=pending_chan_id,json=pendingChanId,proto3" json:"pending_chan_id,omitempty"`
	// Can only be used if the no_publish flag was set to true in the OpenChannel
	// call meaning that the caller is solely responsible for publishing the final
	// funding transaction. If skip_finalize is set to true then lnd will not wait
	// for a FundingPsbtFinalize state step and instead assumes that a transaction
	// with the same TXID as the passed in PSBT will eventually confirm.
	// IT IS ABSOLUTELY IMPERATIVE that the TXID of the transaction that is
	// eventually published does have the _same TXID_ as the verified PSBT. That
	// means no inputs or outputs can change, only signatures can be added. If the
	// TXID changes between this call and the publish step then the channel will
	// never be created and the funds will be in limbo.
	SkipFinalize  bool `protobuf:"varint,3,opt,name=skip_finalize,json=skipFinalize,proto3" json:"skip_finalize,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FundingPsbtVerify) Reset() {
	*x = FundingPsbtVerify{}
	mi := &file_lightning_proto_msgTypes[87]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FundingPsbtVerify) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FundingPsbtVerify) ProtoMessage() {}

func (x *FundingPsbtVerify) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[87]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FundingPsbtVerify.ProtoReflect.Descriptor instead.
func (*FundingPsbtVerify) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{87}
}

func (x *FundingPsbtVerify) GetFundedPsbt() []byte {
	if x != nil {
		return x.FundedPsbt
	}
	return nil
}

func (x *FundingPsbtVerify) GetPendingChanId() []byte {
	if x != nil {
		return x.PendingChanId
	}
	return nil
}

func (x *FundingPsbtVerify) GetSkipFinalize() bool {
	if x != nil {
		return x.SkipFinalize
	}
	return false
}

type FundingPsbtFinalize struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The funded PSBT that contains all witness data to send the exact channel
	// capacity amount to the PK script returned in the open channel message in a
	// previous step. Cannot be set at the same time as final_raw_tx.
	SignedPsbt []byte `protobuf:"bytes,1,opt,name=signed_psbt,json=signedPsbt,proto3" json:"signed_psbt,omitempty"`
	// The pending channel ID of the channel to get the PSBT for.
	PendingChanId []byte `protobuf:"bytes,2,opt,name=pending_chan_id,json=pendingChanId,proto3" json:"pending_chan_id,omitempty"`
	// As an alternative to the signed PSBT with all witness data, the final raw
	// wire format transaction can also be specified directly. Cannot be set at the
	// same time as signed_psbt.
	FinalRawTx    []byte `protobuf:"bytes,3,opt,name=final_raw_tx,json=finalRawTx,proto3" json:"final_raw_tx,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FundingPsbtFinalize) Reset() {
	*x = FundingPsbtFinalize{}
	mi := &file_lightning_proto_msgTypes[88]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FundingPsbtFinalize) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FundingPsbtFinalize) ProtoMessage() {}

func (x *FundingPsbtFinalize) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[88]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FundingPsbtFinalize.ProtoReflect.Descriptor instead.
func (*FundingPsbtFinalize) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{88}
}

func (x *FundingPsbtFinalize) GetSignedPsbt() []byte {
	if x != nil {
		return x.SignedPsbt
	}
	return nil
}

func (x *FundingPsbtFinalize) GetPendingChanId() []byte {
	if x != nil {
		return x.PendingChanId
	}
	return nil
}

func (x *FundingPsbtFinalize) GetFinalRawTx() []byte {
	if x != nil {
		return x.FinalRawTx
	}
	return nil
}

type FundingTransitionMsg struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Trigger:
	//
	//	*FundingTransitionMsg_ShimRegister
	//	*FundingTransitionMsg_ShimCancel
	//	*FundingTransitionMsg_PsbtVerify
	//	*FundingTransitionMsg_PsbtFinalize
	Trigger       isFundingTransitionMsg_Trigger `protobuf_oneof:"trigger"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FundingTransitionMsg) Reset() {
	*x = FundingTransitionMsg{}
	mi := &file_lightning_proto_msgTypes[89]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FundingTransitionMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FundingTransitionMsg) ProtoMessage() {}

func (x *FundingTransitionMsg) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[89]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FundingTransitionMsg.ProtoReflect.Descriptor instead.
func (*FundingTransitionMsg) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{89}
}

func (x *FundingTransitionMsg) GetTrigger() isFundingTransitionMsg_Trigger {
	if x != nil {
		return x.Trigger
	}
	return nil
}

func (x *FundingTransitionMsg) GetShimRegister() *FundingShim {
	if x != nil {
		if x, ok := x.Trigger.(*FundingTransitionMsg_ShimRegister); ok {
			return x.ShimRegister
		}
	}
	return nil
}

func (x *FundingTransitionMsg) GetShimCancel() *FundingShimCancel {
	if x != nil {
		if x, ok := x.Trigger.(*FundingTransitionMsg_ShimCancel); ok {
			return x.ShimCancel
		}
	}
	return nil
}

func (x *FundingTransitionMsg) GetPsbtVerify() *FundingPsbtVerify {
	if x != nil {
		if x, ok := x.Trigger.(*FundingTransitionMsg_PsbtVerify); ok {
			return x.PsbtVerify
		}
	}
	return nil
}

func (x *FundingTransitionMsg) GetPsbtFinalize() *FundingPsbtFinalize {
	if x != nil {
		if x, ok := x.Trigger.(*FundingTransitionMsg_PsbtFinalize); ok {
			return x.PsbtFinalize
		}
	}
	return nil
}

type isFundingTransitionMsg_Trigger interface {
	isFundingTransitionMsg_Trigger()
}

type FundingTransitionMsg_ShimRegister struct {
	// The funding shim to register. This should be used before any
	// channel funding has began by the remote party, as it is intended as a
	// preparatory step for the full channel funding.
	ShimRegister *FundingShim `protobuf:"bytes,1,opt,name=shim_register,json=shimRegister,proto3,oneof"`
}

type FundingTransitionMsg_ShimCancel struct {
	// Used to cancel an existing registered funding shim.
	ShimCancel *FundingShimCancel `protobuf:"bytes,2,opt,name=shim_cancel,json=shimCancel,proto3,oneof"`
}

type FundingTransitionMsg_PsbtVerify struct {
	// Used to continue a funding flow that was initiated to be executed
	// through a PSBT. This step verifies that the PSBT contains the correct
	// outputs to fund the channel.
	PsbtVerify *FundingPsbtVerify `protobuf:"bytes,3,opt,name=psbt_verify,json=psbtVerify,proto3,oneof"`
}

type FundingTransitionMsg_PsbtFinalize struct {
	// Used to continue a funding flow that was initiated to be executed
	// through a PSBT. This step finalizes the funded and signed PSBT, finishes
	// negotiation with the peer and finally publishes the resulting funding
	// transaction.
	PsbtFinalize *FundingPsbtFinalize `protobuf:"bytes,4,opt,name=psbt_finalize,json=psbtFinalize,proto3,oneof"`
}

func (*FundingTransitionMsg_ShimRegister) isFundingTransitionMsg_Trigger() {}

func (*FundingTransitionMsg_ShimCancel) isFundingTransitionMsg_Trigger() {}

func (*FundingTransitionMsg_PsbtVerify) isFundingTransitionMsg_Trigger() {}

func (*FundingTransitionMsg_PsbtFinalize) isFundingTransitionMsg_Trigger() {}

type FundingStateStepResp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FundingStateStepResp) Reset() {
	*x = FundingStateStepResp{}
	mi := &file_lightning_proto_msgTypes[90]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FundingStateStepResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FundingStateStepResp) ProtoMessage() {}

func (x *FundingStateStepResp) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[90]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FundingStateStepResp.ProtoReflect.Descriptor instead.
func (*FundingStateStepResp) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{90}
}

type PendingHTLC struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The direction within the channel that the htlc was sent
	Incoming bool `protobuf:"varint,1,opt,name=incoming,proto3" json:"incoming,omitempty"`
	// The total value of the htlc
	Amount int64 `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
	// The final output to be swept back to the user's wallet
	Outpoint string `protobuf:"bytes,3,opt,name=outpoint,proto3" json:"outpoint,omitempty"`
	// The next block height at which we can spend the current stage
	MaturityHeight uint32 `protobuf:"varint,4,opt,name=maturity_height,json=maturityHeight,proto3" json:"maturity_height,omitempty"`
	// The number of blocks remaining until the current stage can be swept.
	// Negative values indicate how many blocks have passed since becoming
	// mature.
	BlocksTilMaturity int32 `protobuf:"varint,5,opt,name=blocks_til_maturity,json=blocksTilMaturity,proto3" json:"blocks_til_maturity,omitempty"`
	// Indicates whether the htlc is in its first or second stage of recovery
	Stage         uint32 `protobuf:"varint,6,opt,name=stage,proto3" json:"stage,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PendingHTLC) Reset() {
	*x = PendingHTLC{}
	mi := &file_lightning_proto_msgTypes[91]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PendingHTLC) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingHTLC) ProtoMessage() {}

func (x *PendingHTLC) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[91]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PendingHTLC.ProtoReflect.Descriptor instead.
func (*PendingHTLC) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{91}
}

func (x *PendingHTLC) GetIncoming() bool {
	if x != nil {
		return x.Incoming
	}
	return false
}

func (x *PendingHTLC) GetAmount() int64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

func (x *PendingHTLC) GetOutpoint() string {
	if x != nil {
		return x.Outpoint
	}
	return ""
}

func (x *PendingHTLC) GetMaturityHeight() uint32 {
	if x != nil {
		return x.MaturityHeight
	}
	return 0
}

func (x *PendingHTLC) GetBlocksTilMaturity() int32 {
	if x != nil {
		return x.BlocksTilMaturity
	}
	return 0
}

func (x *PendingHTLC) GetStage() uint32 {
	if x != nil {
		return x.Stage
	}
	return 0
}

type PendingChannelsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Indicates whether to include the raw transaction hex for
	// waiting_close_channels.
	IncludeRawTx  bool `protobuf:"varint,1,opt,name=include_raw_tx,json=includeRawTx,proto3" json:"include_raw_tx,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PendingChannelsRequest) Reset() {
	*x = PendingChannelsRequest{}
	mi := &file_lightning_proto_msgTypes[92]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PendingChannelsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingChannelsRequest) ProtoMessage() {}

func (x *PendingChannelsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[92]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PendingChannelsRequest.ProtoReflect.Descriptor instead.
func (*PendingChannelsRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{92}
}

func (x *PendingChannelsRequest) GetIncludeRawTx() bool {
	if x != nil {
		return x.IncludeRawTx
	}
	return false
}

type PendingChannelsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The balance in satoshis encumbered in pending channels
	TotalLimboBalance int64 `protobuf:"varint,1,opt,name=total_limbo_balance,json=totalLimboBalance,proto3" json:"total_limbo_balance,omitempty"`
	// Channels pending opening
	PendingOpenChannels []*PendingChannelsResponse_PendingOpenChannel `protobuf:"bytes,2,rep,name=pending_open_channels,json=pendingOpenChannels,proto3" json:"pending_open_channels,omitempty"`
	// Deprecated: Channels pending closing previously contained cooperatively
	// closed channels with a single confirmation. These channels are now
	// considered closed from the time we see them on chain.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	PendingClosingChannels []*PendingChannelsResponse_ClosedChannel `protobuf:"bytes,3,rep,name=pending_closing_channels,json=pendingClosingChannels,proto3" json:"pending_closing_channels,omitempty"`
	// Channels pending force closing
	PendingForceClosingChannels []*PendingChannelsResponse_ForceClosedChannel `protobuf:"bytes,4,rep,name=pending_force_closing_channels,json=pendingForceClosingChannels,proto3" json:"pending_force_closing_channels,omitempty"`
	// Channels waiting for closing tx to confirm
	WaitingCloseChannels []*PendingChannelsResponse_WaitingCloseChannel `protobuf:"bytes,5,rep,name=waiting_close_channels,json=waitingCloseChannels,proto3" json:"waiting_close_channels,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *PendingChannelsResponse) Reset() {
	*x = PendingChannelsResponse{}
	mi := &file_lightning_proto_msgTypes[93]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PendingChannelsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingChannelsResponse) ProtoMessage() {}

func (x *PendingChannelsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[93]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PendingChannelsResponse.ProtoReflect.Descriptor instead.
func (*PendingChannelsResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{93}
}

func (x *PendingChannelsResponse) GetTotalLimboBalance() int64 {
	if x != nil {
		return x.TotalLimboBalance
	}
	return 0
}

func (x *PendingChannelsResponse) GetPendingOpenChannels() []*PendingChannelsResponse_PendingOpenChannel {
	if x != nil {
		return x.PendingOpenChannels
	}
	return nil
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *PendingChannelsResponse) GetPendingClosingChannels() []*PendingChannelsResponse_ClosedChannel {
	if x != nil {
		return x.PendingClosingChannels
	}
	return nil
}

func (x *PendingChannelsResponse) GetPendingForceClosingChannels() []*PendingChannelsResponse_ForceClosedChannel {
	if x != nil {
		return x.PendingForceClosingChannels
	}
	return nil
}

func (x *PendingChannelsResponse) GetWaitingCloseChannels() []*PendingChannelsResponse_WaitingCloseChannel {
	if x != nil {
		return x.WaitingCloseChannels
	}
	return nil
}

type ChannelEventSubscription struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChannelEventSubscription) Reset() {
	*x = ChannelEventSubscription{}
	mi := &file_lightning_proto_msgTypes[94]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelEventSubscription) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelEventSubscription) ProtoMessage() {}

func (x *ChannelEventSubscription) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[94]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelEventSubscription.ProtoReflect.Descriptor instead.
func (*ChannelEventSubscription) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{94}
}

type ChannelEventUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Channel:
	//
	//	*ChannelEventUpdate_OpenChannel
	//	*ChannelEventUpdate_ClosedChannel
	//	*ChannelEventUpdate_ActiveChannel
	//	*ChannelEventUpdate_InactiveChannel
	//	*ChannelEventUpdate_PendingOpenChannel
	//	*ChannelEventUpdate_FullyResolvedChannel
	//	*ChannelEventUpdate_ChannelFundingTimeout
	Channel       isChannelEventUpdate_Channel  `protobuf_oneof:"channel"`
	Type          ChannelEventUpdate_UpdateType `protobuf:"varint,5,opt,name=type,proto3,enum=lnrpc.ChannelEventUpdate_UpdateType" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChannelEventUpdate) Reset() {
	*x = ChannelEventUpdate{}
	mi := &file_lightning_proto_msgTypes[95]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelEventUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelEventUpdate) ProtoMessage() {}

func (x *ChannelEventUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[95]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelEventUpdate.ProtoReflect.Descriptor instead.
func (*ChannelEventUpdate) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{95}
}

func (x *ChannelEventUpdate) GetChannel() isChannelEventUpdate_Channel {
	if x != nil {
		return x.Channel
	}
	return nil
}

func (x *ChannelEventUpdate) GetOpenChannel() *Channel {
	if x != nil {
		if x, ok := x.Channel.(*ChannelEventUpdate_OpenChannel); ok {
			return x.OpenChannel
		}
	}
	return nil
}

func (x *ChannelEventUpdate) GetClosedChannel() *ChannelCloseSummary {
	if x != nil {
		if x, ok := x.Channel.(*ChannelEventUpdate_ClosedChannel); ok {
			return x.ClosedChannel
		}
	}
	return nil
}

func (x *ChannelEventUpdate) GetActiveChannel() *ChannelPoint {
	if x != nil {
		if x, ok := x.Channel.(*ChannelEventUpdate_ActiveChannel); ok {
			return x.ActiveChannel
		}
	}
	return nil
}

func (x *ChannelEventUpdate) GetInactiveChannel() *ChannelPoint {
	if x != nil {
		if x, ok := x.Channel.(*ChannelEventUpdate_InactiveChannel); ok {
			return x.InactiveChannel
		}
	}
	return nil
}

func (x *ChannelEventUpdate) GetPendingOpenChannel() *PendingUpdate {
	if x != nil {
		if x, ok := x.Channel.(*ChannelEventUpdate_PendingOpenChannel); ok {
			return x.PendingOpenChannel
		}
	}
	return nil
}

func (x *ChannelEventUpdate) GetFullyResolvedChannel() *ChannelPoint {
	if x != nil {
		if x, ok := x.Channel.(*ChannelEventUpdate_FullyResolvedChannel); ok {
			return x.FullyResolvedChannel
		}
	}
	return nil
}

func (x *ChannelEventUpdate) GetChannelFundingTimeout() *ChannelPoint {
	if x != nil {
		if x, ok := x.Channel.(*ChannelEventUpdate_ChannelFundingTimeout); ok {
			return x.ChannelFundingTimeout
		}
	}
	return nil
}

func (x *ChannelEventUpdate) GetType() ChannelEventUpdate_UpdateType {
	if x != nil {
		return x.Type
	}
	return ChannelEventUpdate_OPEN_CHANNEL
}

type isChannelEventUpdate_Channel interface {
	isChannelEventUpdate_Channel()
}

type ChannelEventUpdate_OpenChannel struct {
	OpenChannel *Channel `protobuf:"bytes,1,opt,name=open_channel,json=openChannel,proto3,oneof"`
}

type ChannelEventUpdate_ClosedChannel struct {
	ClosedChannel *ChannelCloseSummary `protobuf:"bytes,2,opt,name=closed_channel,json=closedChannel,proto3,oneof"`
}

type ChannelEventUpdate_ActiveChannel struct {
	ActiveChannel *ChannelPoint `protobuf:"bytes,3,opt,name=active_channel,json=activeChannel,proto3,oneof"`
}

type ChannelEventUpdate_InactiveChannel struct {
	InactiveChannel *ChannelPoint `protobuf:"bytes,4,opt,name=inactive_channel,json=inactiveChannel,proto3,oneof"`
}

type ChannelEventUpdate_PendingOpenChannel struct {
	PendingOpenChannel *PendingUpdate `protobuf:"bytes,6,opt,name=pending_open_channel,json=pendingOpenChannel,proto3,oneof"`
}

type ChannelEventUpdate_FullyResolvedChannel struct {
	FullyResolvedChannel *ChannelPoint `protobuf:"bytes,7,opt,name=fully_resolved_channel,json=fullyResolvedChannel,proto3,oneof"`
}

type ChannelEventUpdate_ChannelFundingTimeout struct {
	ChannelFundingTimeout *ChannelPoint `protobuf:"bytes,8,opt,name=channel_funding_timeout,json=channelFundingTimeout,proto3,oneof"`
}

func (*ChannelEventUpdate_OpenChannel) isChannelEventUpdate_Channel() {}

func (*ChannelEventUpdate_ClosedChannel) isChannelEventUpdate_Channel() {}

func (*ChannelEventUpdate_ActiveChannel) isChannelEventUpdate_Channel() {}

func (*ChannelEventUpdate_InactiveChannel) isChannelEventUpdate_Channel() {}

func (*ChannelEventUpdate_PendingOpenChannel) isChannelEventUpdate_Channel() {}

func (*ChannelEventUpdate_FullyResolvedChannel) isChannelEventUpdate_Channel() {}

func (*ChannelEventUpdate_ChannelFundingTimeout) isChannelEventUpdate_Channel() {}

type WalletAccountBalance struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The confirmed balance of the account (with >= 1 confirmations).
	ConfirmedBalance int64 `protobuf:"varint,1,opt,name=confirmed_balance,json=confirmedBalance,proto3" json:"confirmed_balance,omitempty"`
	// The unconfirmed balance of the account (with 0 confirmations).
	UnconfirmedBalance int64 `protobuf:"varint,2,opt,name=unconfirmed_balance,json=unconfirmedBalance,proto3" json:"unconfirmed_balance,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *WalletAccountBalance) Reset() {
	*x = WalletAccountBalance{}
	mi := &file_lightning_proto_msgTypes[96]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WalletAccountBalance) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WalletAccountBalance) ProtoMessage() {}

func (x *WalletAccountBalance) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[96]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WalletAccountBalance.ProtoReflect.Descriptor instead.
func (*WalletAccountBalance) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{96}
}

func (x *WalletAccountBalance) GetConfirmedBalance() int64 {
	if x != nil {
		return x.ConfirmedBalance
	}
	return 0
}

func (x *WalletAccountBalance) GetUnconfirmedBalance() int64 {
	if x != nil {
		return x.UnconfirmedBalance
	}
	return 0
}

type WalletBalanceRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The wallet account the balance is shown for.
	// If this is not specified, the balance of the "default" account is shown.
	Account string `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	// The minimum number of confirmations each one of your outputs used for the
	// funding transaction must satisfy. If this is not specified, the default
	// value of 1 is used.
	MinConfs      int32 `protobuf:"varint,2,opt,name=min_confs,json=minConfs,proto3" json:"min_confs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WalletBalanceRequest) Reset() {
	*x = WalletBalanceRequest{}
	mi := &file_lightning_proto_msgTypes[97]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WalletBalanceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WalletBalanceRequest) ProtoMessage() {}

func (x *WalletBalanceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[97]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WalletBalanceRequest.ProtoReflect.Descriptor instead.
func (*WalletBalanceRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{97}
}

func (x *WalletBalanceRequest) GetAccount() string {
	if x != nil {
		return x.Account
	}
	return ""
}

func (x *WalletBalanceRequest) GetMinConfs() int32 {
	if x != nil {
		return x.MinConfs
	}
	return 0
}

type WalletBalanceResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The balance of the wallet
	TotalBalance int64 `protobuf:"varint,1,opt,name=total_balance,json=totalBalance,proto3" json:"total_balance,omitempty"`
	// The confirmed balance of a wallet(with >= 1 confirmations)
	ConfirmedBalance int64 `protobuf:"varint,2,opt,name=confirmed_balance,json=confirmedBalance,proto3" json:"confirmed_balance,omitempty"`
	// The unconfirmed balance of a wallet(with 0 confirmations)
	UnconfirmedBalance int64 `protobuf:"varint,3,opt,name=unconfirmed_balance,json=unconfirmedBalance,proto3" json:"unconfirmed_balance,omitempty"`
	// The total amount of wallet UTXOs held in outputs that are locked for
	// other usage.
	LockedBalance int64 `protobuf:"varint,5,opt,name=locked_balance,json=lockedBalance,proto3" json:"locked_balance,omitempty"`
	// The amount of reserve required.
	ReservedBalanceAnchorChan int64 `protobuf:"varint,6,opt,name=reserved_balance_anchor_chan,json=reservedBalanceAnchorChan,proto3" json:"reserved_balance_anchor_chan,omitempty"`
	// A mapping of each wallet account's name to its balance.
	AccountBalance map[string]*WalletAccountBalance `protobuf:"bytes,4,rep,name=account_balance,json=accountBalance,proto3" json:"account_balance,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *WalletBalanceResponse) Reset() {
	*x = WalletBalanceResponse{}
	mi := &file_lightning_proto_msgTypes[98]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WalletBalanceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WalletBalanceResponse) ProtoMessage() {}

func (x *WalletBalanceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[98]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WalletBalanceResponse.ProtoReflect.Descriptor instead.
func (*WalletBalanceResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{98}
}

func (x *WalletBalanceResponse) GetTotalBalance() int64 {
	if x != nil {
		return x.TotalBalance
	}
	return 0
}

func (x *WalletBalanceResponse) GetConfirmedBalance() int64 {
	if x != nil {
		return x.ConfirmedBalance
	}
	return 0
}

func (x *WalletBalanceResponse) GetUnconfirmedBalance() int64 {
	if x != nil {
		return x.UnconfirmedBalance
	}
	return 0
}

func (x *WalletBalanceResponse) GetLockedBalance() int64 {
	if x != nil {
		return x.LockedBalance
	}
	return 0
}

func (x *WalletBalanceResponse) GetReservedBalanceAnchorChan() int64 {
	if x != nil {
		return x.ReservedBalanceAnchorChan
	}
	return 0
}

func (x *WalletBalanceResponse) GetAccountBalance() map[string]*WalletAccountBalance {
	if x != nil {
		return x.AccountBalance
	}
	return nil
}

type Amount struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Value denominated in satoshis.
	Sat uint64 `protobuf:"varint,1,opt,name=sat,proto3" json:"sat,omitempty"`
	// Value denominated in milli-satoshis.
	Msat          uint64 `protobuf:"varint,2,opt,name=msat,proto3" json:"msat,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Amount) Reset() {
	*x = Amount{}
	mi := &file_lightning_proto_msgTypes[99]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Amount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Amount) ProtoMessage() {}

func (x *Amount) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[99]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Amount.ProtoReflect.Descriptor instead.
func (*Amount) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{99}
}

func (x *Amount) GetSat() uint64 {
	if x != nil {
		return x.Sat
	}
	return 0
}

func (x *Amount) GetMsat() uint64 {
	if x != nil {
		return x.Msat
	}
	return 0
}

type ChannelBalanceRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChannelBalanceRequest) Reset() {
	*x = ChannelBalanceRequest{}
	mi := &file_lightning_proto_msgTypes[100]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelBalanceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelBalanceRequest) ProtoMessage() {}

func (x *ChannelBalanceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[100]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelBalanceRequest.ProtoReflect.Descriptor instead.
func (*ChannelBalanceRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{100}
}

type ChannelBalanceResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Deprecated. Sum of channels balances denominated in satoshis
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	Balance int64 `protobuf:"varint,1,opt,name=balance,proto3" json:"balance,omitempty"`
	// Deprecated. Sum of channels pending balances denominated in satoshis
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	PendingOpenBalance int64 `protobuf:"varint,2,opt,name=pending_open_balance,json=pendingOpenBalance,proto3" json:"pending_open_balance,omitempty"`
	// Sum of channels local balances.
	LocalBalance *Amount `protobuf:"bytes,3,opt,name=local_balance,json=localBalance,proto3" json:"local_balance,omitempty"`
	// Sum of channels remote balances.
	RemoteBalance *Amount `protobuf:"bytes,4,opt,name=remote_balance,json=remoteBalance,proto3" json:"remote_balance,omitempty"`
	// Sum of channels local unsettled balances.
	UnsettledLocalBalance *Amount `protobuf:"bytes,5,opt,name=unsettled_local_balance,json=unsettledLocalBalance,proto3" json:"unsettled_local_balance,omitempty"`
	// Sum of channels remote unsettled balances.
	UnsettledRemoteBalance *Amount `protobuf:"bytes,6,opt,name=unsettled_remote_balance,json=unsettledRemoteBalance,proto3" json:"unsettled_remote_balance,omitempty"`
	// Sum of channels pending local balances.
	PendingOpenLocalBalance *Amount `protobuf:"bytes,7,opt,name=pending_open_local_balance,json=pendingOpenLocalBalance,proto3" json:"pending_open_local_balance,omitempty"`
	// Sum of channels pending remote balances.
	PendingOpenRemoteBalance *Amount `protobuf:"bytes,8,opt,name=pending_open_remote_balance,json=pendingOpenRemoteBalance,proto3" json:"pending_open_remote_balance,omitempty"`
	// Custom channel data that might be populated if there are custom channels
	// present.
	CustomChannelData []byte `protobuf:"bytes,9,opt,name=custom_channel_data,json=customChannelData,proto3" json:"custom_channel_data,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ChannelBalanceResponse) Reset() {
	*x = ChannelBalanceResponse{}
	mi := &file_lightning_proto_msgTypes[101]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelBalanceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelBalanceResponse) ProtoMessage() {}

func (x *ChannelBalanceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[101]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelBalanceResponse.ProtoReflect.Descriptor instead.
func (*ChannelBalanceResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{101}
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *ChannelBalanceResponse) GetBalance() int64 {
	if x != nil {
		return x.Balance
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *ChannelBalanceResponse) GetPendingOpenBalance() int64 {
	if x != nil {
		return x.PendingOpenBalance
	}
	return 0
}

func (x *ChannelBalanceResponse) GetLocalBalance() *Amount {
	if x != nil {
		return x.LocalBalance
	}
	return nil
}

func (x *ChannelBalanceResponse) GetRemoteBalance() *Amount {
	if x != nil {
		return x.RemoteBalance
	}
	return nil
}

func (x *ChannelBalanceResponse) GetUnsettledLocalBalance() *Amount {
	if x != nil {
		return x.UnsettledLocalBalance
	}
	return nil
}

func (x *ChannelBalanceResponse) GetUnsettledRemoteBalance() *Amount {
	if x != nil {
		return x.UnsettledRemoteBalance
	}
	return nil
}

func (x *ChannelBalanceResponse) GetPendingOpenLocalBalance() *Amount {
	if x != nil {
		return x.PendingOpenLocalBalance
	}
	return nil
}

func (x *ChannelBalanceResponse) GetPendingOpenRemoteBalance() *Amount {
	if x != nil {
		return x.PendingOpenRemoteBalance
	}
	return nil
}

func (x *ChannelBalanceResponse) GetCustomChannelData() []byte {
	if x != nil {
		return x.CustomChannelData
	}
	return nil
}

type QueryRoutesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The 33-byte hex-encoded public key for the payment destination
	PubKey string `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	// The amount to send expressed in satoshis.
	//
	// The fields amt and amt_msat are mutually exclusive.
	Amt int64 `protobuf:"varint,2,opt,name=amt,proto3" json:"amt,omitempty"`
	// The amount to send expressed in millisatoshis.
	//
	// The fields amt and amt_msat are mutually exclusive.
	AmtMsat int64 `protobuf:"varint,12,opt,name=amt_msat,json=amtMsat,proto3" json:"amt_msat,omitempty"`
	// An optional CLTV delta from the current height that should be used for the
	// timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
	// not add any additional block padding on top of final_ctlv_delta. This
	// padding of a few blocks needs to be added manually or otherwise failures may
	// happen when a block comes in while the payment is in flight.
	//
	// Note: must not be set if making a payment to a blinded path (delta is
	// set by the aggregate parameters provided by blinded_payment_paths)
	FinalCltvDelta int32 `protobuf:"varint,4,opt,name=final_cltv_delta,json=finalCltvDelta,proto3" json:"final_cltv_delta,omitempty"`
	// The maximum number of satoshis that will be paid as a fee of the payment.
	// This value can be represented either as a percentage of the amount being
	// sent, or as a fixed amount of the maximum fee the user is willing the pay to
	// send the payment. If not specified, lnd will use a default value of 100%
	// fees for small amounts (<=1k sat) or 5% fees for larger amounts.
	FeeLimit *FeeLimit `protobuf:"bytes,5,opt,name=fee_limit,json=feeLimit,proto3" json:"fee_limit,omitempty"`
	// A list of nodes to ignore during path finding. When using REST, these fields
	// must be encoded as base64.
	IgnoredNodes [][]byte `protobuf:"bytes,6,rep,name=ignored_nodes,json=ignoredNodes,proto3" json:"ignored_nodes,omitempty"`
	// Deprecated. A list of edges to ignore during path finding.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	IgnoredEdges []*EdgeLocator `protobuf:"bytes,7,rep,name=ignored_edges,json=ignoredEdges,proto3" json:"ignored_edges,omitempty"`
	// The source node where the request route should originated from. If empty,
	// self is assumed.
	SourcePubKey string `protobuf:"bytes,8,opt,name=source_pub_key,json=sourcePubKey,proto3" json:"source_pub_key,omitempty"`
	// If set to true, edge probabilities from mission control will be used to get
	// the optimal route.
	UseMissionControl bool `protobuf:"varint,9,opt,name=use_mission_control,json=useMissionControl,proto3" json:"use_mission_control,omitempty"`
	// A list of directed node pairs that will be ignored during path finding.
	IgnoredPairs []*NodePair `protobuf:"bytes,10,rep,name=ignored_pairs,json=ignoredPairs,proto3" json:"ignored_pairs,omitempty"`
	// An optional maximum total time lock for the route. If the source is empty or
	// ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
	// zero, then the value of `--max-cltv-expiry` is used as the limit.
	CltvLimit uint32 `protobuf:"varint,11,opt,name=cltv_limit,json=cltvLimit,proto3" json:"cltv_limit,omitempty"`
	// An optional field that can be used to pass an arbitrary set of TLV records
	// to a peer which understands the new records. This can be used to pass
	// application specific data during the payment attempt. If the destination
	// does not support the specified records, an error will be returned.
	// Record types are required to be in the custom range >= 65536. When using
	// REST, the values must be encoded as base64.
	DestCustomRecords map[uint64][]byte `protobuf:"bytes,13,rep,name=dest_custom_records,json=destCustomRecords,proto3" json:"dest_custom_records,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Deprecated, use outgoing_chan_ids. The channel id of the channel that must
	// be taken to the first hop. If zero, any channel may be used.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	OutgoingChanId uint64 `protobuf:"varint,14,opt,name=outgoing_chan_id,json=outgoingChanId,proto3" json:"outgoing_chan_id,omitempty"`
	// The pubkey of the last hop of the route. If empty, any hop may be used.
	LastHopPubkey []byte `protobuf:"bytes,15,opt,name=last_hop_pubkey,json=lastHopPubkey,proto3" json:"last_hop_pubkey,omitempty"`
	// Optional route hints to reach the destination through private channels.
	RouteHints []*RouteHint `protobuf:"bytes,16,rep,name=route_hints,json=routeHints,proto3" json:"route_hints,omitempty"`
	// An optional blinded path(s) to reach the destination. Note that the
	// introduction node must be provided as the first hop in the route.
	BlindedPaymentPaths []*BlindedPaymentPath `protobuf:"bytes,19,rep,name=blinded_payment_paths,json=blindedPaymentPaths,proto3" json:"blinded_payment_paths,omitempty"`
	// Features assumed to be supported by the final node. All transitive feature
	// dependencies must also be set properly. For a given feature bit pair, either
	// optional or remote may be set, but not both. If this field is nil or empty,
	// the router will try to load destination features from the graph as a
	// fallback.
	//
	// Note: must not be set if making a payment to a blinded route (features
	// are provided in blinded_payment_paths).
	DestFeatures []FeatureBit `protobuf:"varint,17,rep,packed,name=dest_features,json=destFeatures,proto3,enum=lnrpc.FeatureBit" json:"dest_features,omitempty"`
	// The time preference for this payment. Set to -1 to optimize for fees
	// only, to 1 to optimize for reliability only or a value inbetween for a mix.
	TimePref float64 `protobuf:"fixed64,18,opt,name=time_pref,json=timePref,proto3" json:"time_pref,omitempty"`
	// The channel ids of the channels allowed for the first hop. If empty, any
	// channel may be used.
	OutgoingChanIds []uint64 `protobuf:"varint,20,rep,packed,name=outgoing_chan_ids,json=outgoingChanIds,proto3" json:"outgoing_chan_ids,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *QueryRoutesRequest) Reset() {
	*x = QueryRoutesRequest{}
	mi := &file_lightning_proto_msgTypes[102]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryRoutesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryRoutesRequest) ProtoMessage() {}

func (x *QueryRoutesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[102]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryRoutesRequest.ProtoReflect.Descriptor instead.
func (*QueryRoutesRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{102}
}

func (x *QueryRoutesRequest) GetPubKey() string {
	if x != nil {
		return x.PubKey
	}
	return ""
}

func (x *QueryRoutesRequest) GetAmt() int64 {
	if x != nil {
		return x.Amt
	}
	return 0
}

func (x *QueryRoutesRequest) GetAmtMsat() int64 {
	if x != nil {
		return x.AmtMsat
	}
	return 0
}

func (x *QueryRoutesRequest) GetFinalCltvDelta() int32 {
	if x != nil {
		return x.FinalCltvDelta
	}
	return 0
}

func (x *QueryRoutesRequest) GetFeeLimit() *FeeLimit {
	if x != nil {
		return x.FeeLimit
	}
	return nil
}

func (x *QueryRoutesRequest) GetIgnoredNodes() [][]byte {
	if x != nil {
		return x.IgnoredNodes
	}
	return nil
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *QueryRoutesRequest) GetIgnoredEdges() []*EdgeLocator {
	if x != nil {
		return x.IgnoredEdges
	}
	return nil
}

func (x *QueryRoutesRequest) GetSourcePubKey() string {
	if x != nil {
		return x.SourcePubKey
	}
	return ""
}

func (x *QueryRoutesRequest) GetUseMissionControl() bool {
	if x != nil {
		return x.UseMissionControl
	}
	return false
}

func (x *QueryRoutesRequest) GetIgnoredPairs() []*NodePair {
	if x != nil {
		return x.IgnoredPairs
	}
	return nil
}

func (x *QueryRoutesRequest) GetCltvLimit() uint32 {
	if x != nil {
		return x.CltvLimit
	}
	return 0
}

func (x *QueryRoutesRequest) GetDestCustomRecords() map[uint64][]byte {
	if x != nil {
		return x.DestCustomRecords
	}
	return nil
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *QueryRoutesRequest) GetOutgoingChanId() uint64 {
	if x != nil {
		return x.OutgoingChanId
	}
	return 0
}

func (x *QueryRoutesRequest) GetLastHopPubkey() []byte {
	if x != nil {
		return x.LastHopPubkey
	}
	return nil
}

func (x *QueryRoutesRequest) GetRouteHints() []*RouteHint {
	if x != nil {
		return x.RouteHints
	}
	return nil
}

func (x *QueryRoutesRequest) GetBlindedPaymentPaths() []*BlindedPaymentPath {
	if x != nil {
		return x.BlindedPaymentPaths
	}
	return nil
}

func (x *QueryRoutesRequest) GetDestFeatures() []FeatureBit {
	if x != nil {
		return x.DestFeatures
	}
	return nil
}

func (x *QueryRoutesRequest) GetTimePref() float64 {
	if x != nil {
		return x.TimePref
	}
	return 0
}

func (x *QueryRoutesRequest) GetOutgoingChanIds() []uint64 {
	if x != nil {
		return x.OutgoingChanIds
	}
	return nil
}

type NodePair struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The sending node of the pair. When using REST, this field must be encoded as
	// base64.
	From []byte `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	// The receiving node of the pair. When using REST, this field must be encoded
	// as base64.
	To            []byte `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodePair) Reset() {
	*x = NodePair{}
	mi := &file_lightning_proto_msgTypes[103]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodePair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodePair) ProtoMessage() {}

func (x *NodePair) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[103]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodePair.ProtoReflect.Descriptor instead.
func (*NodePair) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{103}
}

func (x *NodePair) GetFrom() []byte {
	if x != nil {
		return x.From
	}
	return nil
}

func (x *NodePair) GetTo() []byte {
	if x != nil {
		return x.To
	}
	return nil
}

type EdgeLocator struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The short channel id of this edge.
	ChannelId uint64 `protobuf:"varint,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	// The direction of this edge. If direction_reverse is false, the direction
	// of this edge is from the channel endpoint with the lexicographically smaller
	// pub key to the endpoint with the larger pub key. If direction_reverse is
	// is true, the edge goes the other way.
	DirectionReverse bool `protobuf:"varint,2,opt,name=direction_reverse,json=directionReverse,proto3" json:"direction_reverse,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *EdgeLocator) Reset() {
	*x = EdgeLocator{}
	mi := &file_lightning_proto_msgTypes[104]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EdgeLocator) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EdgeLocator) ProtoMessage() {}

func (x *EdgeLocator) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[104]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EdgeLocator.ProtoReflect.Descriptor instead.
func (*EdgeLocator) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{104}
}

func (x *EdgeLocator) GetChannelId() uint64 {
	if x != nil {
		return x.ChannelId
	}
	return 0
}

func (x *EdgeLocator) GetDirectionReverse() bool {
	if x != nil {
		return x.DirectionReverse
	}
	return false
}

type QueryRoutesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The route that results from the path finding operation. This is still a
	// repeated field to retain backwards compatibility.
	Routes []*Route `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
	// The success probability of the returned route based on the current mission
	// control state. [EXPERIMENTAL]
	SuccessProb   float64 `protobuf:"fixed64,2,opt,name=success_prob,json=successProb,proto3" json:"success_prob,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryRoutesResponse) Reset() {
	*x = QueryRoutesResponse{}
	mi := &file_lightning_proto_msgTypes[105]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryRoutesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryRoutesResponse) ProtoMessage() {}

func (x *QueryRoutesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[105]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryRoutesResponse.ProtoReflect.Descriptor instead.
func (*QueryRoutesResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{105}
}

func (x *QueryRoutesResponse) GetRoutes() []*Route {
	if x != nil {
		return x.Routes
	}
	return nil
}

func (x *QueryRoutesResponse) GetSuccessProb() float64 {
	if x != nil {
		return x.SuccessProb
	}
	return 0
}

type Hop struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChanId uint64 `protobuf:"varint,1,opt,name=chan_id,json=chanId,proto3" json:"chan_id,omitempty"`
	// Deprecated: Marked as deprecated in lightning.proto.
	ChanCapacity int64 `protobuf:"varint,2,opt,name=chan_capacity,json=chanCapacity,proto3" json:"chan_capacity,omitempty"`
	// Deprecated: Marked as deprecated in lightning.proto.
	AmtToForward int64 `protobuf:"varint,3,opt,name=amt_to_forward,json=amtToForward,proto3" json:"amt_to_forward,omitempty"`
	// Deprecated: Marked as deprecated in lightning.proto.
	Fee              int64  `protobuf:"varint,4,opt,name=fee,proto3" json:"fee,omitempty"`
	Expiry           uint32 `protobuf:"varint,5,opt,name=expiry,proto3" json:"expiry,omitempty"`
	AmtToForwardMsat int64  `protobuf:"varint,6,opt,name=amt_to_forward_msat,json=amtToForwardMsat,proto3" json:"amt_to_forward_msat,omitempty"`
	FeeMsat          int64  `protobuf:"varint,7,opt,name=fee_msat,json=feeMsat,proto3" json:"fee_msat,omitempty"`
	// An optional public key of the hop. If the public key is given, the payment
	// can be executed without relying on a copy of the channel graph.
	PubKey string `protobuf:"bytes,8,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	// If set to true, then this hop will be encoded using the new variable length
	// TLV format. Note that if any custom tlv_records below are specified, then
	// this field MUST be set to true for them to be encoded properly.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	TlvPayload bool `protobuf:"varint,9,opt,name=tlv_payload,json=tlvPayload,proto3" json:"tlv_payload,omitempty"`
	// An optional TLV record that signals the use of an MPP payment. If present,
	// the receiver will enforce that the same mpp_record is included in the final
	// hop payload of all non-zero payments in the HTLC set. If empty, a regular
	// single-shot payment is or was attempted.
	MppRecord *MPPRecord `protobuf:"bytes,10,opt,name=mpp_record,json=mppRecord,proto3" json:"mpp_record,omitempty"`
	// An optional TLV record that signals the use of an AMP payment. If present,
	// the receiver will treat all received payments including the same
	// (payment_addr, set_id) pair  as being part of one logical payment. The
	// payment will be settled by XORing the root_share's together and deriving the
	// child hashes and preimages according to BOLT XX. Must be used in conjunction
	// with mpp_record.
	AmpRecord *AMPRecord `protobuf:"bytes,12,opt,name=amp_record,json=ampRecord,proto3" json:"amp_record,omitempty"`
	// An optional set of key-value TLV records. This is useful within the context
	// of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
	// to drop off at each hop within the onion.
	CustomRecords map[uint64][]byte `protobuf:"bytes,11,rep,name=custom_records,json=customRecords,proto3" json:"custom_records,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The payment metadata to send along with the payment to the payee.
	Metadata []byte `protobuf:"bytes,13,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Blinding point is an optional blinding point included for introduction
	// nodes in blinded paths. This field is mandatory for hops that represents
	// the introduction point in a blinded path.
	BlindingPoint []byte `protobuf:"bytes,14,opt,name=blinding_point,json=blindingPoint,proto3" json:"blinding_point,omitempty"`
	// Encrypted data is a receiver-produced blob of data that provides hops
	// in a blinded route with forwarding data. As this data is encrypted by
	// the recipient, we will not be able to parse it - it is essentially an
	// arbitrary blob of data from our node's perspective. This field is
	// mandatory for all hops in a blinded path, including the introduction
	// node.
	EncryptedData []byte `protobuf:"bytes,15,opt,name=encrypted_data,json=encryptedData,proto3" json:"encrypted_data,omitempty"`
	// The total amount that is sent to the recipient (possibly across multiple
	// HTLCs), as specified by the sender when making a payment to a blinded path.
	// This value is only set in the final hop payload of a blinded payment. This
	// value is analogous to the MPPRecord that is used for regular (non-blinded)
	// MPP payments.
	TotalAmtMsat  uint64 `protobuf:"varint,16,opt,name=total_amt_msat,json=totalAmtMsat,proto3" json:"total_amt_msat,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Hop) Reset() {
	*x = Hop{}
	mi := &file_lightning_proto_msgTypes[106]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Hop) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Hop) ProtoMessage() {}

func (x *Hop) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[106]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Hop.ProtoReflect.Descriptor instead.
func (*Hop) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{106}
}

func (x *Hop) GetChanId() uint64 {
	if x != nil {
		return x.ChanId
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *Hop) GetChanCapacity() int64 {
	if x != nil {
		return x.ChanCapacity
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *Hop) GetAmtToForward() int64 {
	if x != nil {
		return x.AmtToForward
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *Hop) GetFee() int64 {
	if x != nil {
		return x.Fee
	}
	return 0
}

func (x *Hop) GetExpiry() uint32 {
	if x != nil {
		return x.Expiry
	}
	return 0
}

func (x *Hop) GetAmtToForwardMsat() int64 {
	if x != nil {
		return x.AmtToForwardMsat
	}
	return 0
}

func (x *Hop) GetFeeMsat() int64 {
	if x != nil {
		return x.FeeMsat
	}
	return 0
}

func (x *Hop) GetPubKey() string {
	if x != nil {
		return x.PubKey
	}
	return ""
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *Hop) GetTlvPayload() bool {
	if x != nil {
		return x.TlvPayload
	}
	return false
}

func (x *Hop) GetMppRecord() *MPPRecord {
	if x != nil {
		return x.MppRecord
	}
	return nil
}

func (x *Hop) GetAmpRecord() *AMPRecord {
	if x != nil {
		return x.AmpRecord
	}
	return nil
}

func (x *Hop) GetCustomRecords() map[uint64][]byte {
	if x != nil {
		return x.CustomRecords
	}
	return nil
}

func (x *Hop) GetMetadata() []byte {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *Hop) GetBlindingPoint() []byte {
	if x != nil {
		return x.BlindingPoint
	}
	return nil
}

func (x *Hop) GetEncryptedData() []byte {
	if x != nil {
		return x.EncryptedData
	}
	return nil
}

func (x *Hop) GetTotalAmtMsat() uint64 {
	if x != nil {
		return x.TotalAmtMsat
	}
	return 0
}

type MPPRecord struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A unique, random identifier used to authenticate the sender as the intended
	// payer of a multi-path payment. The payment_addr must be the same for all
	// subpayments, and match the payment_addr provided in the receiver's invoice.
	// The same payment_addr must be used on all subpayments. This is also called
	// payment secret in specifications (e.g. BOLT 11).
	PaymentAddr []byte `protobuf:"bytes,11,opt,name=payment_addr,json=paymentAddr,proto3" json:"payment_addr,omitempty"`
	// The total amount in milli-satoshis being sent as part of a larger multi-path
	// payment. The caller is responsible for ensuring subpayments to the same node
	// and payment_hash sum exactly to total_amt_msat. The same
	// total_amt_msat must be used on all subpayments.
	TotalAmtMsat  int64 `protobuf:"varint,10,opt,name=total_amt_msat,json=totalAmtMsat,proto3" json:"total_amt_msat,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MPPRecord) Reset() {
	*x = MPPRecord{}
	mi := &file_lightning_proto_msgTypes[107]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MPPRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MPPRecord) ProtoMessage() {}

func (x *MPPRecord) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[107]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MPPRecord.ProtoReflect.Descriptor instead.
func (*MPPRecord) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{107}
}

func (x *MPPRecord) GetPaymentAddr() []byte {
	if x != nil {
		return x.PaymentAddr
	}
	return nil
}

func (x *MPPRecord) GetTotalAmtMsat() int64 {
	if x != nil {
		return x.TotalAmtMsat
	}
	return 0
}

type AMPRecord struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RootShare     []byte                 `protobuf:"bytes,1,opt,name=root_share,json=rootShare,proto3" json:"root_share,omitempty"`
	SetId         []byte                 `protobuf:"bytes,2,opt,name=set_id,json=setId,proto3" json:"set_id,omitempty"`
	ChildIndex    uint32                 `protobuf:"varint,3,opt,name=child_index,json=childIndex,proto3" json:"child_index,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AMPRecord) Reset() {
	*x = AMPRecord{}
	mi := &file_lightning_proto_msgTypes[108]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AMPRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AMPRecord) ProtoMessage() {}

func (x *AMPRecord) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[108]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AMPRecord.ProtoReflect.Descriptor instead.
func (*AMPRecord) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{108}
}

func (x *AMPRecord) GetRootShare() []byte {
	if x != nil {
		return x.RootShare
	}
	return nil
}

func (x *AMPRecord) GetSetId() []byte {
	if x != nil {
		return x.SetId
	}
	return nil
}

func (x *AMPRecord) GetChildIndex() uint32 {
	if x != nil {
		return x.ChildIndex
	}
	return 0
}

// A path through the channel graph which runs over one or more channels in
// succession. This struct carries all the information required to craft the
// Sphinx onion packet, and send the payment along the first hop in the path. A
// route is only selected as valid if all the channels have sufficient capacity to
// carry the initial payment amount after fees are accounted for.
type Route struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The cumulative (final) time lock across the entire route. This is the CLTV
	// value that should be extended to the first hop in the route. All other hops
	// will decrement the time-lock as advertised, leaving enough time for all
	// hops to wait for or present the payment preimage to complete the payment.
	TotalTimeLock uint32 `protobuf:"varint,1,opt,name=total_time_lock,json=totalTimeLock,proto3" json:"total_time_lock,omitempty"`
	// The sum of the fees paid at each hop within the final route. In the case
	// of a one-hop payment, this value will be zero as we don't need to pay a fee
	// to ourselves.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	TotalFees int64 `protobuf:"varint,2,opt,name=total_fees,json=totalFees,proto3" json:"total_fees,omitempty"`
	// The total amount of funds required to complete a payment over this route.
	// This value includes the cumulative fees at each hop. As a result, the HTLC
	// extended to the first-hop in the route will need to have at least this many
	// satoshis, otherwise the route will fail at an intermediate node due to an
	// insufficient amount of fees.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	TotalAmt int64 `protobuf:"varint,3,opt,name=total_amt,json=totalAmt,proto3" json:"total_amt,omitempty"`
	// Contains details concerning the specific forwarding details at each hop.
	Hops []*Hop `protobuf:"bytes,4,rep,name=hops,proto3" json:"hops,omitempty"`
	// The total fees in millisatoshis.
	TotalFeesMsat int64 `protobuf:"varint,5,opt,name=total_fees_msat,json=totalFeesMsat,proto3" json:"total_fees_msat,omitempty"`
	// The total amount in millisatoshis.
	TotalAmtMsat int64 `protobuf:"varint,6,opt,name=total_amt_msat,json=totalAmtMsat,proto3" json:"total_amt_msat,omitempty"`
	// The actual on-chain amount that was sent out to the first hop. This value is
	// only different from the total_amt_msat field if this is a custom channel
	// payment and the value transported in the HTLC is different from the BTC
	// amount in the HTLC. If this value is zero, then this is an old payment that
	// didn't have this value yet and can be ignored.
	FirstHopAmountMsat int64 `protobuf:"varint,7,opt,name=first_hop_amount_msat,json=firstHopAmountMsat,proto3" json:"first_hop_amount_msat,omitempty"`
	// Custom channel data that might be populated in custom channels.
	CustomChannelData []byte `protobuf:"bytes,8,opt,name=custom_channel_data,json=customChannelData,proto3" json:"custom_channel_data,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *Route) Reset() {
	*x = Route{}
	mi := &file_lightning_proto_msgTypes[109]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Route) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Route) ProtoMessage() {}

func (x *Route) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[109]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Route.ProtoReflect.Descriptor instead.
func (*Route) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{109}
}

func (x *Route) GetTotalTimeLock() uint32 {
	if x != nil {
		return x.TotalTimeLock
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *Route) GetTotalFees() int64 {
	if x != nil {
		return x.TotalFees
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *Route) GetTotalAmt() int64 {
	if x != nil {
		return x.TotalAmt
	}
	return 0
}

func (x *Route) GetHops() []*Hop {
	if x != nil {
		return x.Hops
	}
	return nil
}

func (x *Route) GetTotalFeesMsat() int64 {
	if x != nil {
		return x.TotalFeesMsat
	}
	return 0
}

func (x *Route) GetTotalAmtMsat() int64 {
	if x != nil {
		return x.TotalAmtMsat
	}
	return 0
}

func (x *Route) GetFirstHopAmountMsat() int64 {
	if x != nil {
		return x.FirstHopAmountMsat
	}
	return 0
}

func (x *Route) GetCustomChannelData() []byte {
	if x != nil {
		return x.CustomChannelData
	}
	return nil
}

type NodeInfoRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The 33-byte hex-encoded compressed public of the target node
	PubKey string `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	// If true, will include all known channels associated with the node.
	IncludeChannels bool `protobuf:"varint,2,opt,name=include_channels,json=includeChannels,proto3" json:"include_channels,omitempty"`
	// If true, will include announcements' signatures into ChannelEdge.
	// Depends on include_channels.
	IncludeAuthProof bool `protobuf:"varint,3,opt,name=include_auth_proof,json=includeAuthProof,proto3" json:"include_auth_proof,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *NodeInfoRequest) Reset() {
	*x = NodeInfoRequest{}
	mi := &file_lightning_proto_msgTypes[110]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeInfoRequest) ProtoMessage() {}

func (x *NodeInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[110]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeInfoRequest.ProtoReflect.Descriptor instead.
func (*NodeInfoRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{110}
}

func (x *NodeInfoRequest) GetPubKey() string {
	if x != nil {
		return x.PubKey
	}
	return ""
}

func (x *NodeInfoRequest) GetIncludeChannels() bool {
	if x != nil {
		return x.IncludeChannels
	}
	return false
}

func (x *NodeInfoRequest) GetIncludeAuthProof() bool {
	if x != nil {
		return x.IncludeAuthProof
	}
	return false
}

type NodeInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// An individual vertex/node within the channel graph. A node is
	// connected to other nodes by one or more channel edges emanating from it. As
	// the graph is directed, a node will also have an incoming edge attached to
	// it for each outgoing edge.
	Node *LightningNode `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
	// The total number of channels for the node.
	NumChannels uint32 `protobuf:"varint,2,opt,name=num_channels,json=numChannels,proto3" json:"num_channels,omitempty"`
	// The sum of all channels capacity for the node, denominated in satoshis.
	TotalCapacity int64 `protobuf:"varint,3,opt,name=total_capacity,json=totalCapacity,proto3" json:"total_capacity,omitempty"`
	// A list of all public channels for the node.
	Channels      []*ChannelEdge `protobuf:"bytes,4,rep,name=channels,proto3" json:"channels,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeInfo) Reset() {
	*x = NodeInfo{}
	mi := &file_lightning_proto_msgTypes[111]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeInfo) ProtoMessage() {}

func (x *NodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[111]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeInfo.ProtoReflect.Descriptor instead.
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{111}
}

func (x *NodeInfo) GetNode() *LightningNode {
	if x != nil {
		return x.Node
	}
	return nil
}

func (x *NodeInfo) GetNumChannels() uint32 {
	if x != nil {
		return x.NumChannels
	}
	return 0
}

func (x *NodeInfo) GetTotalCapacity() int64 {
	if x != nil {
		return x.TotalCapacity
	}
	return 0
}

func (x *NodeInfo) GetChannels() []*ChannelEdge {
	if x != nil {
		return x.Channels
	}
	return nil
}

// An individual vertex/node within the channel graph. A node is
// connected to other nodes by one or more channel edges emanating from it. As the
// graph is directed, a node will also have an incoming edge attached to it for
// each outgoing edge.
type LightningNode struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	LastUpdate uint32                 `protobuf:"varint,1,opt,name=last_update,json=lastUpdate,proto3" json:"last_update,omitempty"`
	PubKey     string                 `protobuf:"bytes,2,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	Alias      string                 `protobuf:"bytes,3,opt,name=alias,proto3" json:"alias,omitempty"`
	Addresses  []*NodeAddress         `protobuf:"bytes,4,rep,name=addresses,proto3" json:"addresses,omitempty"`
	Color      string                 `protobuf:"bytes,5,opt,name=color,proto3" json:"color,omitempty"`
	Features   map[uint32]*Feature    `protobuf:"bytes,6,rep,name=features,proto3" json:"features,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Custom node announcement tlv records.
	CustomRecords map[uint64][]byte `protobuf:"bytes,7,rep,name=custom_records,json=customRecords,proto3" json:"custom_records,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LightningNode) Reset() {
	*x = LightningNode{}
	mi := &file_lightning_proto_msgTypes[112]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LightningNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LightningNode) ProtoMessage() {}

func (x *LightningNode) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[112]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LightningNode.ProtoReflect.Descriptor instead.
func (*LightningNode) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{112}
}

func (x *LightningNode) GetLastUpdate() uint32 {
	if x != nil {
		return x.LastUpdate
	}
	return 0
}

func (x *LightningNode) GetPubKey() string {
	if x != nil {
		return x.PubKey
	}
	return ""
}

func (x *LightningNode) GetAlias() string {
	if x != nil {
		return x.Alias
	}
	return ""
}

func (x *LightningNode) GetAddresses() []*NodeAddress {
	if x != nil {
		return x.Addresses
	}
	return nil
}

func (x *LightningNode) GetColor() string {
	if x != nil {
		return x.Color
	}
	return ""
}

func (x *LightningNode) GetFeatures() map[uint32]*Feature {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *LightningNode) GetCustomRecords() map[uint64][]byte {
	if x != nil {
		return x.CustomRecords
	}
	return nil
}

type NodeAddress struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Network       string                 `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Addr          string                 `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeAddress) Reset() {
	*x = NodeAddress{}
	mi := &file_lightning_proto_msgTypes[113]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeAddress) ProtoMessage() {}

func (x *NodeAddress) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[113]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeAddress.ProtoReflect.Descriptor instead.
func (*NodeAddress) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{113}
}

func (x *NodeAddress) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *NodeAddress) GetAddr() string {
	if x != nil {
		return x.Addr
	}
	return ""
}

type RoutingPolicy struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	TimeLockDelta    uint32                 `protobuf:"varint,1,opt,name=time_lock_delta,json=timeLockDelta,proto3" json:"time_lock_delta,omitempty"`
	MinHtlc          int64                  `protobuf:"varint,2,opt,name=min_htlc,json=minHtlc,proto3" json:"min_htlc,omitempty"`
	FeeBaseMsat      int64                  `protobuf:"varint,3,opt,name=fee_base_msat,json=feeBaseMsat,proto3" json:"fee_base_msat,omitempty"`
	FeeRateMilliMsat int64                  `protobuf:"varint,4,opt,name=fee_rate_milli_msat,json=feeRateMilliMsat,proto3" json:"fee_rate_milli_msat,omitempty"`
	Disabled         bool                   `protobuf:"varint,5,opt,name=disabled,proto3" json:"disabled,omitempty"`
	MaxHtlcMsat      uint64                 `protobuf:"varint,6,opt,name=max_htlc_msat,json=maxHtlcMsat,proto3" json:"max_htlc_msat,omitempty"`
	LastUpdate       uint32                 `protobuf:"varint,7,opt,name=last_update,json=lastUpdate,proto3" json:"last_update,omitempty"`
	// Custom channel update tlv records. These are customized fields that are
	// not defined by LND and cannot be extracted.
	CustomRecords           map[uint64][]byte `protobuf:"bytes,8,rep,name=custom_records,json=customRecords,proto3" json:"custom_records,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	InboundFeeBaseMsat      int32             `protobuf:"varint,9,opt,name=inbound_fee_base_msat,json=inboundFeeBaseMsat,proto3" json:"inbound_fee_base_msat,omitempty"`
	InboundFeeRateMilliMsat int32             `protobuf:"varint,10,opt,name=inbound_fee_rate_milli_msat,json=inboundFeeRateMilliMsat,proto3" json:"inbound_fee_rate_milli_msat,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *RoutingPolicy) Reset() {
	*x = RoutingPolicy{}
	mi := &file_lightning_proto_msgTypes[114]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RoutingPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RoutingPolicy) ProtoMessage() {}

func (x *RoutingPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[114]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RoutingPolicy.ProtoReflect.Descriptor instead.
func (*RoutingPolicy) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{114}
}

func (x *RoutingPolicy) GetTimeLockDelta() uint32 {
	if x != nil {
		return x.TimeLockDelta
	}
	return 0
}

func (x *RoutingPolicy) GetMinHtlc() int64 {
	if x != nil {
		return x.MinHtlc
	}
	return 0
}

func (x *RoutingPolicy) GetFeeBaseMsat() int64 {
	if x != nil {
		return x.FeeBaseMsat
	}
	return 0
}

func (x *RoutingPolicy) GetFeeRateMilliMsat() int64 {
	if x != nil {
		return x.FeeRateMilliMsat
	}
	return 0
}

func (x *RoutingPolicy) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

func (x *RoutingPolicy) GetMaxHtlcMsat() uint64 {
	if x != nil {
		return x.MaxHtlcMsat
	}
	return 0
}

func (x *RoutingPolicy) GetLastUpdate() uint32 {
	if x != nil {
		return x.LastUpdate
	}
	return 0
}

func (x *RoutingPolicy) GetCustomRecords() map[uint64][]byte {
	if x != nil {
		return x.CustomRecords
	}
	return nil
}

func (x *RoutingPolicy) GetInboundFeeBaseMsat() int32 {
	if x != nil {
		return x.InboundFeeBaseMsat
	}
	return 0
}

func (x *RoutingPolicy) GetInboundFeeRateMilliMsat() int32 {
	if x != nil {
		return x.InboundFeeRateMilliMsat
	}
	return 0
}

// ChannelAuthProof is the authentication proof (the signature portion) for a
// channel. Using the four signatures contained in the struct, and some
// auxiliary knowledge (the funding script, node identities, and outpoint) nodes
// on the network are able to validate the authenticity and existence of a
// channel.
type ChannelAuthProof struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// node_sig1 are the raw bytes of the first node signature encoded
	// in DER format.
	NodeSig1 []byte `protobuf:"bytes,1,opt,name=node_sig1,json=nodeSig1,proto3" json:"node_sig1,omitempty"`
	// bitcoin_sig1 are the raw bytes of the first bitcoin signature of the
	// MultiSigKey key of the channel encoded in DER format.
	BitcoinSig1 []byte `protobuf:"bytes,2,opt,name=bitcoin_sig1,json=bitcoinSig1,proto3" json:"bitcoin_sig1,omitempty"`
	// node_sig2 are the raw bytes of the second node signature encoded
	// in DER format.
	NodeSig2 []byte `protobuf:"bytes,3,opt,name=node_sig2,json=nodeSig2,proto3" json:"node_sig2,omitempty"`
	// bitcoin_sig2 are the raw bytes of the second bitcoin signature of the
	// MultiSigKey key of the channel encoded in DER format.
	BitcoinSig2   []byte `protobuf:"bytes,4,opt,name=bitcoin_sig2,json=bitcoinSig2,proto3" json:"bitcoin_sig2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChannelAuthProof) Reset() {
	*x = ChannelAuthProof{}
	mi := &file_lightning_proto_msgTypes[115]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelAuthProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelAuthProof) ProtoMessage() {}

func (x *ChannelAuthProof) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[115]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelAuthProof.ProtoReflect.Descriptor instead.
func (*ChannelAuthProof) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{115}
}

func (x *ChannelAuthProof) GetNodeSig1() []byte {
	if x != nil {
		return x.NodeSig1
	}
	return nil
}

func (x *ChannelAuthProof) GetBitcoinSig1() []byte {
	if x != nil {
		return x.BitcoinSig1
	}
	return nil
}

func (x *ChannelAuthProof) GetNodeSig2() []byte {
	if x != nil {
		return x.NodeSig2
	}
	return nil
}

func (x *ChannelAuthProof) GetBitcoinSig2() []byte {
	if x != nil {
		return x.BitcoinSig2
	}
	return nil
}

// A fully authenticated channel along with all its unique attributes.
// Once an authenticated channel announcement has been processed on the network,
// then an instance of ChannelEdgeInfo encapsulating the channels attributes is
// stored. The other portions relevant to routing policy of a channel are stored
// within a ChannelEdgePolicy for each direction of the channel.
type ChannelEdge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChannelId uint64 `protobuf:"varint,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	ChanPoint string `protobuf:"bytes,2,opt,name=chan_point,json=chanPoint,proto3" json:"chan_point,omitempty"`
	// Deprecated: Marked as deprecated in lightning.proto.
	LastUpdate  uint32         `protobuf:"varint,3,opt,name=last_update,json=lastUpdate,proto3" json:"last_update,omitempty"`
	Node1Pub    string         `protobuf:"bytes,4,opt,name=node1_pub,json=node1Pub,proto3" json:"node1_pub,omitempty"`
	Node2Pub    string         `protobuf:"bytes,5,opt,name=node2_pub,json=node2Pub,proto3" json:"node2_pub,omitempty"`
	Capacity    int64          `protobuf:"varint,6,opt,name=capacity,proto3" json:"capacity,omitempty"`
	Node1Policy *RoutingPolicy `protobuf:"bytes,7,opt,name=node1_policy,json=node1Policy,proto3" json:"node1_policy,omitempty"`
	Node2Policy *RoutingPolicy `protobuf:"bytes,8,opt,name=node2_policy,json=node2Policy,proto3" json:"node2_policy,omitempty"`
	// Custom channel announcement tlv records.
	CustomRecords map[uint64][]byte `protobuf:"bytes,9,rep,name=custom_records,json=customRecords,proto3" json:"custom_records,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Authentication proof for this channel. This proof contains a set of
	// signatures binding four identities, which attests to the legitimacy of
	// the advertised channel. This only is available for advertised channels.
	// This field is not filled by default. Pass include_auth_proof flag to
	// DescribeGraph, GetNodeInfo or GetChanInfo to get this data.
	AuthProof     *ChannelAuthProof `protobuf:"bytes,10,opt,name=auth_proof,json=authProof,proto3" json:"auth_proof,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChannelEdge) Reset() {
	*x = ChannelEdge{}
	mi := &file_lightning_proto_msgTypes[116]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelEdge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelEdge) ProtoMessage() {}

func (x *ChannelEdge) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[116]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelEdge.ProtoReflect.Descriptor instead.
func (*ChannelEdge) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{116}
}

func (x *ChannelEdge) GetChannelId() uint64 {
	if x != nil {
		return x.ChannelId
	}
	return 0
}

func (x *ChannelEdge) GetChanPoint() string {
	if x != nil {
		return x.ChanPoint
	}
	return ""
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *ChannelEdge) GetLastUpdate() uint32 {
	if x != nil {
		return x.LastUpdate
	}
	return 0
}

func (x *ChannelEdge) GetNode1Pub() string {
	if x != nil {
		return x.Node1Pub
	}
	return ""
}

func (x *ChannelEdge) GetNode2Pub() string {
	if x != nil {
		return x.Node2Pub
	}
	return ""
}

func (x *ChannelEdge) GetCapacity() int64 {
	if x != nil {
		return x.Capacity
	}
	return 0
}

func (x *ChannelEdge) GetNode1Policy() *RoutingPolicy {
	if x != nil {
		return x.Node1Policy
	}
	return nil
}

func (x *ChannelEdge) GetNode2Policy() *RoutingPolicy {
	if x != nil {
		return x.Node2Policy
	}
	return nil
}

func (x *ChannelEdge) GetCustomRecords() map[uint64][]byte {
	if x != nil {
		return x.CustomRecords
	}
	return nil
}

func (x *ChannelEdge) GetAuthProof() *ChannelAuthProof {
	if x != nil {
		return x.AuthProof
	}
	return nil
}

type ChannelGraphRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether unannounced channels are included in the response or not. If set,
	// unannounced channels are included. Unannounced channels are both private
	// channels, and public channels that are not yet announced to the network.
	IncludeUnannounced bool `protobuf:"varint,1,opt,name=include_unannounced,json=includeUnannounced,proto3" json:"include_unannounced,omitempty"`
	// If true, will include announcements' signatures into ChannelEdge.
	IncludeAuthProof bool `protobuf:"varint,2,opt,name=include_auth_proof,json=includeAuthProof,proto3" json:"include_auth_proof,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ChannelGraphRequest) Reset() {
	*x = ChannelGraphRequest{}
	mi := &file_lightning_proto_msgTypes[117]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelGraphRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelGraphRequest) ProtoMessage() {}

func (x *ChannelGraphRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[117]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelGraphRequest.ProtoReflect.Descriptor instead.
func (*ChannelGraphRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{117}
}

func (x *ChannelGraphRequest) GetIncludeUnannounced() bool {
	if x != nil {
		return x.IncludeUnannounced
	}
	return false
}

func (x *ChannelGraphRequest) GetIncludeAuthProof() bool {
	if x != nil {
		return x.IncludeAuthProof
	}
	return false
}

// Returns a new instance of the directed channel graph.
type ChannelGraph struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The list of `LightningNode`s in this channel graph
	Nodes []*LightningNode `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// The list of `ChannelEdge`s in this channel graph
	Edges         []*ChannelEdge `protobuf:"bytes,2,rep,name=edges,proto3" json:"edges,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChannelGraph) Reset() {
	*x = ChannelGraph{}
	mi := &file_lightning_proto_msgTypes[118]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelGraph) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelGraph) ProtoMessage() {}

func (x *ChannelGraph) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[118]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelGraph.ProtoReflect.Descriptor instead.
func (*ChannelGraph) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{118}
}

func (x *ChannelGraph) GetNodes() []*LightningNode {
	if x != nil {
		return x.Nodes
	}
	return nil
}

func (x *ChannelGraph) GetEdges() []*ChannelEdge {
	if x != nil {
		return x.Edges
	}
	return nil
}

type NodeMetricsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The requested node metrics.
	Types         []NodeMetricType `protobuf:"varint,1,rep,packed,name=types,proto3,enum=lnrpc.NodeMetricType" json:"types,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeMetricsRequest) Reset() {
	*x = NodeMetricsRequest{}
	mi := &file_lightning_proto_msgTypes[119]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeMetricsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeMetricsRequest) ProtoMessage() {}

func (x *NodeMetricsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[119]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeMetricsRequest.ProtoReflect.Descriptor instead.
func (*NodeMetricsRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{119}
}

func (x *NodeMetricsRequest) GetTypes() []NodeMetricType {
	if x != nil {
		return x.Types
	}
	return nil
}

type NodeMetricsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Betweenness centrality is the sum of the ratio of shortest paths that pass
	// through the node for each pair of nodes in the graph (not counting paths
	// starting or ending at this node).
	// Map of node pubkey to betweenness centrality of the node. Normalized
	// values are in the [0,1] closed interval.
	BetweennessCentrality map[string]*FloatMetric `protobuf:"bytes,1,rep,name=betweenness_centrality,json=betweennessCentrality,proto3" json:"betweenness_centrality,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *NodeMetricsResponse) Reset() {
	*x = NodeMetricsResponse{}
	mi := &file_lightning_proto_msgTypes[120]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeMetricsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeMetricsResponse) ProtoMessage() {}

func (x *NodeMetricsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[120]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeMetricsResponse.ProtoReflect.Descriptor instead.
func (*NodeMetricsResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{120}
}

func (x *NodeMetricsResponse) GetBetweennessCentrality() map[string]*FloatMetric {
	if x != nil {
		return x.BetweennessCentrality
	}
	return nil
}

type FloatMetric struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Arbitrary float value.
	Value float64 `protobuf:"fixed64,1,opt,name=value,proto3" json:"value,omitempty"`
	// The value normalized to [0,1] or [-1,1].
	NormalizedValue float64 `protobuf:"fixed64,2,opt,name=normalized_value,json=normalizedValue,proto3" json:"normalized_value,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *FloatMetric) Reset() {
	*x = FloatMetric{}
	mi := &file_lightning_proto_msgTypes[121]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FloatMetric) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FloatMetric) ProtoMessage() {}

func (x *FloatMetric) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[121]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FloatMetric.ProtoReflect.Descriptor instead.
func (*FloatMetric) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{121}
}

func (x *FloatMetric) GetValue() float64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *FloatMetric) GetNormalizedValue() float64 {
	if x != nil {
		return x.NormalizedValue
	}
	return 0
}

type ChanInfoRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChanId uint64 `protobuf:"varint,1,opt,name=chan_id,json=chanId,proto3" json:"chan_id,omitempty"`
	// The channel point of the channel in format funding_txid:output_index. If
	// chan_id is specified, this field is ignored.
	ChanPoint string `protobuf:"bytes,2,opt,name=chan_point,json=chanPoint,proto3" json:"chan_point,omitempty"`
	// If true, will include announcements' signatures into ChannelEdge.
	IncludeAuthProof bool `protobuf:"varint,3,opt,name=include_auth_proof,json=includeAuthProof,proto3" json:"include_auth_proof,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ChanInfoRequest) Reset() {
	*x = ChanInfoRequest{}
	mi := &file_lightning_proto_msgTypes[122]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChanInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChanInfoRequest) ProtoMessage() {}

func (x *ChanInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[122]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChanInfoRequest.ProtoReflect.Descriptor instead.
func (*ChanInfoRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{122}
}

func (x *ChanInfoRequest) GetChanId() uint64 {
	if x != nil {
		return x.ChanId
	}
	return 0
}

func (x *ChanInfoRequest) GetChanPoint() string {
	if x != nil {
		return x.ChanPoint
	}
	return ""
}

func (x *ChanInfoRequest) GetIncludeAuthProof() bool {
	if x != nil {
		return x.IncludeAuthProof
	}
	return false
}

type NetworkInfoRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkInfoRequest) Reset() {
	*x = NetworkInfoRequest{}
	mi := &file_lightning_proto_msgTypes[123]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkInfoRequest) ProtoMessage() {}

func (x *NetworkInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[123]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkInfoRequest.ProtoReflect.Descriptor instead.
func (*NetworkInfoRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{123}
}

type NetworkInfo struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	GraphDiameter        uint32                 `protobuf:"varint,1,opt,name=graph_diameter,json=graphDiameter,proto3" json:"graph_diameter,omitempty"`
	AvgOutDegree         float64                `protobuf:"fixed64,2,opt,name=avg_out_degree,json=avgOutDegree,proto3" json:"avg_out_degree,omitempty"`
	MaxOutDegree         uint32                 `protobuf:"varint,3,opt,name=max_out_degree,json=maxOutDegree,proto3" json:"max_out_degree,omitempty"`
	NumNodes             uint32                 `protobuf:"varint,4,opt,name=num_nodes,json=numNodes,proto3" json:"num_nodes,omitempty"`
	NumChannels          uint32                 `protobuf:"varint,5,opt,name=num_channels,json=numChannels,proto3" json:"num_channels,omitempty"`
	TotalNetworkCapacity int64                  `protobuf:"varint,6,opt,name=total_network_capacity,json=totalNetworkCapacity,proto3" json:"total_network_capacity,omitempty"`
	AvgChannelSize       float64                `protobuf:"fixed64,7,opt,name=avg_channel_size,json=avgChannelSize,proto3" json:"avg_channel_size,omitempty"`
	MinChannelSize       int64                  `protobuf:"varint,8,opt,name=min_channel_size,json=minChannelSize,proto3" json:"min_channel_size,omitempty"`
	MaxChannelSize       int64                  `protobuf:"varint,9,opt,name=max_channel_size,json=maxChannelSize,proto3" json:"max_channel_size,omitempty"`
	MedianChannelSizeSat int64                  `protobuf:"varint,10,opt,name=median_channel_size_sat,json=medianChannelSizeSat,proto3" json:"median_channel_size_sat,omitempty"`
	// The number of edges marked as zombies.
	NumZombieChans uint64 `protobuf:"varint,11,opt,name=num_zombie_chans,json=numZombieChans,proto3" json:"num_zombie_chans,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *NetworkInfo) Reset() {
	*x = NetworkInfo{}
	mi := &file_lightning_proto_msgTypes[124]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkInfo) ProtoMessage() {}

func (x *NetworkInfo) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[124]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkInfo.ProtoReflect.Descriptor instead.
func (*NetworkInfo) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{124}
}

func (x *NetworkInfo) GetGraphDiameter() uint32 {
	if x != nil {
		return x.GraphDiameter
	}
	return 0
}

func (x *NetworkInfo) GetAvgOutDegree() float64 {
	if x != nil {
		return x.AvgOutDegree
	}
	return 0
}

func (x *NetworkInfo) GetMaxOutDegree() uint32 {
	if x != nil {
		return x.MaxOutDegree
	}
	return 0
}

func (x *NetworkInfo) GetNumNodes() uint32 {
	if x != nil {
		return x.NumNodes
	}
	return 0
}

func (x *NetworkInfo) GetNumChannels() uint32 {
	if x != nil {
		return x.NumChannels
	}
	return 0
}

func (x *NetworkInfo) GetTotalNetworkCapacity() int64 {
	if x != nil {
		return x.TotalNetworkCapacity
	}
	return 0
}

func (x *NetworkInfo) GetAvgChannelSize() float64 {
	if x != nil {
		return x.AvgChannelSize
	}
	return 0
}

func (x *NetworkInfo) GetMinChannelSize() int64 {
	if x != nil {
		return x.MinChannelSize
	}
	return 0
}

func (x *NetworkInfo) GetMaxChannelSize() int64 {
	if x != nil {
		return x.MaxChannelSize
	}
	return 0
}

func (x *NetworkInfo) GetMedianChannelSizeSat() int64 {
	if x != nil {
		return x.MedianChannelSizeSat
	}
	return 0
}

func (x *NetworkInfo) GetNumZombieChans() uint64 {
	if x != nil {
		return x.NumZombieChans
	}
	return 0
}

type StopRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopRequest) Reset() {
	*x = StopRequest{}
	mi := &file_lightning_proto_msgTypes[125]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopRequest) ProtoMessage() {}

func (x *StopRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[125]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopRequest.ProtoReflect.Descriptor instead.
func (*StopRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{125}
}

type StopResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The status of the stop operation.
	Status        string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopResponse) Reset() {
	*x = StopResponse{}
	mi := &file_lightning_proto_msgTypes[126]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopResponse) ProtoMessage() {}

func (x *StopResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[126]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopResponse.ProtoReflect.Descriptor instead.
func (*StopResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{126}
}

func (x *StopResponse) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

type GraphTopologySubscription struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GraphTopologySubscription) Reset() {
	*x = GraphTopologySubscription{}
	mi := &file_lightning_proto_msgTypes[127]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GraphTopologySubscription) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GraphTopologySubscription) ProtoMessage() {}

func (x *GraphTopologySubscription) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[127]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GraphTopologySubscription.ProtoReflect.Descriptor instead.
func (*GraphTopologySubscription) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{127}
}

type GraphTopologyUpdate struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	NodeUpdates    []*NodeUpdate          `protobuf:"bytes,1,rep,name=node_updates,json=nodeUpdates,proto3" json:"node_updates,omitempty"`
	ChannelUpdates []*ChannelEdgeUpdate   `protobuf:"bytes,2,rep,name=channel_updates,json=channelUpdates,proto3" json:"channel_updates,omitempty"`
	ClosedChans    []*ClosedChannelUpdate `protobuf:"bytes,3,rep,name=closed_chans,json=closedChans,proto3" json:"closed_chans,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *GraphTopologyUpdate) Reset() {
	*x = GraphTopologyUpdate{}
	mi := &file_lightning_proto_msgTypes[128]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GraphTopologyUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GraphTopologyUpdate) ProtoMessage() {}

func (x *GraphTopologyUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[128]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GraphTopologyUpdate.ProtoReflect.Descriptor instead.
func (*GraphTopologyUpdate) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{128}
}

func (x *GraphTopologyUpdate) GetNodeUpdates() []*NodeUpdate {
	if x != nil {
		return x.NodeUpdates
	}
	return nil
}

func (x *GraphTopologyUpdate) GetChannelUpdates() []*ChannelEdgeUpdate {
	if x != nil {
		return x.ChannelUpdates
	}
	return nil
}

func (x *GraphTopologyUpdate) GetClosedChans() []*ClosedChannelUpdate {
	if x != nil {
		return x.ClosedChans
	}
	return nil
}

type NodeUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Deprecated, use node_addresses.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	Addresses   []string `protobuf:"bytes,1,rep,name=addresses,proto3" json:"addresses,omitempty"`
	IdentityKey string   `protobuf:"bytes,2,opt,name=identity_key,json=identityKey,proto3" json:"identity_key,omitempty"`
	// Deprecated, use features.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	GlobalFeatures []byte         `protobuf:"bytes,3,opt,name=global_features,json=globalFeatures,proto3" json:"global_features,omitempty"`
	Alias          string         `protobuf:"bytes,4,opt,name=alias,proto3" json:"alias,omitempty"`
	Color          string         `protobuf:"bytes,5,opt,name=color,proto3" json:"color,omitempty"`
	NodeAddresses  []*NodeAddress `protobuf:"bytes,7,rep,name=node_addresses,json=nodeAddresses,proto3" json:"node_addresses,omitempty"`
	// Features that the node has advertised in the init message, node
	// announcements and invoices.
	Features      map[uint32]*Feature `protobuf:"bytes,6,rep,name=features,proto3" json:"features,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeUpdate) Reset() {
	*x = NodeUpdate{}
	mi := &file_lightning_proto_msgTypes[129]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeUpdate) ProtoMessage() {}

func (x *NodeUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[129]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeUpdate.ProtoReflect.Descriptor instead.
func (*NodeUpdate) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{129}
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *NodeUpdate) GetAddresses() []string {
	if x != nil {
		return x.Addresses
	}
	return nil
}

func (x *NodeUpdate) GetIdentityKey() string {
	if x != nil {
		return x.IdentityKey
	}
	return ""
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *NodeUpdate) GetGlobalFeatures() []byte {
	if x != nil {
		return x.GlobalFeatures
	}
	return nil
}

func (x *NodeUpdate) GetAlias() string {
	if x != nil {
		return x.Alias
	}
	return ""
}

func (x *NodeUpdate) GetColor() string {
	if x != nil {
		return x.Color
	}
	return ""
}

func (x *NodeUpdate) GetNodeAddresses() []*NodeAddress {
	if x != nil {
		return x.NodeAddresses
	}
	return nil
}

func (x *NodeUpdate) GetFeatures() map[uint32]*Feature {
	if x != nil {
		return x.Features
	}
	return nil
}

type ChannelEdgeUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChanId          uint64         `protobuf:"varint,1,opt,name=chan_id,json=chanId,proto3" json:"chan_id,omitempty"`
	ChanPoint       *ChannelPoint  `protobuf:"bytes,2,opt,name=chan_point,json=chanPoint,proto3" json:"chan_point,omitempty"`
	Capacity        int64          `protobuf:"varint,3,opt,name=capacity,proto3" json:"capacity,omitempty"`
	RoutingPolicy   *RoutingPolicy `protobuf:"bytes,4,opt,name=routing_policy,json=routingPolicy,proto3" json:"routing_policy,omitempty"`
	AdvertisingNode string         `protobuf:"bytes,5,opt,name=advertising_node,json=advertisingNode,proto3" json:"advertising_node,omitempty"`
	ConnectingNode  string         `protobuf:"bytes,6,opt,name=connecting_node,json=connectingNode,proto3" json:"connecting_node,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ChannelEdgeUpdate) Reset() {
	*x = ChannelEdgeUpdate{}
	mi := &file_lightning_proto_msgTypes[130]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelEdgeUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelEdgeUpdate) ProtoMessage() {}

func (x *ChannelEdgeUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[130]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelEdgeUpdate.ProtoReflect.Descriptor instead.
func (*ChannelEdgeUpdate) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{130}
}

func (x *ChannelEdgeUpdate) GetChanId() uint64 {
	if x != nil {
		return x.ChanId
	}
	return 0
}

func (x *ChannelEdgeUpdate) GetChanPoint() *ChannelPoint {
	if x != nil {
		return x.ChanPoint
	}
	return nil
}

func (x *ChannelEdgeUpdate) GetCapacity() int64 {
	if x != nil {
		return x.Capacity
	}
	return 0
}

func (x *ChannelEdgeUpdate) GetRoutingPolicy() *RoutingPolicy {
	if x != nil {
		return x.RoutingPolicy
	}
	return nil
}

func (x *ChannelEdgeUpdate) GetAdvertisingNode() string {
	if x != nil {
		return x.AdvertisingNode
	}
	return ""
}

func (x *ChannelEdgeUpdate) GetConnectingNode() string {
	if x != nil {
		return x.ConnectingNode
	}
	return ""
}

type ClosedChannelUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChanId        uint64        `protobuf:"varint,1,opt,name=chan_id,json=chanId,proto3" json:"chan_id,omitempty"`
	Capacity      int64         `protobuf:"varint,2,opt,name=capacity,proto3" json:"capacity,omitempty"`
	ClosedHeight  uint32        `protobuf:"varint,3,opt,name=closed_height,json=closedHeight,proto3" json:"closed_height,omitempty"`
	ChanPoint     *ChannelPoint `protobuf:"bytes,4,opt,name=chan_point,json=chanPoint,proto3" json:"chan_point,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClosedChannelUpdate) Reset() {
	*x = ClosedChannelUpdate{}
	mi := &file_lightning_proto_msgTypes[131]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClosedChannelUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClosedChannelUpdate) ProtoMessage() {}

func (x *ClosedChannelUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[131]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClosedChannelUpdate.ProtoReflect.Descriptor instead.
func (*ClosedChannelUpdate) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{131}
}

func (x *ClosedChannelUpdate) GetChanId() uint64 {
	if x != nil {
		return x.ChanId
	}
	return 0
}

func (x *ClosedChannelUpdate) GetCapacity() int64 {
	if x != nil {
		return x.Capacity
	}
	return 0
}

func (x *ClosedChannelUpdate) GetClosedHeight() uint32 {
	if x != nil {
		return x.ClosedHeight
	}
	return 0
}

func (x *ClosedChannelUpdate) GetChanPoint() *ChannelPoint {
	if x != nil {
		return x.ChanPoint
	}
	return nil
}

type HopHint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The public key of the node at the start of the channel.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// The unique identifier of the channel.
	ChanId uint64 `protobuf:"varint,2,opt,name=chan_id,json=chanId,proto3" json:"chan_id,omitempty"`
	// The base fee of the channel denominated in millisatoshis.
	FeeBaseMsat uint32 `protobuf:"varint,3,opt,name=fee_base_msat,json=feeBaseMsat,proto3" json:"fee_base_msat,omitempty"`
	// The fee rate of the channel for sending one satoshi across it denominated in
	// millionths of a satoshi.
	FeeProportionalMillionths uint32 `protobuf:"varint,4,opt,name=fee_proportional_millionths,json=feeProportionalMillionths,proto3" json:"fee_proportional_millionths,omitempty"`
	// The time-lock delta of the channel.
	CltvExpiryDelta uint32 `protobuf:"varint,5,opt,name=cltv_expiry_delta,json=cltvExpiryDelta,proto3" json:"cltv_expiry_delta,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *HopHint) Reset() {
	*x = HopHint{}
	mi := &file_lightning_proto_msgTypes[132]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HopHint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HopHint) ProtoMessage() {}

func (x *HopHint) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[132]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HopHint.ProtoReflect.Descriptor instead.
func (*HopHint) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{132}
}

func (x *HopHint) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *HopHint) GetChanId() uint64 {
	if x != nil {
		return x.ChanId
	}
	return 0
}

func (x *HopHint) GetFeeBaseMsat() uint32 {
	if x != nil {
		return x.FeeBaseMsat
	}
	return 0
}

func (x *HopHint) GetFeeProportionalMillionths() uint32 {
	if x != nil {
		return x.FeeProportionalMillionths
	}
	return 0
}

func (x *HopHint) GetCltvExpiryDelta() uint32 {
	if x != nil {
		return x.CltvExpiryDelta
	}
	return 0
}

type SetID struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SetId         []byte                 `protobuf:"bytes,1,opt,name=set_id,json=setId,proto3" json:"set_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetID) Reset() {
	*x = SetID{}
	mi := &file_lightning_proto_msgTypes[133]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetID) ProtoMessage() {}

func (x *SetID) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[133]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetID.ProtoReflect.Descriptor instead.
func (*SetID) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{133}
}

func (x *SetID) GetSetId() []byte {
	if x != nil {
		return x.SetId
	}
	return nil
}

type RouteHint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of hop hints that when chained together can assist in reaching a
	// specific destination.
	HopHints      []*HopHint `protobuf:"bytes,1,rep,name=hop_hints,json=hopHints,proto3" json:"hop_hints,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RouteHint) Reset() {
	*x = RouteHint{}
	mi := &file_lightning_proto_msgTypes[134]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouteHint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteHint) ProtoMessage() {}

func (x *RouteHint) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[134]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteHint.ProtoReflect.Descriptor instead.
func (*RouteHint) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{134}
}

func (x *RouteHint) GetHopHints() []*HopHint {
	if x != nil {
		return x.HopHints
	}
	return nil
}

type BlindedPaymentPath struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The blinded path to send the payment to.
	BlindedPath *BlindedPath `protobuf:"bytes,1,opt,name=blinded_path,json=blindedPath,proto3" json:"blinded_path,omitempty"`
	// The base fee for the blinded path provided, expressed in msat.
	BaseFeeMsat uint64 `protobuf:"varint,2,opt,name=base_fee_msat,json=baseFeeMsat,proto3" json:"base_fee_msat,omitempty"`
	// The proportional fee for the blinded path provided, expressed in parts
	// per million.
	ProportionalFeeRate uint32 `protobuf:"varint,3,opt,name=proportional_fee_rate,json=proportionalFeeRate,proto3" json:"proportional_fee_rate,omitempty"`
	// The total CLTV delta for the blinded path provided, including the
	// final CLTV delta for the receiving node.
	TotalCltvDelta uint32 `protobuf:"varint,4,opt,name=total_cltv_delta,json=totalCltvDelta,proto3" json:"total_cltv_delta,omitempty"`
	// The minimum hltc size that may be sent over the blinded path, expressed
	// in msat.
	HtlcMinMsat uint64 `protobuf:"varint,5,opt,name=htlc_min_msat,json=htlcMinMsat,proto3" json:"htlc_min_msat,omitempty"`
	// The maximum htlc size that may be sent over the blinded path, expressed
	// in msat.
	HtlcMaxMsat uint64 `protobuf:"varint,6,opt,name=htlc_max_msat,json=htlcMaxMsat,proto3" json:"htlc_max_msat,omitempty"`
	// The feature bits for the route.
	Features      []FeatureBit `protobuf:"varint,7,rep,packed,name=features,proto3,enum=lnrpc.FeatureBit" json:"features,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BlindedPaymentPath) Reset() {
	*x = BlindedPaymentPath{}
	mi := &file_lightning_proto_msgTypes[135]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlindedPaymentPath) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlindedPaymentPath) ProtoMessage() {}

func (x *BlindedPaymentPath) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[135]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlindedPaymentPath.ProtoReflect.Descriptor instead.
func (*BlindedPaymentPath) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{135}
}

func (x *BlindedPaymentPath) GetBlindedPath() *BlindedPath {
	if x != nil {
		return x.BlindedPath
	}
	return nil
}

func (x *BlindedPaymentPath) GetBaseFeeMsat() uint64 {
	if x != nil {
		return x.BaseFeeMsat
	}
	return 0
}

func (x *BlindedPaymentPath) GetProportionalFeeRate() uint32 {
	if x != nil {
		return x.ProportionalFeeRate
	}
	return 0
}

func (x *BlindedPaymentPath) GetTotalCltvDelta() uint32 {
	if x != nil {
		return x.TotalCltvDelta
	}
	return 0
}

func (x *BlindedPaymentPath) GetHtlcMinMsat() uint64 {
	if x != nil {
		return x.HtlcMinMsat
	}
	return 0
}

func (x *BlindedPaymentPath) GetHtlcMaxMsat() uint64 {
	if x != nil {
		return x.HtlcMaxMsat
	}
	return 0
}

func (x *BlindedPaymentPath) GetFeatures() []FeatureBit {
	if x != nil {
		return x.Features
	}
	return nil
}

type BlindedPath struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unblinded pubkey of the introduction node for the route.
	IntroductionNode []byte `protobuf:"bytes,1,opt,name=introduction_node,json=introductionNode,proto3" json:"introduction_node,omitempty"`
	// The ephemeral pubkey used by nodes in the blinded route.
	BlindingPoint []byte `protobuf:"bytes,2,opt,name=blinding_point,json=blindingPoint,proto3" json:"blinding_point,omitempty"`
	// A set of blinded node keys and data blobs for the blinded portion of the
	// route. Note that the first hop is expected to be the introduction node,
	// so the route is always expected to have at least one hop.
	BlindedHops   []*BlindedHop `protobuf:"bytes,3,rep,name=blinded_hops,json=blindedHops,proto3" json:"blinded_hops,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BlindedPath) Reset() {
	*x = BlindedPath{}
	mi := &file_lightning_proto_msgTypes[136]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlindedPath) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlindedPath) ProtoMessage() {}

func (x *BlindedPath) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[136]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlindedPath.ProtoReflect.Descriptor instead.
func (*BlindedPath) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{136}
}

func (x *BlindedPath) GetIntroductionNode() []byte {
	if x != nil {
		return x.IntroductionNode
	}
	return nil
}

func (x *BlindedPath) GetBlindingPoint() []byte {
	if x != nil {
		return x.BlindingPoint
	}
	return nil
}

func (x *BlindedPath) GetBlindedHops() []*BlindedHop {
	if x != nil {
		return x.BlindedHops
	}
	return nil
}

type BlindedHop struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The blinded public key of the node.
	BlindedNode []byte `protobuf:"bytes,1,opt,name=blinded_node,json=blindedNode,proto3" json:"blinded_node,omitempty"`
	// An encrypted blob of data provided to the blinded node.
	EncryptedData []byte `protobuf:"bytes,2,opt,name=encrypted_data,json=encryptedData,proto3" json:"encrypted_data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BlindedHop) Reset() {
	*x = BlindedHop{}
	mi := &file_lightning_proto_msgTypes[137]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlindedHop) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlindedHop) ProtoMessage() {}

func (x *BlindedHop) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[137]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlindedHop.ProtoReflect.Descriptor instead.
func (*BlindedHop) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{137}
}

func (x *BlindedHop) GetBlindedNode() []byte {
	if x != nil {
		return x.BlindedNode
	}
	return nil
}

func (x *BlindedHop) GetEncryptedData() []byte {
	if x != nil {
		return x.EncryptedData
	}
	return nil
}

type AMPInvoiceState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The state the HTLCs associated with this setID are in.
	State InvoiceHTLCState `protobuf:"varint,1,opt,name=state,proto3,enum=lnrpc.InvoiceHTLCState" json:"state,omitempty"`
	// The settle index of this HTLC set, if the invoice state is settled.
	SettleIndex uint64 `protobuf:"varint,2,opt,name=settle_index,json=settleIndex,proto3" json:"settle_index,omitempty"`
	// The time this HTLC set was settled expressed in unix epoch.
	SettleTime int64 `protobuf:"varint,3,opt,name=settle_time,json=settleTime,proto3" json:"settle_time,omitempty"`
	// The total amount paid for the sub-invoice expressed in milli satoshis.
	AmtPaidMsat   int64 `protobuf:"varint,5,opt,name=amt_paid_msat,json=amtPaidMsat,proto3" json:"amt_paid_msat,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AMPInvoiceState) Reset() {
	*x = AMPInvoiceState{}
	mi := &file_lightning_proto_msgTypes[138]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AMPInvoiceState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AMPInvoiceState) ProtoMessage() {}

func (x *AMPInvoiceState) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[138]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AMPInvoiceState.ProtoReflect.Descriptor instead.
func (*AMPInvoiceState) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{138}
}

func (x *AMPInvoiceState) GetState() InvoiceHTLCState {
	if x != nil {
		return x.State
	}
	return InvoiceHTLCState_ACCEPTED
}

func (x *AMPInvoiceState) GetSettleIndex() uint64 {
	if x != nil {
		return x.SettleIndex
	}
	return 0
}

func (x *AMPInvoiceState) GetSettleTime() int64 {
	if x != nil {
		return x.SettleTime
	}
	return 0
}

func (x *AMPInvoiceState) GetAmtPaidMsat() int64 {
	if x != nil {
		return x.AmtPaidMsat
	}
	return 0
}

type Invoice struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// An optional memo to attach along with the invoice. Used for record keeping
	// purposes for the invoice's creator, and will also be set in the description
	// field of the encoded payment request if the description_hash field is not
	// being used.
	Memo string `protobuf:"bytes,1,opt,name=memo,proto3" json:"memo,omitempty"`
	// The hex-encoded preimage (32 byte) which will allow settling an incoming
	// HTLC payable to this preimage. When using REST, this field must be encoded
	// as base64.
	RPreimage []byte `protobuf:"bytes,3,opt,name=r_preimage,json=rPreimage,proto3" json:"r_preimage,omitempty"`
	// The hash of the preimage. When using REST, this field must be encoded as
	// base64.
	// Note: Output only, don't specify for creating an invoice.
	RHash []byte `protobuf:"bytes,4,opt,name=r_hash,json=rHash,proto3" json:"r_hash,omitempty"`
	// The value of this invoice in satoshis
	//
	// The fields value and value_msat are mutually exclusive.
	Value int64 `protobuf:"varint,5,opt,name=value,proto3" json:"value,omitempty"`
	// The value of this invoice in millisatoshis
	//
	// The fields value and value_msat are mutually exclusive.
	ValueMsat int64 `protobuf:"varint,23,opt,name=value_msat,json=valueMsat,proto3" json:"value_msat,omitempty"`
	// Whether this invoice has been fulfilled.
	//
	// The field is deprecated. Use the state field instead (compare to SETTLED).
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	Settled bool `protobuf:"varint,6,opt,name=settled,proto3" json:"settled,omitempty"`
	// When this invoice was created.
	// Measured in seconds since the unix epoch.
	// Note: Output only, don't specify for creating an invoice.
	CreationDate int64 `protobuf:"varint,7,opt,name=creation_date,json=creationDate,proto3" json:"creation_date,omitempty"`
	// When this invoice was settled.
	// Measured in seconds since the unix epoch.
	// Note: Output only, don't specify for creating an invoice.
	SettleDate int64 `protobuf:"varint,8,opt,name=settle_date,json=settleDate,proto3" json:"settle_date,omitempty"`
	// A bare-bones invoice for a payment within the Lightning Network. With the
	// details of the invoice, the sender has all the data necessary to send a
	// payment to the recipient.
	// Note: Output only, don't specify for creating an invoice.
	PaymentRequest string `protobuf:"bytes,9,opt,name=payment_request,json=paymentRequest,proto3" json:"payment_request,omitempty"`
	// Hash (SHA-256) of a description of the payment. Used if the description of
	// payment (memo) is too long to naturally fit within the description field
	// of an encoded payment request. When using REST, this field must be encoded
	// as base64.
	DescriptionHash []byte `protobuf:"bytes,10,opt,name=description_hash,json=descriptionHash,proto3" json:"description_hash,omitempty"`
	// Payment request expiry time in seconds. Default is 86400 (24 hours).
	Expiry int64 `protobuf:"varint,11,opt,name=expiry,proto3" json:"expiry,omitempty"`
	// Fallback on-chain address.
	FallbackAddr string `protobuf:"bytes,12,opt,name=fallback_addr,json=fallbackAddr,proto3" json:"fallback_addr,omitempty"`
	// Delta to use for the time-lock of the CLTV extended to the final hop.
	CltvExpiry uint64 `protobuf:"varint,13,opt,name=cltv_expiry,json=cltvExpiry,proto3" json:"cltv_expiry,omitempty"`
	// Route hints that can each be individually used to assist in reaching the
	// invoice's destination.
	RouteHints []*RouteHint `protobuf:"bytes,14,rep,name=route_hints,json=routeHints,proto3" json:"route_hints,omitempty"`
	// Whether this invoice should include routing hints for private channels.
	// Note: When enabled, if value and value_msat are zero, a large number of
	// hints with these channels can be included, which might not be desirable.
	Private bool `protobuf:"varint,15,opt,name=private,proto3" json:"private,omitempty"`
	// The "add" index of this invoice. Each newly created invoice will increment
	// this index making it monotonically increasing. Callers to the
	// SubscribeInvoices call can use this to instantly get notified of all added
	// invoices with an add_index greater than this one.
	// Note: Output only, don't specify for creating an invoice.
	AddIndex uint64 `protobuf:"varint,16,opt,name=add_index,json=addIndex,proto3" json:"add_index,omitempty"`
	// The "settle" index of this invoice. Each newly settled invoice will
	// increment this index making it monotonically increasing. Callers to the
	// SubscribeInvoices call can use this to instantly get notified of all
	// settled invoices with an settle_index greater than this one.
	// Note: Output only, don't specify for creating an invoice.
	SettleIndex uint64 `protobuf:"varint,17,opt,name=settle_index,json=settleIndex,proto3" json:"settle_index,omitempty"`
	// Deprecated, use amt_paid_sat or amt_paid_msat.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	AmtPaid int64 `protobuf:"varint,18,opt,name=amt_paid,json=amtPaid,proto3" json:"amt_paid,omitempty"`
	// The amount that was accepted for this invoice, in satoshis. This will ONLY
	// be set if this invoice has been settled or accepted. We provide this field
	// as if the invoice was created with a zero value, then we need to record what
	// amount was ultimately accepted. Additionally, it's possible that the sender
	// paid MORE that was specified in the original invoice. So we'll record that
	// here as well.
	// Note: Output only, don't specify for creating an invoice.
	AmtPaidSat int64 `protobuf:"varint,19,opt,name=amt_paid_sat,json=amtPaidSat,proto3" json:"amt_paid_sat,omitempty"`
	// The amount that was accepted for this invoice, in millisatoshis. This will
	// ONLY be set if this invoice has been settled or accepted. We provide this
	// field as if the invoice was created with a zero value, then we need to
	// record what amount was ultimately accepted. Additionally, it's possible that
	// the sender paid MORE that was specified in the original invoice. So we'll
	// record that here as well.
	// Note: Output only, don't specify for creating an invoice.
	AmtPaidMsat int64 `protobuf:"varint,20,opt,name=amt_paid_msat,json=amtPaidMsat,proto3" json:"amt_paid_msat,omitempty"`
	// The state the invoice is in.
	// Note: Output only, don't specify for creating an invoice.
	State Invoice_InvoiceState `protobuf:"varint,21,opt,name=state,proto3,enum=lnrpc.Invoice_InvoiceState" json:"state,omitempty"`
	// List of HTLCs paying to this invoice [EXPERIMENTAL].
	// Note: Output only, don't specify for creating an invoice.
	Htlcs []*InvoiceHTLC `protobuf:"bytes,22,rep,name=htlcs,proto3" json:"htlcs,omitempty"`
	// List of features advertised on the invoice.
	// Note: Output only, don't specify for creating an invoice.
	Features map[uint32]*Feature `protobuf:"bytes,24,rep,name=features,proto3" json:"features,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Indicates if this invoice was a spontaneous payment that arrived via keysend
	// [EXPERIMENTAL].
	// Note: Output only, don't specify for creating an invoice.
	IsKeysend bool `protobuf:"varint,25,opt,name=is_keysend,json=isKeysend,proto3" json:"is_keysend,omitempty"`
	// The payment address of this invoice. This is also called payment secret in
	// specifications (e.g. BOLT 11). This value will be used in MPP payments, and
	// also for newer invoices that always require the MPP payload for added
	// end-to-end security.
	// Note: Output only, don't specify for creating an invoice.
	PaymentAddr []byte `protobuf:"bytes,26,opt,name=payment_addr,json=paymentAddr,proto3" json:"payment_addr,omitempty"`
	// Signals whether or not this is an AMP invoice.
	IsAmp bool `protobuf:"varint,27,opt,name=is_amp,json=isAmp,proto3" json:"is_amp,omitempty"`
	// [EXPERIMENTAL]:
	//
	// Maps a 32-byte hex-encoded set ID to the sub-invoice AMP state for the
	// given set ID. This field is always populated for AMP invoices, and can be
	// used along side LookupInvoice to obtain the HTLC information related to a
	// given sub-invoice.
	// Note: Output only, don't specify for creating an invoice.
	AmpInvoiceState map[string]*AMPInvoiceState `protobuf:"bytes,28,rep,name=amp_invoice_state,json=ampInvoiceState,proto3" json:"amp_invoice_state,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Signals that the invoice should include blinded paths to hide the true
	// identity of the recipient.
	IsBlinded bool `protobuf:"varint,29,opt,name=is_blinded,json=isBlinded,proto3" json:"is_blinded,omitempty"`
	// Config values to use when creating blinded paths for this invoice. These
	// can be used to override the defaults config values provided in by the
	// global config. This field is only used if is_blinded is true.
	BlindedPathConfig *BlindedPathConfig `protobuf:"bytes,30,opt,name=blinded_path_config,json=blindedPathConfig,proto3" json:"blinded_path_config,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *Invoice) Reset() {
	*x = Invoice{}
	mi := &file_lightning_proto_msgTypes[139]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Invoice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Invoice) ProtoMessage() {}

func (x *Invoice) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[139]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Invoice.ProtoReflect.Descriptor instead.
func (*Invoice) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{139}
}

func (x *Invoice) GetMemo() string {
	if x != nil {
		return x.Memo
	}
	return ""
}

func (x *Invoice) GetRPreimage() []byte {
	if x != nil {
		return x.RPreimage
	}
	return nil
}

func (x *Invoice) GetRHash() []byte {
	if x != nil {
		return x.RHash
	}
	return nil
}

func (x *Invoice) GetValue() int64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *Invoice) GetValueMsat() int64 {
	if x != nil {
		return x.ValueMsat
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *Invoice) GetSettled() bool {
	if x != nil {
		return x.Settled
	}
	return false
}

func (x *Invoice) GetCreationDate() int64 {
	if x != nil {
		return x.CreationDate
	}
	return 0
}

func (x *Invoice) GetSettleDate() int64 {
	if x != nil {
		return x.SettleDate
	}
	return 0
}

func (x *Invoice) GetPaymentRequest() string {
	if x != nil {
		return x.PaymentRequest
	}
	return ""
}

func (x *Invoice) GetDescriptionHash() []byte {
	if x != nil {
		return x.DescriptionHash
	}
	return nil
}

func (x *Invoice) GetExpiry() int64 {
	if x != nil {
		return x.Expiry
	}
	return 0
}

func (x *Invoice) GetFallbackAddr() string {
	if x != nil {
		return x.FallbackAddr
	}
	return ""
}

func (x *Invoice) GetCltvExpiry() uint64 {
	if x != nil {
		return x.CltvExpiry
	}
	return 0
}

func (x *Invoice) GetRouteHints() []*RouteHint {
	if x != nil {
		return x.RouteHints
	}
	return nil
}

func (x *Invoice) GetPrivate() bool {
	if x != nil {
		return x.Private
	}
	return false
}

func (x *Invoice) GetAddIndex() uint64 {
	if x != nil {
		return x.AddIndex
	}
	return 0
}

func (x *Invoice) GetSettleIndex() uint64 {
	if x != nil {
		return x.SettleIndex
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *Invoice) GetAmtPaid() int64 {
	if x != nil {
		return x.AmtPaid
	}
	return 0
}

func (x *Invoice) GetAmtPaidSat() int64 {
	if x != nil {
		return x.AmtPaidSat
	}
	return 0
}

func (x *Invoice) GetAmtPaidMsat() int64 {
	if x != nil {
		return x.AmtPaidMsat
	}
	return 0
}

func (x *Invoice) GetState() Invoice_InvoiceState {
	if x != nil {
		return x.State
	}
	return Invoice_OPEN
}

func (x *Invoice) GetHtlcs() []*InvoiceHTLC {
	if x != nil {
		return x.Htlcs
	}
	return nil
}

func (x *Invoice) GetFeatures() map[uint32]*Feature {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *Invoice) GetIsKeysend() bool {
	if x != nil {
		return x.IsKeysend
	}
	return false
}

func (x *Invoice) GetPaymentAddr() []byte {
	if x != nil {
		return x.PaymentAddr
	}
	return nil
}

func (x *Invoice) GetIsAmp() bool {
	if x != nil {
		return x.IsAmp
	}
	return false
}

func (x *Invoice) GetAmpInvoiceState() map[string]*AMPInvoiceState {
	if x != nil {
		return x.AmpInvoiceState
	}
	return nil
}

func (x *Invoice) GetIsBlinded() bool {
	if x != nil {
		return x.IsBlinded
	}
	return false
}

func (x *Invoice) GetBlindedPathConfig() *BlindedPathConfig {
	if x != nil {
		return x.BlindedPathConfig
	}
	return nil
}

type BlindedPathConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The minimum number of real hops to include in a blinded path. This doesn't
	// include our node, so if the minimum is 1, then the path will contain at
	// minimum our node along with an introduction node hop. If it is zero then
	// the shortest path will use our node as an introduction node.
	MinNumRealHops *uint32 `protobuf:"varint,1,opt,name=min_num_real_hops,json=minNumRealHops,proto3,oneof" json:"min_num_real_hops,omitempty"`
	// The number of hops to include in a blinded path. This doesn't include our
	// node, so if it is 1, then the path will contain our node along with an
	// introduction node or dummy node hop. If paths shorter than NumHops is
	// found, then they will be padded using dummy hops.
	NumHops *uint32 `protobuf:"varint,2,opt,name=num_hops,json=numHops,proto3,oneof" json:"num_hops,omitempty"`
	// The maximum number of blinded paths to select and add to an invoice.
	MaxNumPaths *uint32 `protobuf:"varint,3,opt,name=max_num_paths,json=maxNumPaths,proto3,oneof" json:"max_num_paths,omitempty"`
	// A list of node IDs of nodes that should not be used in any of our generated
	// blinded paths.
	NodeOmissionList [][]byte `protobuf:"bytes,4,rep,name=node_omission_list,json=nodeOmissionList,proto3" json:"node_omission_list,omitempty"`
	// The chained channels list specified via channel id (separated by commas),
	// starting from a channel owned by the receiver node.
	IncomingChannelList []uint64 `protobuf:"varint,5,rep,packed,name=incoming_channel_list,json=incomingChannelList,proto3" json:"incoming_channel_list,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *BlindedPathConfig) Reset() {
	*x = BlindedPathConfig{}
	mi := &file_lightning_proto_msgTypes[140]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlindedPathConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlindedPathConfig) ProtoMessage() {}

func (x *BlindedPathConfig) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[140]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlindedPathConfig.ProtoReflect.Descriptor instead.
func (*BlindedPathConfig) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{140}
}

func (x *BlindedPathConfig) GetMinNumRealHops() uint32 {
	if x != nil && x.MinNumRealHops != nil {
		return *x.MinNumRealHops
	}
	return 0
}

func (x *BlindedPathConfig) GetNumHops() uint32 {
	if x != nil && x.NumHops != nil {
		return *x.NumHops
	}
	return 0
}

func (x *BlindedPathConfig) GetMaxNumPaths() uint32 {
	if x != nil && x.MaxNumPaths != nil {
		return *x.MaxNumPaths
	}
	return 0
}

func (x *BlindedPathConfig) GetNodeOmissionList() [][]byte {
	if x != nil {
		return x.NodeOmissionList
	}
	return nil
}

func (x *BlindedPathConfig) GetIncomingChannelList() []uint64 {
	if x != nil {
		return x.IncomingChannelList
	}
	return nil
}

// Details of an HTLC that paid to an invoice
type InvoiceHTLC struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Short channel id over which the htlc was received.
	ChanId uint64 `protobuf:"varint,1,opt,name=chan_id,json=chanId,proto3" json:"chan_id,omitempty"`
	// Index identifying the htlc on the channel.
	HtlcIndex uint64 `protobuf:"varint,2,opt,name=htlc_index,json=htlcIndex,proto3" json:"htlc_index,omitempty"`
	// The amount of the htlc in msat.
	AmtMsat uint64 `protobuf:"varint,3,opt,name=amt_msat,json=amtMsat,proto3" json:"amt_msat,omitempty"`
	// Block height at which this htlc was accepted.
	AcceptHeight int32 `protobuf:"varint,4,opt,name=accept_height,json=acceptHeight,proto3" json:"accept_height,omitempty"`
	// Time at which this htlc was accepted.
	AcceptTime int64 `protobuf:"varint,5,opt,name=accept_time,json=acceptTime,proto3" json:"accept_time,omitempty"`
	// Time at which this htlc was settled or canceled.
	ResolveTime int64 `protobuf:"varint,6,opt,name=resolve_time,json=resolveTime,proto3" json:"resolve_time,omitempty"`
	// Block height at which this htlc expires.
	ExpiryHeight int32 `protobuf:"varint,7,opt,name=expiry_height,json=expiryHeight,proto3" json:"expiry_height,omitempty"`
	// Current state the htlc is in.
	State InvoiceHTLCState `protobuf:"varint,8,opt,name=state,proto3,enum=lnrpc.InvoiceHTLCState" json:"state,omitempty"`
	// Custom tlv records.
	CustomRecords map[uint64][]byte `protobuf:"bytes,9,rep,name=custom_records,json=customRecords,proto3" json:"custom_records,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The total amount of the mpp payment in msat.
	MppTotalAmtMsat uint64 `protobuf:"varint,10,opt,name=mpp_total_amt_msat,json=mppTotalAmtMsat,proto3" json:"mpp_total_amt_msat,omitempty"`
	// Details relevant to AMP HTLCs, only populated if this is an AMP HTLC.
	Amp *AMP `protobuf:"bytes,11,opt,name=amp,proto3" json:"amp,omitempty"`
	// Custom channel data that might be populated in custom channels.
	CustomChannelData []byte `protobuf:"bytes,12,opt,name=custom_channel_data,json=customChannelData,proto3" json:"custom_channel_data,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *InvoiceHTLC) Reset() {
	*x = InvoiceHTLC{}
	mi := &file_lightning_proto_msgTypes[141]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InvoiceHTLC) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InvoiceHTLC) ProtoMessage() {}

func (x *InvoiceHTLC) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[141]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InvoiceHTLC.ProtoReflect.Descriptor instead.
func (*InvoiceHTLC) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{141}
}

func (x *InvoiceHTLC) GetChanId() uint64 {
	if x != nil {
		return x.ChanId
	}
	return 0
}

func (x *InvoiceHTLC) GetHtlcIndex() uint64 {
	if x != nil {
		return x.HtlcIndex
	}
	return 0
}

func (x *InvoiceHTLC) GetAmtMsat() uint64 {
	if x != nil {
		return x.AmtMsat
	}
	return 0
}

func (x *InvoiceHTLC) GetAcceptHeight() int32 {
	if x != nil {
		return x.AcceptHeight
	}
	return 0
}

func (x *InvoiceHTLC) GetAcceptTime() int64 {
	if x != nil {
		return x.AcceptTime
	}
	return 0
}

func (x *InvoiceHTLC) GetResolveTime() int64 {
	if x != nil {
		return x.ResolveTime
	}
	return 0
}

func (x *InvoiceHTLC) GetExpiryHeight() int32 {
	if x != nil {
		return x.ExpiryHeight
	}
	return 0
}

func (x *InvoiceHTLC) GetState() InvoiceHTLCState {
	if x != nil {
		return x.State
	}
	return InvoiceHTLCState_ACCEPTED
}

func (x *InvoiceHTLC) GetCustomRecords() map[uint64][]byte {
	if x != nil {
		return x.CustomRecords
	}
	return nil
}

func (x *InvoiceHTLC) GetMppTotalAmtMsat() uint64 {
	if x != nil {
		return x.MppTotalAmtMsat
	}
	return 0
}

func (x *InvoiceHTLC) GetAmp() *AMP {
	if x != nil {
		return x.Amp
	}
	return nil
}

func (x *InvoiceHTLC) GetCustomChannelData() []byte {
	if x != nil {
		return x.CustomChannelData
	}
	return nil
}

// Details specific to AMP HTLCs.
type AMP struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// An n-of-n secret share of the root seed from which child payment hashes
	// and preimages are derived.
	RootShare []byte `protobuf:"bytes,1,opt,name=root_share,json=rootShare,proto3" json:"root_share,omitempty"`
	// An identifier for the HTLC set that this HTLC belongs to.
	SetId []byte `protobuf:"bytes,2,opt,name=set_id,json=setId,proto3" json:"set_id,omitempty"`
	// A nonce used to randomize the child preimage and child hash from a given
	// root_share.
	ChildIndex uint32 `protobuf:"varint,3,opt,name=child_index,json=childIndex,proto3" json:"child_index,omitempty"`
	// The payment hash of the AMP HTLC.
	Hash []byte `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`
	// The preimage used to settle this AMP htlc. This field will only be
	// populated if the invoice is in InvoiceState_ACCEPTED or
	// InvoiceState_SETTLED.
	Preimage      []byte `protobuf:"bytes,5,opt,name=preimage,proto3" json:"preimage,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AMP) Reset() {
	*x = AMP{}
	mi := &file_lightning_proto_msgTypes[142]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AMP) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AMP) ProtoMessage() {}

func (x *AMP) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[142]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AMP.ProtoReflect.Descriptor instead.
func (*AMP) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{142}
}

func (x *AMP) GetRootShare() []byte {
	if x != nil {
		return x.RootShare
	}
	return nil
}

func (x *AMP) GetSetId() []byte {
	if x != nil {
		return x.SetId
	}
	return nil
}

func (x *AMP) GetChildIndex() uint32 {
	if x != nil {
		return x.ChildIndex
	}
	return 0
}

func (x *AMP) GetHash() []byte {
	if x != nil {
		return x.Hash
	}
	return nil
}

func (x *AMP) GetPreimage() []byte {
	if x != nil {
		return x.Preimage
	}
	return nil
}

type AddInvoiceResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	RHash []byte                 `protobuf:"bytes,1,opt,name=r_hash,json=rHash,proto3" json:"r_hash,omitempty"`
	// A bare-bones invoice for a payment within the Lightning Network. With the
	// details of the invoice, the sender has all the data necessary to send a
	// payment to the recipient.
	PaymentRequest string `protobuf:"bytes,2,opt,name=payment_request,json=paymentRequest,proto3" json:"payment_request,omitempty"`
	// The "add" index of this invoice. Each newly created invoice will increment
	// this index making it monotonically increasing. Callers to the
	// SubscribeInvoices call can use this to instantly get notified of all added
	// invoices with an add_index greater than this one.
	AddIndex uint64 `protobuf:"varint,16,opt,name=add_index,json=addIndex,proto3" json:"add_index,omitempty"`
	// The payment address of the generated invoice. This is also called
	// payment secret in specifications (e.g. BOLT 11). This value should be used
	// in all payments for this invoice as we require it for end to end security.
	PaymentAddr   []byte `protobuf:"bytes,17,opt,name=payment_addr,json=paymentAddr,proto3" json:"payment_addr,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddInvoiceResponse) Reset() {
	*x = AddInvoiceResponse{}
	mi := &file_lightning_proto_msgTypes[143]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddInvoiceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddInvoiceResponse) ProtoMessage() {}

func (x *AddInvoiceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[143]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddInvoiceResponse.ProtoReflect.Descriptor instead.
func (*AddInvoiceResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{143}
}

func (x *AddInvoiceResponse) GetRHash() []byte {
	if x != nil {
		return x.RHash
	}
	return nil
}

func (x *AddInvoiceResponse) GetPaymentRequest() string {
	if x != nil {
		return x.PaymentRequest
	}
	return ""
}

func (x *AddInvoiceResponse) GetAddIndex() uint64 {
	if x != nil {
		return x.AddIndex
	}
	return 0
}

func (x *AddInvoiceResponse) GetPaymentAddr() []byte {
	if x != nil {
		return x.PaymentAddr
	}
	return nil
}

type PaymentHash struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The hex-encoded payment hash of the invoice to be looked up. The passed
	// payment hash must be exactly 32 bytes, otherwise an error is returned.
	// Deprecated now that the REST gateway supports base64 encoding of bytes
	// fields.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	RHashStr string `protobuf:"bytes,1,opt,name=r_hash_str,json=rHashStr,proto3" json:"r_hash_str,omitempty"`
	// The payment hash of the invoice to be looked up. When using REST, this field
	// must be encoded as base64.
	RHash         []byte `protobuf:"bytes,2,opt,name=r_hash,json=rHash,proto3" json:"r_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PaymentHash) Reset() {
	*x = PaymentHash{}
	mi := &file_lightning_proto_msgTypes[144]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PaymentHash) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PaymentHash) ProtoMessage() {}

func (x *PaymentHash) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[144]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PaymentHash.ProtoReflect.Descriptor instead.
func (*PaymentHash) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{144}
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *PaymentHash) GetRHashStr() string {
	if x != nil {
		return x.RHashStr
	}
	return ""
}

func (x *PaymentHash) GetRHash() []byte {
	if x != nil {
		return x.RHash
	}
	return nil
}

type ListInvoiceRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If set, only invoices that are not settled and not canceled will be returned
	// in the response.
	PendingOnly bool `protobuf:"varint,1,opt,name=pending_only,json=pendingOnly,proto3" json:"pending_only,omitempty"`
	// The index of an invoice that will be used as either the start or end of a
	// query to determine which invoices should be returned in the response.
	IndexOffset uint64 `protobuf:"varint,4,opt,name=index_offset,json=indexOffset,proto3" json:"index_offset,omitempty"`
	// The max number of invoices to return in the response to this query.
	NumMaxInvoices uint64 `protobuf:"varint,5,opt,name=num_max_invoices,json=numMaxInvoices,proto3" json:"num_max_invoices,omitempty"`
	// If set, the invoices returned will result from seeking backwards from the
	// specified index offset. This can be used to paginate backwards.
	Reversed bool `protobuf:"varint,6,opt,name=reversed,proto3" json:"reversed,omitempty"`
	// If set, returns all invoices with a creation date greater than or equal
	// to it. Measured in seconds since the unix epoch.
	CreationDateStart uint64 `protobuf:"varint,7,opt,name=creation_date_start,json=creationDateStart,proto3" json:"creation_date_start,omitempty"`
	// If set, returns all invoices with a creation date less than or equal to
	// it. Measured in seconds since the unix epoch.
	CreationDateEnd uint64 `protobuf:"varint,8,opt,name=creation_date_end,json=creationDateEnd,proto3" json:"creation_date_end,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ListInvoiceRequest) Reset() {
	*x = ListInvoiceRequest{}
	mi := &file_lightning_proto_msgTypes[145]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListInvoiceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListInvoiceRequest) ProtoMessage() {}

func (x *ListInvoiceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[145]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListInvoiceRequest.ProtoReflect.Descriptor instead.
func (*ListInvoiceRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{145}
}

func (x *ListInvoiceRequest) GetPendingOnly() bool {
	if x != nil {
		return x.PendingOnly
	}
	return false
}

func (x *ListInvoiceRequest) GetIndexOffset() uint64 {
	if x != nil {
		return x.IndexOffset
	}
	return 0
}

func (x *ListInvoiceRequest) GetNumMaxInvoices() uint64 {
	if x != nil {
		return x.NumMaxInvoices
	}
	return 0
}

func (x *ListInvoiceRequest) GetReversed() bool {
	if x != nil {
		return x.Reversed
	}
	return false
}

func (x *ListInvoiceRequest) GetCreationDateStart() uint64 {
	if x != nil {
		return x.CreationDateStart
	}
	return 0
}

func (x *ListInvoiceRequest) GetCreationDateEnd() uint64 {
	if x != nil {
		return x.CreationDateEnd
	}
	return 0
}

type ListInvoiceResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of invoices from the time slice of the time series specified in the
	// request.
	Invoices []*Invoice `protobuf:"bytes,1,rep,name=invoices,proto3" json:"invoices,omitempty"`
	// The index of the last item in the set of returned invoices. This can be used
	// to seek further, pagination style.
	LastIndexOffset uint64 `protobuf:"varint,2,opt,name=last_index_offset,json=lastIndexOffset,proto3" json:"last_index_offset,omitempty"`
	// The index of the last item in the set of returned invoices. This can be used
	// to seek backwards, pagination style.
	FirstIndexOffset uint64 `protobuf:"varint,3,opt,name=first_index_offset,json=firstIndexOffset,proto3" json:"first_index_offset,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ListInvoiceResponse) Reset() {
	*x = ListInvoiceResponse{}
	mi := &file_lightning_proto_msgTypes[146]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListInvoiceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListInvoiceResponse) ProtoMessage() {}

func (x *ListInvoiceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[146]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListInvoiceResponse.ProtoReflect.Descriptor instead.
func (*ListInvoiceResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{146}
}

func (x *ListInvoiceResponse) GetInvoices() []*Invoice {
	if x != nil {
		return x.Invoices
	}
	return nil
}

func (x *ListInvoiceResponse) GetLastIndexOffset() uint64 {
	if x != nil {
		return x.LastIndexOffset
	}
	return 0
}

func (x *ListInvoiceResponse) GetFirstIndexOffset() uint64 {
	if x != nil {
		return x.FirstIndexOffset
	}
	return 0
}

type InvoiceSubscription struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If specified (non-zero), then we'll first start by sending out
	// notifications for all added indexes with an add_index greater than this
	// value. This allows callers to catch up on any events they missed while they
	// weren't connected to the streaming RPC.
	AddIndex uint64 `protobuf:"varint,1,opt,name=add_index,json=addIndex,proto3" json:"add_index,omitempty"`
	// If specified (non-zero), then we'll first start by sending out
	// notifications for all settled indexes with an settle_index greater than
	// this value. This allows callers to catch up on any events they missed while
	// they weren't connected to the streaming RPC.
	SettleIndex   uint64 `protobuf:"varint,2,opt,name=settle_index,json=settleIndex,proto3" json:"settle_index,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InvoiceSubscription) Reset() {
	*x = InvoiceSubscription{}
	mi := &file_lightning_proto_msgTypes[147]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InvoiceSubscription) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InvoiceSubscription) ProtoMessage() {}

func (x *InvoiceSubscription) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[147]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InvoiceSubscription.ProtoReflect.Descriptor instead.
func (*InvoiceSubscription) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{147}
}

func (x *InvoiceSubscription) GetAddIndex() uint64 {
	if x != nil {
		return x.AddIndex
	}
	return 0
}

func (x *InvoiceSubscription) GetSettleIndex() uint64 {
	if x != nil {
		return x.SettleIndex
	}
	return 0
}

type DelCanceledInvoiceReq struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Invoice payment hash to delete.
	InvoiceHash   string `protobuf:"bytes,1,opt,name=invoice_hash,json=invoiceHash,proto3" json:"invoice_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DelCanceledInvoiceReq) Reset() {
	*x = DelCanceledInvoiceReq{}
	mi := &file_lightning_proto_msgTypes[148]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DelCanceledInvoiceReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DelCanceledInvoiceReq) ProtoMessage() {}

func (x *DelCanceledInvoiceReq) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[148]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DelCanceledInvoiceReq.ProtoReflect.Descriptor instead.
func (*DelCanceledInvoiceReq) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{148}
}

func (x *DelCanceledInvoiceReq) GetInvoiceHash() string {
	if x != nil {
		return x.InvoiceHash
	}
	return ""
}

type DelCanceledInvoiceResp struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The status of the delete operation.
	Status        string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DelCanceledInvoiceResp) Reset() {
	*x = DelCanceledInvoiceResp{}
	mi := &file_lightning_proto_msgTypes[149]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DelCanceledInvoiceResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DelCanceledInvoiceResp) ProtoMessage() {}

func (x *DelCanceledInvoiceResp) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[149]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DelCanceledInvoiceResp.ProtoReflect.Descriptor instead.
func (*DelCanceledInvoiceResp) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{149}
}

func (x *DelCanceledInvoiceResp) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

type Payment struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The payment hash
	PaymentHash string `protobuf:"bytes,1,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	// Deprecated, use value_sat or value_msat.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	Value int64 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	// Deprecated, use creation_time_ns
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	CreationDate int64 `protobuf:"varint,3,opt,name=creation_date,json=creationDate,proto3" json:"creation_date,omitempty"`
	// Deprecated, use fee_sat or fee_msat.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	Fee int64 `protobuf:"varint,5,opt,name=fee,proto3" json:"fee,omitempty"`
	// The payment preimage
	PaymentPreimage string `protobuf:"bytes,6,opt,name=payment_preimage,json=paymentPreimage,proto3" json:"payment_preimage,omitempty"`
	// The value of the payment in satoshis
	ValueSat int64 `protobuf:"varint,7,opt,name=value_sat,json=valueSat,proto3" json:"value_sat,omitempty"`
	// The value of the payment in milli-satoshis
	ValueMsat int64 `protobuf:"varint,8,opt,name=value_msat,json=valueMsat,proto3" json:"value_msat,omitempty"`
	// The optional payment request being fulfilled.
	PaymentRequest string `protobuf:"bytes,9,opt,name=payment_request,json=paymentRequest,proto3" json:"payment_request,omitempty"`
	// The status of the payment.
	Status Payment_PaymentStatus `protobuf:"varint,10,opt,name=status,proto3,enum=lnrpc.Payment_PaymentStatus" json:"status,omitempty"`
	// The fee paid for this payment in satoshis
	FeeSat int64 `protobuf:"varint,11,opt,name=fee_sat,json=feeSat,proto3" json:"fee_sat,omitempty"`
	// The fee paid for this payment in milli-satoshis
	FeeMsat int64 `protobuf:"varint,12,opt,name=fee_msat,json=feeMsat,proto3" json:"fee_msat,omitempty"`
	// The time in UNIX nanoseconds at which the payment was created.
	CreationTimeNs int64 `protobuf:"varint,13,opt,name=creation_time_ns,json=creationTimeNs,proto3" json:"creation_time_ns,omitempty"`
	// The HTLCs made in attempt to settle the payment.
	Htlcs []*HTLCAttempt `protobuf:"bytes,14,rep,name=htlcs,proto3" json:"htlcs,omitempty"`
	// The creation index of this payment. Each payment can be uniquely identified
	// by this index, which may not strictly increment by 1 for payments made in
	// older versions of lnd.
	PaymentIndex  uint64               `protobuf:"varint,15,opt,name=payment_index,json=paymentIndex,proto3" json:"payment_index,omitempty"`
	FailureReason PaymentFailureReason `protobuf:"varint,16,opt,name=failure_reason,json=failureReason,proto3,enum=lnrpc.PaymentFailureReason" json:"failure_reason,omitempty"`
	// The custom TLV records that were sent to the first hop as part of the HTLC
	// wire message for this payment.
	FirstHopCustomRecords map[uint64][]byte `protobuf:"bytes,17,rep,name=first_hop_custom_records,json=firstHopCustomRecords,proto3" json:"first_hop_custom_records,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *Payment) Reset() {
	*x = Payment{}
	mi := &file_lightning_proto_msgTypes[150]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Payment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Payment) ProtoMessage() {}

func (x *Payment) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[150]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Payment.ProtoReflect.Descriptor instead.
func (*Payment) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{150}
}

func (x *Payment) GetPaymentHash() string {
	if x != nil {
		return x.PaymentHash
	}
	return ""
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *Payment) GetValue() int64 {
	if x != nil {
		return x.Value
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *Payment) GetCreationDate() int64 {
	if x != nil {
		return x.CreationDate
	}
	return 0
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *Payment) GetFee() int64 {
	if x != nil {
		return x.Fee
	}
	return 0
}

func (x *Payment) GetPaymentPreimage() string {
	if x != nil {
		return x.PaymentPreimage
	}
	return ""
}

func (x *Payment) GetValueSat() int64 {
	if x != nil {
		return x.ValueSat
	}
	return 0
}

func (x *Payment) GetValueMsat() int64 {
	if x != nil {
		return x.ValueMsat
	}
	return 0
}

func (x *Payment) GetPaymentRequest() string {
	if x != nil {
		return x.PaymentRequest
	}
	return ""
}

func (x *Payment) GetStatus() Payment_PaymentStatus {
	if x != nil {
		return x.Status
	}
	return Payment_UNKNOWN
}

func (x *Payment) GetFeeSat() int64 {
	if x != nil {
		return x.FeeSat
	}
	return 0
}

func (x *Payment) GetFeeMsat() int64 {
	if x != nil {
		return x.FeeMsat
	}
	return 0
}

func (x *Payment) GetCreationTimeNs() int64 {
	if x != nil {
		return x.CreationTimeNs
	}
	return 0
}

func (x *Payment) GetHtlcs() []*HTLCAttempt {
	if x != nil {
		return x.Htlcs
	}
	return nil
}

func (x *Payment) GetPaymentIndex() uint64 {
	if x != nil {
		return x.PaymentIndex
	}
	return 0
}

func (x *Payment) GetFailureReason() PaymentFailureReason {
	if x != nil {
		return x.FailureReason
	}
	return PaymentFailureReason_FAILURE_REASON_NONE
}

func (x *Payment) GetFirstHopCustomRecords() map[uint64][]byte {
	if x != nil {
		return x.FirstHopCustomRecords
	}
	return nil
}

type HTLCAttempt struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique ID that is used for this attempt.
	AttemptId uint64 `protobuf:"varint,7,opt,name=attempt_id,json=attemptId,proto3" json:"attempt_id,omitempty"`
	// The status of the HTLC.
	Status HTLCAttempt_HTLCStatus `protobuf:"varint,1,opt,name=status,proto3,enum=lnrpc.HTLCAttempt_HTLCStatus" json:"status,omitempty"`
	// The route taken by this HTLC.
	Route *Route `protobuf:"bytes,2,opt,name=route,proto3" json:"route,omitempty"`
	// The time in UNIX nanoseconds at which this HTLC was sent.
	AttemptTimeNs int64 `protobuf:"varint,3,opt,name=attempt_time_ns,json=attemptTimeNs,proto3" json:"attempt_time_ns,omitempty"`
	// The time in UNIX nanoseconds at which this HTLC was settled or failed.
	// This value will not be set if the HTLC is still IN_FLIGHT.
	ResolveTimeNs int64 `protobuf:"varint,4,opt,name=resolve_time_ns,json=resolveTimeNs,proto3" json:"resolve_time_ns,omitempty"`
	// Detailed htlc failure info.
	Failure *Failure `protobuf:"bytes,5,opt,name=failure,proto3" json:"failure,omitempty"`
	// The preimage that was used to settle the HTLC.
	Preimage      []byte `protobuf:"bytes,6,opt,name=preimage,proto3" json:"preimage,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HTLCAttempt) Reset() {
	*x = HTLCAttempt{}
	mi := &file_lightning_proto_msgTypes[151]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTLCAttempt) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTLCAttempt) ProtoMessage() {}

func (x *HTLCAttempt) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[151]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTLCAttempt.ProtoReflect.Descriptor instead.
func (*HTLCAttempt) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{151}
}

func (x *HTLCAttempt) GetAttemptId() uint64 {
	if x != nil {
		return x.AttemptId
	}
	return 0
}

func (x *HTLCAttempt) GetStatus() HTLCAttempt_HTLCStatus {
	if x != nil {
		return x.Status
	}
	return HTLCAttempt_IN_FLIGHT
}

func (x *HTLCAttempt) GetRoute() *Route {
	if x != nil {
		return x.Route
	}
	return nil
}

func (x *HTLCAttempt) GetAttemptTimeNs() int64 {
	if x != nil {
		return x.AttemptTimeNs
	}
	return 0
}

func (x *HTLCAttempt) GetResolveTimeNs() int64 {
	if x != nil {
		return x.ResolveTimeNs
	}
	return 0
}

func (x *HTLCAttempt) GetFailure() *Failure {
	if x != nil {
		return x.Failure
	}
	return nil
}

func (x *HTLCAttempt) GetPreimage() []byte {
	if x != nil {
		return x.Preimage
	}
	return nil
}

type ListPaymentsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If true, then return payments that have not yet fully completed. This means
	// that pending payments, as well as failed payments will show up if this
	// field is set to true. This flag doesn't change the meaning of the indices,
	// which are tied to individual payments.
	IncludeIncomplete bool `protobuf:"varint,1,opt,name=include_incomplete,json=includeIncomplete,proto3" json:"include_incomplete,omitempty"`
	// The index of a payment that will be used as either the start or end of a
	// query to determine which payments should be returned in the response. The
	// index_offset is exclusive. In the case of a zero index_offset, the query
	// will start with the oldest payment when paginating forwards, or will end
	// with the most recent payment when paginating backwards.
	IndexOffset uint64 `protobuf:"varint,2,opt,name=index_offset,json=indexOffset,proto3" json:"index_offset,omitempty"`
	// The maximal number of payments returned in the response to this query.
	MaxPayments uint64 `protobuf:"varint,3,opt,name=max_payments,json=maxPayments,proto3" json:"max_payments,omitempty"`
	// If set, the payments returned will result from seeking backwards from the
	// specified index offset. This can be used to paginate backwards. The order
	// of the returned payments is always oldest first (ascending index order).
	Reversed bool `protobuf:"varint,4,opt,name=reversed,proto3" json:"reversed,omitempty"`
	// If set, all payments (complete and incomplete, independent of the
	// max_payments parameter) will be counted. Note that setting this to true will
	// increase the run time of the call significantly on systems that have a lot
	// of payments, as all of them have to be iterated through to be counted.
	CountTotalPayments bool `protobuf:"varint,5,opt,name=count_total_payments,json=countTotalPayments,proto3" json:"count_total_payments,omitempty"`
	// If set, returns all payments with a creation date greater than or equal
	// to it. Measured in seconds since the unix epoch.
	CreationDateStart uint64 `protobuf:"varint,6,opt,name=creation_date_start,json=creationDateStart,proto3" json:"creation_date_start,omitempty"`
	// If set, returns all payments with a creation date less than or equal to
	// it. Measured in seconds since the unix epoch.
	CreationDateEnd uint64 `protobuf:"varint,7,opt,name=creation_date_end,json=creationDateEnd,proto3" json:"creation_date_end,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ListPaymentsRequest) Reset() {
	*x = ListPaymentsRequest{}
	mi := &file_lightning_proto_msgTypes[152]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPaymentsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPaymentsRequest) ProtoMessage() {}

func (x *ListPaymentsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[152]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPaymentsRequest.ProtoReflect.Descriptor instead.
func (*ListPaymentsRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{152}
}

func (x *ListPaymentsRequest) GetIncludeIncomplete() bool {
	if x != nil {
		return x.IncludeIncomplete
	}
	return false
}

func (x *ListPaymentsRequest) GetIndexOffset() uint64 {
	if x != nil {
		return x.IndexOffset
	}
	return 0
}

func (x *ListPaymentsRequest) GetMaxPayments() uint64 {
	if x != nil {
		return x.MaxPayments
	}
	return 0
}

func (x *ListPaymentsRequest) GetReversed() bool {
	if x != nil {
		return x.Reversed
	}
	return false
}

func (x *ListPaymentsRequest) GetCountTotalPayments() bool {
	if x != nil {
		return x.CountTotalPayments
	}
	return false
}

func (x *ListPaymentsRequest) GetCreationDateStart() uint64 {
	if x != nil {
		return x.CreationDateStart
	}
	return 0
}

func (x *ListPaymentsRequest) GetCreationDateEnd() uint64 {
	if x != nil {
		return x.CreationDateEnd
	}
	return 0
}

type ListPaymentsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The list of payments
	Payments []*Payment `protobuf:"bytes,1,rep,name=payments,proto3" json:"payments,omitempty"`
	// The index of the first item in the set of returned payments. This can be
	// used as the index_offset to continue seeking backwards in the next request.
	FirstIndexOffset uint64 `protobuf:"varint,2,opt,name=first_index_offset,json=firstIndexOffset,proto3" json:"first_index_offset,omitempty"`
	// The index of the last item in the set of returned payments. This can be used
	// as the index_offset to continue seeking forwards in the next request.
	LastIndexOffset uint64 `protobuf:"varint,3,opt,name=last_index_offset,json=lastIndexOffset,proto3" json:"last_index_offset,omitempty"`
	// Will only be set if count_total_payments in the request was set. Represents
	// the total number of payments (complete and incomplete, independent of the
	// number of payments requested in the query) currently present in the payments
	// database.
	TotalNumPayments uint64 `protobuf:"varint,4,opt,name=total_num_payments,json=totalNumPayments,proto3" json:"total_num_payments,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ListPaymentsResponse) Reset() {
	*x = ListPaymentsResponse{}
	mi := &file_lightning_proto_msgTypes[153]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPaymentsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPaymentsResponse) ProtoMessage() {}

func (x *ListPaymentsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[153]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPaymentsResponse.ProtoReflect.Descriptor instead.
func (*ListPaymentsResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{153}
}

func (x *ListPaymentsResponse) GetPayments() []*Payment {
	if x != nil {
		return x.Payments
	}
	return nil
}

func (x *ListPaymentsResponse) GetFirstIndexOffset() uint64 {
	if x != nil {
		return x.FirstIndexOffset
	}
	return 0
}

func (x *ListPaymentsResponse) GetLastIndexOffset() uint64 {
	if x != nil {
		return x.LastIndexOffset
	}
	return 0
}

func (x *ListPaymentsResponse) GetTotalNumPayments() uint64 {
	if x != nil {
		return x.TotalNumPayments
	}
	return 0
}

type DeletePaymentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Payment hash to delete.
	PaymentHash []byte `protobuf:"bytes,1,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	// Only delete failed HTLCs from the payment, not the payment itself.
	FailedHtlcsOnly bool `protobuf:"varint,2,opt,name=failed_htlcs_only,json=failedHtlcsOnly,proto3" json:"failed_htlcs_only,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DeletePaymentRequest) Reset() {
	*x = DeletePaymentRequest{}
	mi := &file_lightning_proto_msgTypes[154]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeletePaymentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeletePaymentRequest) ProtoMessage() {}

func (x *DeletePaymentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[154]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeletePaymentRequest.ProtoReflect.Descriptor instead.
func (*DeletePaymentRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{154}
}

func (x *DeletePaymentRequest) GetPaymentHash() []byte {
	if x != nil {
		return x.PaymentHash
	}
	return nil
}

func (x *DeletePaymentRequest) GetFailedHtlcsOnly() bool {
	if x != nil {
		return x.FailedHtlcsOnly
	}
	return false
}

type DeleteAllPaymentsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Only delete failed payments.
	FailedPaymentsOnly bool `protobuf:"varint,1,opt,name=failed_payments_only,json=failedPaymentsOnly,proto3" json:"failed_payments_only,omitempty"`
	// Only delete failed HTLCs from payments, not the payment itself.
	FailedHtlcsOnly bool `protobuf:"varint,2,opt,name=failed_htlcs_only,json=failedHtlcsOnly,proto3" json:"failed_htlcs_only,omitempty"`
	// Delete all payments. NOTE: Using this option requires careful
	// consideration as it is a destructive operation.
	AllPayments   bool `protobuf:"varint,3,opt,name=all_payments,json=allPayments,proto3" json:"all_payments,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteAllPaymentsRequest) Reset() {
	*x = DeleteAllPaymentsRequest{}
	mi := &file_lightning_proto_msgTypes[155]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteAllPaymentsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteAllPaymentsRequest) ProtoMessage() {}

func (x *DeleteAllPaymentsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[155]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteAllPaymentsRequest.ProtoReflect.Descriptor instead.
func (*DeleteAllPaymentsRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{155}
}

func (x *DeleteAllPaymentsRequest) GetFailedPaymentsOnly() bool {
	if x != nil {
		return x.FailedPaymentsOnly
	}
	return false
}

func (x *DeleteAllPaymentsRequest) GetFailedHtlcsOnly() bool {
	if x != nil {
		return x.FailedHtlcsOnly
	}
	return false
}

func (x *DeleteAllPaymentsRequest) GetAllPayments() bool {
	if x != nil {
		return x.AllPayments
	}
	return false
}

type DeletePaymentResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The status of the delete operation.
	Status        string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeletePaymentResponse) Reset() {
	*x = DeletePaymentResponse{}
	mi := &file_lightning_proto_msgTypes[156]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeletePaymentResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeletePaymentResponse) ProtoMessage() {}

func (x *DeletePaymentResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[156]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeletePaymentResponse.ProtoReflect.Descriptor instead.
func (*DeletePaymentResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{156}
}

func (x *DeletePaymentResponse) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

type DeleteAllPaymentsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The status of the delete operation.
	Status        string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteAllPaymentsResponse) Reset() {
	*x = DeleteAllPaymentsResponse{}
	mi := &file_lightning_proto_msgTypes[157]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteAllPaymentsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteAllPaymentsResponse) ProtoMessage() {}

func (x *DeleteAllPaymentsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[157]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteAllPaymentsResponse.ProtoReflect.Descriptor instead.
func (*DeleteAllPaymentsResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{157}
}

func (x *DeleteAllPaymentsResponse) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

type AbandonChannelRequest struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	ChannelPoint           *ChannelPoint          `protobuf:"bytes,1,opt,name=channel_point,json=channelPoint,proto3" json:"channel_point,omitempty"`
	PendingFundingShimOnly bool                   `protobuf:"varint,2,opt,name=pending_funding_shim_only,json=pendingFundingShimOnly,proto3" json:"pending_funding_shim_only,omitempty"`
	// Override the requirement for being in dev mode by setting this to true and
	// confirming the user knows what they are doing and this is a potential foot
	// gun to lose funds if used on active channels.
	IKnowWhatIAmDoing bool `protobuf:"varint,3,opt,name=i_know_what_i_am_doing,json=iKnowWhatIAmDoing,proto3" json:"i_know_what_i_am_doing,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *AbandonChannelRequest) Reset() {
	*x = AbandonChannelRequest{}
	mi := &file_lightning_proto_msgTypes[158]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AbandonChannelRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AbandonChannelRequest) ProtoMessage() {}

func (x *AbandonChannelRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[158]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AbandonChannelRequest.ProtoReflect.Descriptor instead.
func (*AbandonChannelRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{158}
}

func (x *AbandonChannelRequest) GetChannelPoint() *ChannelPoint {
	if x != nil {
		return x.ChannelPoint
	}
	return nil
}

func (x *AbandonChannelRequest) GetPendingFundingShimOnly() bool {
	if x != nil {
		return x.PendingFundingShimOnly
	}
	return false
}

func (x *AbandonChannelRequest) GetIKnowWhatIAmDoing() bool {
	if x != nil {
		return x.IKnowWhatIAmDoing
	}
	return false
}

type AbandonChannelResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The status of the abandon operation.
	Status        string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AbandonChannelResponse) Reset() {
	*x = AbandonChannelResponse{}
	mi := &file_lightning_proto_msgTypes[159]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AbandonChannelResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AbandonChannelResponse) ProtoMessage() {}

func (x *AbandonChannelResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[159]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AbandonChannelResponse.ProtoReflect.Descriptor instead.
func (*AbandonChannelResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{159}
}

func (x *AbandonChannelResponse) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

type DebugLevelRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Show          bool                   `protobuf:"varint,1,opt,name=show,proto3" json:"show,omitempty"`
	LevelSpec     string                 `protobuf:"bytes,2,opt,name=level_spec,json=levelSpec,proto3" json:"level_spec,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DebugLevelRequest) Reset() {
	*x = DebugLevelRequest{}
	mi := &file_lightning_proto_msgTypes[160]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DebugLevelRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DebugLevelRequest) ProtoMessage() {}

func (x *DebugLevelRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[160]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DebugLevelRequest.ProtoReflect.Descriptor instead.
func (*DebugLevelRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{160}
}

func (x *DebugLevelRequest) GetShow() bool {
	if x != nil {
		return x.Show
	}
	return false
}

func (x *DebugLevelRequest) GetLevelSpec() string {
	if x != nil {
		return x.LevelSpec
	}
	return ""
}

type DebugLevelResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SubSystems    string                 `protobuf:"bytes,1,opt,name=sub_systems,json=subSystems,proto3" json:"sub_systems,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DebugLevelResponse) Reset() {
	*x = DebugLevelResponse{}
	mi := &file_lightning_proto_msgTypes[161]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DebugLevelResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DebugLevelResponse) ProtoMessage() {}

func (x *DebugLevelResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[161]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DebugLevelResponse.ProtoReflect.Descriptor instead.
func (*DebugLevelResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{161}
}

func (x *DebugLevelResponse) GetSubSystems() string {
	if x != nil {
		return x.SubSystems
	}
	return ""
}

type PayReqString struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The payment request string to be decoded
	PayReq        string `protobuf:"bytes,1,opt,name=pay_req,json=payReq,proto3" json:"pay_req,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PayReqString) Reset() {
	*x = PayReqString{}
	mi := &file_lightning_proto_msgTypes[162]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PayReqString) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PayReqString) ProtoMessage() {}

func (x *PayReqString) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[162]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PayReqString.ProtoReflect.Descriptor instead.
func (*PayReqString) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{162}
}

func (x *PayReqString) GetPayReq() string {
	if x != nil {
		return x.PayReq
	}
	return ""
}

type PayReq struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Destination     string                 `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	PaymentHash     string                 `protobuf:"bytes,2,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	NumSatoshis     int64                  `protobuf:"varint,3,opt,name=num_satoshis,json=numSatoshis,proto3" json:"num_satoshis,omitempty"`
	Timestamp       int64                  `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Expiry          int64                  `protobuf:"varint,5,opt,name=expiry,proto3" json:"expiry,omitempty"`
	Description     string                 `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	DescriptionHash string                 `protobuf:"bytes,7,opt,name=description_hash,json=descriptionHash,proto3" json:"description_hash,omitempty"`
	FallbackAddr    string                 `protobuf:"bytes,8,opt,name=fallback_addr,json=fallbackAddr,proto3" json:"fallback_addr,omitempty"`
	CltvExpiry      int64                  `protobuf:"varint,9,opt,name=cltv_expiry,json=cltvExpiry,proto3" json:"cltv_expiry,omitempty"`
	RouteHints      []*RouteHint           `protobuf:"bytes,10,rep,name=route_hints,json=routeHints,proto3" json:"route_hints,omitempty"`
	PaymentAddr     []byte                 `protobuf:"bytes,11,opt,name=payment_addr,json=paymentAddr,proto3" json:"payment_addr,omitempty"`
	NumMsat         int64                  `protobuf:"varint,12,opt,name=num_msat,json=numMsat,proto3" json:"num_msat,omitempty"`
	Features        map[uint32]*Feature    `protobuf:"bytes,13,rep,name=features,proto3" json:"features,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	BlindedPaths    []*BlindedPaymentPath  `protobuf:"bytes,14,rep,name=blinded_paths,json=blindedPaths,proto3" json:"blinded_paths,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PayReq) Reset() {
	*x = PayReq{}
	mi := &file_lightning_proto_msgTypes[163]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PayReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PayReq) ProtoMessage() {}

func (x *PayReq) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[163]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PayReq.ProtoReflect.Descriptor instead.
func (*PayReq) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{163}
}

func (x *PayReq) GetDestination() string {
	if x != nil {
		return x.Destination
	}
	return ""
}

func (x *PayReq) GetPaymentHash() string {
	if x != nil {
		return x.PaymentHash
	}
	return ""
}

func (x *PayReq) GetNumSatoshis() int64 {
	if x != nil {
		return x.NumSatoshis
	}
	return 0
}

func (x *PayReq) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *PayReq) GetExpiry() int64 {
	if x != nil {
		return x.Expiry
	}
	return 0
}

func (x *PayReq) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *PayReq) GetDescriptionHash() string {
	if x != nil {
		return x.DescriptionHash
	}
	return ""
}

func (x *PayReq) GetFallbackAddr() string {
	if x != nil {
		return x.FallbackAddr
	}
	return ""
}

func (x *PayReq) GetCltvExpiry() int64 {
	if x != nil {
		return x.CltvExpiry
	}
	return 0
}

func (x *PayReq) GetRouteHints() []*RouteHint {
	if x != nil {
		return x.RouteHints
	}
	return nil
}

func (x *PayReq) GetPaymentAddr() []byte {
	if x != nil {
		return x.PaymentAddr
	}
	return nil
}

func (x *PayReq) GetNumMsat() int64 {
	if x != nil {
		return x.NumMsat
	}
	return 0
}

func (x *PayReq) GetFeatures() map[uint32]*Feature {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *PayReq) GetBlindedPaths() []*BlindedPaymentPath {
	if x != nil {
		return x.BlindedPaths
	}
	return nil
}

type Feature struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	IsRequired    bool                   `protobuf:"varint,3,opt,name=is_required,json=isRequired,proto3" json:"is_required,omitempty"`
	IsKnown       bool                   `protobuf:"varint,4,opt,name=is_known,json=isKnown,proto3" json:"is_known,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Feature) Reset() {
	*x = Feature{}
	mi := &file_lightning_proto_msgTypes[164]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Feature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Feature) ProtoMessage() {}

func (x *Feature) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[164]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Feature.ProtoReflect.Descriptor instead.
func (*Feature) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{164}
}

func (x *Feature) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Feature) GetIsRequired() bool {
	if x != nil {
		return x.IsRequired
	}
	return false
}

func (x *Feature) GetIsKnown() bool {
	if x != nil {
		return x.IsKnown
	}
	return false
}

type FeeReportRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FeeReportRequest) Reset() {
	*x = FeeReportRequest{}
	mi := &file_lightning_proto_msgTypes[165]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FeeReportRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FeeReportRequest) ProtoMessage() {}

func (x *FeeReportRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[165]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FeeReportRequest.ProtoReflect.Descriptor instead.
func (*FeeReportRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{165}
}

type ChannelFeeReport struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The short channel id that this fee report belongs to.
	ChanId uint64 `protobuf:"varint,5,opt,name=chan_id,json=chanId,proto3" json:"chan_id,omitempty"`
	// The channel that this fee report belongs to.
	ChannelPoint string `protobuf:"bytes,1,opt,name=channel_point,json=channelPoint,proto3" json:"channel_point,omitempty"`
	// The base fee charged regardless of the number of milli-satoshis sent.
	BaseFeeMsat int64 `protobuf:"varint,2,opt,name=base_fee_msat,json=baseFeeMsat,proto3" json:"base_fee_msat,omitempty"`
	// The amount charged per milli-satoshis transferred expressed in
	// millionths of a satoshi.
	FeePerMil int64 `protobuf:"varint,3,opt,name=fee_per_mil,json=feePerMil,proto3" json:"fee_per_mil,omitempty"`
	// The effective fee rate in milli-satoshis. Computed by dividing the
	// fee_per_mil value by 1 million.
	FeeRate float64 `protobuf:"fixed64,4,opt,name=fee_rate,json=feeRate,proto3" json:"fee_rate,omitempty"`
	// The base fee charged regardless of the number of milli-satoshis sent.
	InboundBaseFeeMsat int32 `protobuf:"varint,6,opt,name=inbound_base_fee_msat,json=inboundBaseFeeMsat,proto3" json:"inbound_base_fee_msat,omitempty"`
	// The amount charged per milli-satoshis transferred expressed in
	// millionths of a satoshi.
	InboundFeePerMil int32 `protobuf:"varint,7,opt,name=inbound_fee_per_mil,json=inboundFeePerMil,proto3" json:"inbound_fee_per_mil,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ChannelFeeReport) Reset() {
	*x = ChannelFeeReport{}
	mi := &file_lightning_proto_msgTypes[166]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelFeeReport) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelFeeReport) ProtoMessage() {}

func (x *ChannelFeeReport) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[166]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelFeeReport.ProtoReflect.Descriptor instead.
func (*ChannelFeeReport) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{166}
}

func (x *ChannelFeeReport) GetChanId() uint64 {
	if x != nil {
		return x.ChanId
	}
	return 0
}

func (x *ChannelFeeReport) GetChannelPoint() string {
	if x != nil {
		return x.ChannelPoint
	}
	return ""
}

func (x *ChannelFeeReport) GetBaseFeeMsat() int64 {
	if x != nil {
		return x.BaseFeeMsat
	}
	return 0
}

func (x *ChannelFeeReport) GetFeePerMil() int64 {
	if x != nil {
		return x.FeePerMil
	}
	return 0
}

func (x *ChannelFeeReport) GetFeeRate() float64 {
	if x != nil {
		return x.FeeRate
	}
	return 0
}

func (x *ChannelFeeReport) GetInboundBaseFeeMsat() int32 {
	if x != nil {
		return x.InboundBaseFeeMsat
	}
	return 0
}

func (x *ChannelFeeReport) GetInboundFeePerMil() int32 {
	if x != nil {
		return x.InboundFeePerMil
	}
	return 0
}

type FeeReportResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// An array of channel fee reports which describes the current fee schedule
	// for each channel.
	ChannelFees []*ChannelFeeReport `protobuf:"bytes,1,rep,name=channel_fees,json=channelFees,proto3" json:"channel_fees,omitempty"`
	// The total amount of fee revenue (in satoshis) the switch has collected
	// over the past 24 hrs.
	DayFeeSum uint64 `protobuf:"varint,2,opt,name=day_fee_sum,json=dayFeeSum,proto3" json:"day_fee_sum,omitempty"`
	// The total amount of fee revenue (in satoshis) the switch has collected
	// over the past 1 week.
	WeekFeeSum uint64 `protobuf:"varint,3,opt,name=week_fee_sum,json=weekFeeSum,proto3" json:"week_fee_sum,omitempty"`
	// The total amount of fee revenue (in satoshis) the switch has collected
	// over the past 1 month.
	MonthFeeSum   uint64 `protobuf:"varint,4,opt,name=month_fee_sum,json=monthFeeSum,proto3" json:"month_fee_sum,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FeeReportResponse) Reset() {
	*x = FeeReportResponse{}
	mi := &file_lightning_proto_msgTypes[167]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FeeReportResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FeeReportResponse) ProtoMessage() {}

func (x *FeeReportResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[167]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FeeReportResponse.ProtoReflect.Descriptor instead.
func (*FeeReportResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{167}
}

func (x *FeeReportResponse) GetChannelFees() []*ChannelFeeReport {
	if x != nil {
		return x.ChannelFees
	}
	return nil
}

func (x *FeeReportResponse) GetDayFeeSum() uint64 {
	if x != nil {
		return x.DayFeeSum
	}
	return 0
}

func (x *FeeReportResponse) GetWeekFeeSum() uint64 {
	if x != nil {
		return x.WeekFeeSum
	}
	return 0
}

func (x *FeeReportResponse) GetMonthFeeSum() uint64 {
	if x != nil {
		return x.MonthFeeSum
	}
	return 0
}

type InboundFee struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The inbound base fee charged regardless of the number of milli-satoshis
	// received in the channel. By default, only negative values are accepted.
	BaseFeeMsat int32 `protobuf:"varint,1,opt,name=base_fee_msat,json=baseFeeMsat,proto3" json:"base_fee_msat,omitempty"`
	// The effective inbound fee rate in micro-satoshis (parts per million).
	// By default, only negative values are accepted.
	FeeRatePpm    int32 `protobuf:"varint,2,opt,name=fee_rate_ppm,json=feeRatePpm,proto3" json:"fee_rate_ppm,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InboundFee) Reset() {
	*x = InboundFee{}
	mi := &file_lightning_proto_msgTypes[168]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InboundFee) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InboundFee) ProtoMessage() {}

func (x *InboundFee) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[168]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InboundFee.ProtoReflect.Descriptor instead.
func (*InboundFee) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{168}
}

func (x *InboundFee) GetBaseFeeMsat() int32 {
	if x != nil {
		return x.BaseFeeMsat
	}
	return 0
}

func (x *InboundFee) GetFeeRatePpm() int32 {
	if x != nil {
		return x.FeeRatePpm
	}
	return 0
}

type PolicyUpdateRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Scope:
	//
	//	*PolicyUpdateRequest_Global
	//	*PolicyUpdateRequest_ChanPoint
	Scope isPolicyUpdateRequest_Scope `protobuf_oneof:"scope"`
	// The base fee charged regardless of the number of milli-satoshis sent.
	BaseFeeMsat int64 `protobuf:"varint,3,opt,name=base_fee_msat,json=baseFeeMsat,proto3" json:"base_fee_msat,omitempty"`
	// The effective fee rate in milli-satoshis. The precision of this value
	// goes up to 6 decimal places, so 1e-6.
	FeeRate float64 `protobuf:"fixed64,4,opt,name=fee_rate,json=feeRate,proto3" json:"fee_rate,omitempty"`
	// The effective fee rate in micro-satoshis (parts per million).
	FeeRatePpm uint32 `protobuf:"varint,9,opt,name=fee_rate_ppm,json=feeRatePpm,proto3" json:"fee_rate_ppm,omitempty"`
	// The required timelock delta for HTLCs forwarded over the channel.
	TimeLockDelta uint32 `protobuf:"varint,5,opt,name=time_lock_delta,json=timeLockDelta,proto3" json:"time_lock_delta,omitempty"`
	// If set, the maximum HTLC size in milli-satoshis. If unset, the maximum
	// HTLC will be unchanged.
	MaxHtlcMsat uint64 `protobuf:"varint,6,opt,name=max_htlc_msat,json=maxHtlcMsat,proto3" json:"max_htlc_msat,omitempty"`
	// The minimum HTLC size in milli-satoshis. Only applied if
	// min_htlc_msat_specified is true.
	MinHtlcMsat uint64 `protobuf:"varint,7,opt,name=min_htlc_msat,json=minHtlcMsat,proto3" json:"min_htlc_msat,omitempty"`
	// If true, min_htlc_msat is applied.
	MinHtlcMsatSpecified bool `protobuf:"varint,8,opt,name=min_htlc_msat_specified,json=minHtlcMsatSpecified,proto3" json:"min_htlc_msat_specified,omitempty"`
	// Optional inbound fee. If unset, the previously set value will be
	// retained [EXPERIMENTAL].
	InboundFee *InboundFee `protobuf:"bytes,10,opt,name=inbound_fee,json=inboundFee,proto3" json:"inbound_fee,omitempty"`
	// Under unknown circumstances a channel can exist with a missing edge in
	// the graph database. This can cause an 'edge not found' error when calling
	// `getchaninfo` and/or cause the default channel policy to be used during
	// forwards. Setting this flag will recreate the edge if not found, allowing
	// updating this channel policy and fixing the missing edge problem for this
	// channel permanently. For fields not set in this command, the default
	// policy will be created.
	CreateMissingEdge bool `protobuf:"varint,11,opt,name=create_missing_edge,json=createMissingEdge,proto3" json:"create_missing_edge,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *PolicyUpdateRequest) Reset() {
	*x = PolicyUpdateRequest{}
	mi := &file_lightning_proto_msgTypes[169]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PolicyUpdateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PolicyUpdateRequest) ProtoMessage() {}

func (x *PolicyUpdateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[169]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PolicyUpdateRequest.ProtoReflect.Descriptor instead.
func (*PolicyUpdateRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{169}
}

func (x *PolicyUpdateRequest) GetScope() isPolicyUpdateRequest_Scope {
	if x != nil {
		return x.Scope
	}
	return nil
}

func (x *PolicyUpdateRequest) GetGlobal() bool {
	if x != nil {
		if x, ok := x.Scope.(*PolicyUpdateRequest_Global); ok {
			return x.Global
		}
	}
	return false
}

func (x *PolicyUpdateRequest) GetChanPoint() *ChannelPoint {
	if x != nil {
		if x, ok := x.Scope.(*PolicyUpdateRequest_ChanPoint); ok {
			return x.ChanPoint
		}
	}
	return nil
}

func (x *PolicyUpdateRequest) GetBaseFeeMsat() int64 {
	if x != nil {
		return x.BaseFeeMsat
	}
	return 0
}

func (x *PolicyUpdateRequest) GetFeeRate() float64 {
	if x != nil {
		return x.FeeRate
	}
	return 0
}

func (x *PolicyUpdateRequest) GetFeeRatePpm() uint32 {
	if x != nil {
		return x.FeeRatePpm
	}
	return 0
}

func (x *PolicyUpdateRequest) GetTimeLockDelta() uint32 {
	if x != nil {
		return x.TimeLockDelta
	}
	return 0
}

func (x *PolicyUpdateRequest) GetMaxHtlcMsat() uint64 {
	if x != nil {
		return x.MaxHtlcMsat
	}
	return 0
}

func (x *PolicyUpdateRequest) GetMinHtlcMsat() uint64 {
	if x != nil {
		return x.MinHtlcMsat
	}
	return 0
}

func (x *PolicyUpdateRequest) GetMinHtlcMsatSpecified() bool {
	if x != nil {
		return x.MinHtlcMsatSpecified
	}
	return false
}

func (x *PolicyUpdateRequest) GetInboundFee() *InboundFee {
	if x != nil {
		return x.InboundFee
	}
	return nil
}

func (x *PolicyUpdateRequest) GetCreateMissingEdge() bool {
	if x != nil {
		return x.CreateMissingEdge
	}
	return false
}

type isPolicyUpdateRequest_Scope interface {
	isPolicyUpdateRequest_Scope()
}

type PolicyUpdateRequest_Global struct {
	// If set, then this update applies to all currently active channels.
	Global bool `protobuf:"varint,1,opt,name=global,proto3,oneof"`
}

type PolicyUpdateRequest_ChanPoint struct {
	// If set, this update will target a specific channel.
	ChanPoint *ChannelPoint `protobuf:"bytes,2,opt,name=chan_point,json=chanPoint,proto3,oneof"`
}

func (*PolicyUpdateRequest_Global) isPolicyUpdateRequest_Scope() {}

func (*PolicyUpdateRequest_ChanPoint) isPolicyUpdateRequest_Scope() {}

type FailedUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The outpoint in format txid:n
	Outpoint *OutPoint `protobuf:"bytes,1,opt,name=outpoint,proto3" json:"outpoint,omitempty"`
	// Reason for the policy update failure.
	Reason UpdateFailure `protobuf:"varint,2,opt,name=reason,proto3,enum=lnrpc.UpdateFailure" json:"reason,omitempty"`
	// A string representation of the policy update error.
	UpdateError   string `protobuf:"bytes,3,opt,name=update_error,json=updateError,proto3" json:"update_error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FailedUpdate) Reset() {
	*x = FailedUpdate{}
	mi := &file_lightning_proto_msgTypes[170]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FailedUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FailedUpdate) ProtoMessage() {}

func (x *FailedUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[170]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FailedUpdate.ProtoReflect.Descriptor instead.
func (*FailedUpdate) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{170}
}

func (x *FailedUpdate) GetOutpoint() *OutPoint {
	if x != nil {
		return x.Outpoint
	}
	return nil
}

func (x *FailedUpdate) GetReason() UpdateFailure {
	if x != nil {
		return x.Reason
	}
	return UpdateFailure_UPDATE_FAILURE_UNKNOWN
}

func (x *FailedUpdate) GetUpdateError() string {
	if x != nil {
		return x.UpdateError
	}
	return ""
}

type PolicyUpdateResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of failed policy updates.
	FailedUpdates []*FailedUpdate `protobuf:"bytes,1,rep,name=failed_updates,json=failedUpdates,proto3" json:"failed_updates,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PolicyUpdateResponse) Reset() {
	*x = PolicyUpdateResponse{}
	mi := &file_lightning_proto_msgTypes[171]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PolicyUpdateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PolicyUpdateResponse) ProtoMessage() {}

func (x *PolicyUpdateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[171]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PolicyUpdateResponse.ProtoReflect.Descriptor instead.
func (*PolicyUpdateResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{171}
}

func (x *PolicyUpdateResponse) GetFailedUpdates() []*FailedUpdate {
	if x != nil {
		return x.FailedUpdates
	}
	return nil
}

type ForwardingHistoryRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Start time is the starting point of the forwarding history request. All
	// records beyond this point will be included, respecting the end time, and
	// the index offset.
	StartTime uint64 `protobuf:"varint,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// End time is the end point of the forwarding history request. The
	// response will carry at most 50k records between the start time and the
	// end time. The index offset can be used to implement pagination.
	EndTime uint64 `protobuf:"varint,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// Index offset is the offset in the time series to start at. As each
	// response can only contain 50k records, callers can use this to skip
	// around within a packed time series.
	IndexOffset uint32 `protobuf:"varint,3,opt,name=index_offset,json=indexOffset,proto3" json:"index_offset,omitempty"`
	// The max number of events to return in the response to this query.
	NumMaxEvents uint32 `protobuf:"varint,4,opt,name=num_max_events,json=numMaxEvents,proto3" json:"num_max_events,omitempty"`
	// Informs the server if the peer alias should be looked up for each
	// forwarding event.
	PeerAliasLookup bool `protobuf:"varint,5,opt,name=peer_alias_lookup,json=peerAliasLookup,proto3" json:"peer_alias_lookup,omitempty"`
	// List of incoming channel ids to filter htlcs received from a
	// particular channel
	IncomingChanIds []uint64 `protobuf:"varint,6,rep,packed,name=incoming_chan_ids,json=incomingChanIds,proto3" json:"incoming_chan_ids,omitempty"`
	// List of outgoing channel ids to filter htlcs being forwarded to a
	// particular channel
	OutgoingChanIds []uint64 `protobuf:"varint,7,rep,packed,name=outgoing_chan_ids,json=outgoingChanIds,proto3" json:"outgoing_chan_ids,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ForwardingHistoryRequest) Reset() {
	*x = ForwardingHistoryRequest{}
	mi := &file_lightning_proto_msgTypes[172]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ForwardingHistoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ForwardingHistoryRequest) ProtoMessage() {}

func (x *ForwardingHistoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[172]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ForwardingHistoryRequest.ProtoReflect.Descriptor instead.
func (*ForwardingHistoryRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{172}
}

func (x *ForwardingHistoryRequest) GetStartTime() uint64 {
	if x != nil {
		return x.StartTime
	}
	return 0
}

func (x *ForwardingHistoryRequest) GetEndTime() uint64 {
	if x != nil {
		return x.EndTime
	}
	return 0
}

func (x *ForwardingHistoryRequest) GetIndexOffset() uint32 {
	if x != nil {
		return x.IndexOffset
	}
	return 0
}

func (x *ForwardingHistoryRequest) GetNumMaxEvents() uint32 {
	if x != nil {
		return x.NumMaxEvents
	}
	return 0
}

func (x *ForwardingHistoryRequest) GetPeerAliasLookup() bool {
	if x != nil {
		return x.PeerAliasLookup
	}
	return false
}

func (x *ForwardingHistoryRequest) GetIncomingChanIds() []uint64 {
	if x != nil {
		return x.IncomingChanIds
	}
	return nil
}

func (x *ForwardingHistoryRequest) GetOutgoingChanIds() []uint64 {
	if x != nil {
		return x.OutgoingChanIds
	}
	return nil
}

type ForwardingEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Timestamp is the time (unix epoch offset) that this circuit was
	// completed. Deprecated by timestamp_ns.
	//
	// Deprecated: Marked as deprecated in lightning.proto.
	Timestamp uint64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// The incoming channel ID that carried the HTLC that created the circuit.
	ChanIdIn uint64 `protobuf:"varint,2,opt,name=chan_id_in,json=chanIdIn,proto3" json:"chan_id_in,omitempty"`
	// The outgoing channel ID that carried the preimage that completed the
	// circuit.
	ChanIdOut uint64 `protobuf:"varint,4,opt,name=chan_id_out,json=chanIdOut,proto3" json:"chan_id_out,omitempty"`
	// The total amount (in satoshis) of the incoming HTLC that created half
	// the circuit.
	AmtIn uint64 `protobuf:"varint,5,opt,name=amt_in,json=amtIn,proto3" json:"amt_in,omitempty"`
	// The total amount (in satoshis) of the outgoing HTLC that created the
	// second half of the circuit.
	AmtOut uint64 `protobuf:"varint,6,opt,name=amt_out,json=amtOut,proto3" json:"amt_out,omitempty"`
	// The total fee (in satoshis) that this payment circuit carried.
	Fee uint64 `protobuf:"varint,7,opt,name=fee,proto3" json:"fee,omitempty"`
	// The total fee (in milli-satoshis) that this payment circuit carried.
	FeeMsat uint64 `protobuf:"varint,8,opt,name=fee_msat,json=feeMsat,proto3" json:"fee_msat,omitempty"`
	// The total amount (in milli-satoshis) of the incoming HTLC that created
	// half the circuit.
	AmtInMsat uint64 `protobuf:"varint,9,opt,name=amt_in_msat,json=amtInMsat,proto3" json:"amt_in_msat,omitempty"`
	// The total amount (in milli-satoshis) of the outgoing HTLC that created
	// the second half of the circuit.
	AmtOutMsat uint64 `protobuf:"varint,10,opt,name=amt_out_msat,json=amtOutMsat,proto3" json:"amt_out_msat,omitempty"`
	// The number of nanoseconds elapsed since January 1, 1970 UTC when this
	// circuit was completed.
	TimestampNs uint64 `protobuf:"varint,11,opt,name=timestamp_ns,json=timestampNs,proto3" json:"timestamp_ns,omitempty"`
	// The peer alias of the incoming channel.
	PeerAliasIn string `protobuf:"bytes,12,opt,name=peer_alias_in,json=peerAliasIn,proto3" json:"peer_alias_in,omitempty"`
	// The peer alias of the outgoing channel.
	PeerAliasOut string `protobuf:"bytes,13,opt,name=peer_alias_out,json=peerAliasOut,proto3" json:"peer_alias_out,omitempty"`
	// The ID of the incoming HTLC in the payment circuit. This field is
	// optional and is unset for forwarding events happened before v0.20.
	IncomingHtlcId *uint64 `protobuf:"varint,14,opt,name=incoming_htlc_id,json=incomingHtlcId,proto3,oneof" json:"incoming_htlc_id,omitempty"`
	// The ID of the outgoing HTLC in the payment circuit. This field is
	// optional and may be unset for legacy forwarding events.
	OutgoingHtlcId *uint64 `protobuf:"varint,15,opt,name=outgoing_htlc_id,json=outgoingHtlcId,proto3,oneof" json:"outgoing_htlc_id,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ForwardingEvent) Reset() {
	*x = ForwardingEvent{}
	mi := &file_lightning_proto_msgTypes[173]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ForwardingEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ForwardingEvent) ProtoMessage() {}

func (x *ForwardingEvent) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[173]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ForwardingEvent.ProtoReflect.Descriptor instead.
func (*ForwardingEvent) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{173}
}

// Deprecated: Marked as deprecated in lightning.proto.
func (x *ForwardingEvent) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *ForwardingEvent) GetChanIdIn() uint64 {
	if x != nil {
		return x.ChanIdIn
	}
	return 0
}

func (x *ForwardingEvent) GetChanIdOut() uint64 {
	if x != nil {
		return x.ChanIdOut
	}
	return 0
}

func (x *ForwardingEvent) GetAmtIn() uint64 {
	if x != nil {
		return x.AmtIn
	}
	return 0
}

func (x *ForwardingEvent) GetAmtOut() uint64 {
	if x != nil {
		return x.AmtOut
	}
	return 0
}

func (x *ForwardingEvent) GetFee() uint64 {
	if x != nil {
		return x.Fee
	}
	return 0
}

func (x *ForwardingEvent) GetFeeMsat() uint64 {
	if x != nil {
		return x.FeeMsat
	}
	return 0
}

func (x *ForwardingEvent) GetAmtInMsat() uint64 {
	if x != nil {
		return x.AmtInMsat
	}
	return 0
}

func (x *ForwardingEvent) GetAmtOutMsat() uint64 {
	if x != nil {
		return x.AmtOutMsat
	}
	return 0
}

func (x *ForwardingEvent) GetTimestampNs() uint64 {
	if x != nil {
		return x.TimestampNs
	}
	return 0
}

func (x *ForwardingEvent) GetPeerAliasIn() string {
	if x != nil {
		return x.PeerAliasIn
	}
	return ""
}

func (x *ForwardingEvent) GetPeerAliasOut() string {
	if x != nil {
		return x.PeerAliasOut
	}
	return ""
}

func (x *ForwardingEvent) GetIncomingHtlcId() uint64 {
	if x != nil && x.IncomingHtlcId != nil {
		return *x.IncomingHtlcId
	}
	return 0
}

func (x *ForwardingEvent) GetOutgoingHtlcId() uint64 {
	if x != nil && x.OutgoingHtlcId != nil {
		return *x.OutgoingHtlcId
	}
	return 0
}

type ForwardingHistoryResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of forwarding events from the time slice of the time series
	// specified in the request.
	ForwardingEvents []*ForwardingEvent `protobuf:"bytes,1,rep,name=forwarding_events,json=forwardingEvents,proto3" json:"forwarding_events,omitempty"`
	// The index of the last time in the set of returned forwarding events. Can
	// be used to seek further, pagination style.
	LastOffsetIndex uint32 `protobuf:"varint,2,opt,name=last_offset_index,json=lastOffsetIndex,proto3" json:"last_offset_index,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ForwardingHistoryResponse) Reset() {
	*x = ForwardingHistoryResponse{}
	mi := &file_lightning_proto_msgTypes[174]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ForwardingHistoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ForwardingHistoryResponse) ProtoMessage() {}

func (x *ForwardingHistoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[174]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ForwardingHistoryResponse.ProtoReflect.Descriptor instead.
func (*ForwardingHistoryResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{174}
}

func (x *ForwardingHistoryResponse) GetForwardingEvents() []*ForwardingEvent {
	if x != nil {
		return x.ForwardingEvents
	}
	return nil
}

func (x *ForwardingHistoryResponse) GetLastOffsetIndex() uint32 {
	if x != nil {
		return x.LastOffsetIndex
	}
	return 0
}

type ExportChannelBackupRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The target channel point to obtain a back up for.
	ChanPoint     *ChannelPoint `protobuf:"bytes,1,opt,name=chan_point,json=chanPoint,proto3" json:"chan_point,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExportChannelBackupRequest) Reset() {
	*x = ExportChannelBackupRequest{}
	mi := &file_lightning_proto_msgTypes[175]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExportChannelBackupRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExportChannelBackupRequest) ProtoMessage() {}

func (x *ExportChannelBackupRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[175]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExportChannelBackupRequest.ProtoReflect.Descriptor instead.
func (*ExportChannelBackupRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{175}
}

func (x *ExportChannelBackupRequest) GetChanPoint() *ChannelPoint {
	if x != nil {
		return x.ChanPoint
	}
	return nil
}

type ChannelBackup struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifies the channel that this backup belongs to.
	ChanPoint *ChannelPoint `protobuf:"bytes,1,opt,name=chan_point,json=chanPoint,proto3" json:"chan_point,omitempty"`
	// Is an encrypted single-chan backup. this can be passed to
	// RestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in
	// order to trigger the recovery protocol. When using REST, this field must be
	// encoded as base64.
	ChanBackup    []byte `protobuf:"bytes,2,opt,name=chan_backup,json=chanBackup,proto3" json:"chan_backup,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChannelBackup) Reset() {
	*x = ChannelBackup{}
	mi := &file_lightning_proto_msgTypes[176]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelBackup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelBackup) ProtoMessage() {}

func (x *ChannelBackup) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[176]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelBackup.ProtoReflect.Descriptor instead.
func (*ChannelBackup) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{176}
}

func (x *ChannelBackup) GetChanPoint() *ChannelPoint {
	if x != nil {
		return x.ChanPoint
	}
	return nil
}

func (x *ChannelBackup) GetChanBackup() []byte {
	if x != nil {
		return x.ChanBackup
	}
	return nil
}

type MultiChanBackup struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Is the set of all channels that are included in this multi-channel backup.
	ChanPoints []*ChannelPoint `protobuf:"bytes,1,rep,name=chan_points,json=chanPoints,proto3" json:"chan_points,omitempty"`
	// A single encrypted blob containing all the static channel backups of the
	// channel listed above. This can be stored as a single file or blob, and
	// safely be replaced with any prior/future versions. When using REST, this
	// field must be encoded as base64.
	MultiChanBackup []byte `protobuf:"bytes,2,opt,name=multi_chan_backup,json=multiChanBackup,proto3" json:"multi_chan_backup,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *MultiChanBackup) Reset() {
	*x = MultiChanBackup{}
	mi := &file_lightning_proto_msgTypes[177]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiChanBackup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiChanBackup) ProtoMessage() {}

func (x *MultiChanBackup) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[177]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiChanBackup.ProtoReflect.Descriptor instead.
func (*MultiChanBackup) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{177}
}

func (x *MultiChanBackup) GetChanPoints() []*ChannelPoint {
	if x != nil {
		return x.ChanPoints
	}
	return nil
}

func (x *MultiChanBackup) GetMultiChanBackup() []byte {
	if x != nil {
		return x.MultiChanBackup
	}
	return nil
}

type ChanBackupExportRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChanBackupExportRequest) Reset() {
	*x = ChanBackupExportRequest{}
	mi := &file_lightning_proto_msgTypes[178]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChanBackupExportRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChanBackupExportRequest) ProtoMessage() {}

func (x *ChanBackupExportRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[178]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChanBackupExportRequest.ProtoReflect.Descriptor instead.
func (*ChanBackupExportRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{178}
}

type ChanBackupSnapshot struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The set of new channels that have been added since the last channel backup
	// snapshot was requested.
	SingleChanBackups *ChannelBackups `protobuf:"bytes,1,opt,name=single_chan_backups,json=singleChanBackups,proto3" json:"single_chan_backups,omitempty"`
	// A multi-channel backup that covers all open channels currently known to
	// lnd.
	MultiChanBackup *MultiChanBackup `protobuf:"bytes,2,opt,name=multi_chan_backup,json=multiChanBackup,proto3" json:"multi_chan_backup,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ChanBackupSnapshot) Reset() {
	*x = ChanBackupSnapshot{}
	mi := &file_lightning_proto_msgTypes[179]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChanBackupSnapshot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChanBackupSnapshot) ProtoMessage() {}

func (x *ChanBackupSnapshot) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[179]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChanBackupSnapshot.ProtoReflect.Descriptor instead.
func (*ChanBackupSnapshot) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{179}
}

func (x *ChanBackupSnapshot) GetSingleChanBackups() *ChannelBackups {
	if x != nil {
		return x.SingleChanBackups
	}
	return nil
}

func (x *ChanBackupSnapshot) GetMultiChanBackup() *MultiChanBackup {
	if x != nil {
		return x.MultiChanBackup
	}
	return nil
}

type ChannelBackups struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A set of single-chan static channel backups.
	ChanBackups   []*ChannelBackup `protobuf:"bytes,1,rep,name=chan_backups,json=chanBackups,proto3" json:"chan_backups,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChannelBackups) Reset() {
	*x = ChannelBackups{}
	mi := &file_lightning_proto_msgTypes[180]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelBackups) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelBackups) ProtoMessage() {}

func (x *ChannelBackups) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[180]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelBackups.ProtoReflect.Descriptor instead.
func (*ChannelBackups) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{180}
}

func (x *ChannelBackups) GetChanBackups() []*ChannelBackup {
	if x != nil {
		return x.ChanBackups
	}
	return nil
}

type RestoreChanBackupRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Backup:
	//
	//	*RestoreChanBackupRequest_ChanBackups
	//	*RestoreChanBackupRequest_MultiChanBackup
	Backup        isRestoreChanBackupRequest_Backup `protobuf_oneof:"backup"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RestoreChanBackupRequest) Reset() {
	*x = RestoreChanBackupRequest{}
	mi := &file_lightning_proto_msgTypes[181]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RestoreChanBackupRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RestoreChanBackupRequest) ProtoMessage() {}

func (x *RestoreChanBackupRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[181]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RestoreChanBackupRequest.ProtoReflect.Descriptor instead.
func (*RestoreChanBackupRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{181}
}

func (x *RestoreChanBackupRequest) GetBackup() isRestoreChanBackupRequest_Backup {
	if x != nil {
		return x.Backup
	}
	return nil
}

func (x *RestoreChanBackupRequest) GetChanBackups() *ChannelBackups {
	if x != nil {
		if x, ok := x.Backup.(*RestoreChanBackupRequest_ChanBackups); ok {
			return x.ChanBackups
		}
	}
	return nil
}

func (x *RestoreChanBackupRequest) GetMultiChanBackup() []byte {
	if x != nil {
		if x, ok := x.Backup.(*RestoreChanBackupRequest_MultiChanBackup); ok {
			return x.MultiChanBackup
		}
	}
	return nil
}

type isRestoreChanBackupRequest_Backup interface {
	isRestoreChanBackupRequest_Backup()
}

type RestoreChanBackupRequest_ChanBackups struct {
	// The channels to restore as a list of channel/backup pairs.
	ChanBackups *ChannelBackups `protobuf:"bytes,1,opt,name=chan_backups,json=chanBackups,proto3,oneof"`
}

type RestoreChanBackupRequest_MultiChanBackup struct {
	// The channels to restore in the packed multi backup format. When using
	// REST, this field must be encoded as base64.
	MultiChanBackup []byte `protobuf:"bytes,2,opt,name=multi_chan_backup,json=multiChanBackup,proto3,oneof"`
}

func (*RestoreChanBackupRequest_ChanBackups) isRestoreChanBackupRequest_Backup() {}

func (*RestoreChanBackupRequest_MultiChanBackup) isRestoreChanBackupRequest_Backup() {}

type RestoreBackupResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of channels successfully restored.
	NumRestored   uint32 `protobuf:"varint,1,opt,name=num_restored,json=numRestored,proto3" json:"num_restored,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RestoreBackupResponse) Reset() {
	*x = RestoreBackupResponse{}
	mi := &file_lightning_proto_msgTypes[182]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RestoreBackupResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RestoreBackupResponse) ProtoMessage() {}

func (x *RestoreBackupResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[182]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RestoreBackupResponse.ProtoReflect.Descriptor instead.
func (*RestoreBackupResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{182}
}

func (x *RestoreBackupResponse) GetNumRestored() uint32 {
	if x != nil {
		return x.NumRestored
	}
	return 0
}

type ChannelBackupSubscription struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChannelBackupSubscription) Reset() {
	*x = ChannelBackupSubscription{}
	mi := &file_lightning_proto_msgTypes[183]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelBackupSubscription) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelBackupSubscription) ProtoMessage() {}

func (x *ChannelBackupSubscription) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[183]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelBackupSubscription.ProtoReflect.Descriptor instead.
func (*ChannelBackupSubscription) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{183}
}

type VerifyChanBackupResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ChanPoints    []string               `protobuf:"bytes,1,rep,name=chan_points,json=chanPoints,proto3" json:"chan_points,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VerifyChanBackupResponse) Reset() {
	*x = VerifyChanBackupResponse{}
	mi := &file_lightning_proto_msgTypes[184]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VerifyChanBackupResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerifyChanBackupResponse) ProtoMessage() {}

func (x *VerifyChanBackupResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[184]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VerifyChanBackupResponse.ProtoReflect.Descriptor instead.
func (*VerifyChanBackupResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{184}
}

func (x *VerifyChanBackupResponse) GetChanPoints() []string {
	if x != nil {
		return x.ChanPoints
	}
	return nil
}

type MacaroonPermission struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The entity a permission grants access to.
	Entity string `protobuf:"bytes,1,opt,name=entity,proto3" json:"entity,omitempty"`
	// The action that is granted.
	Action        string `protobuf:"bytes,2,opt,name=action,proto3" json:"action,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MacaroonPermission) Reset() {
	*x = MacaroonPermission{}
	mi := &file_lightning_proto_msgTypes[185]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MacaroonPermission) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MacaroonPermission) ProtoMessage() {}

func (x *MacaroonPermission) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[185]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MacaroonPermission.ProtoReflect.Descriptor instead.
func (*MacaroonPermission) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{185}
}

func (x *MacaroonPermission) GetEntity() string {
	if x != nil {
		return x.Entity
	}
	return ""
}

func (x *MacaroonPermission) GetAction() string {
	if x != nil {
		return x.Action
	}
	return ""
}

type BakeMacaroonRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The list of permissions the new macaroon should grant.
	Permissions []*MacaroonPermission `protobuf:"bytes,1,rep,name=permissions,proto3" json:"permissions,omitempty"`
	// The root key ID used to create the macaroon, must be a positive integer.
	RootKeyId uint64 `protobuf:"varint,2,opt,name=root_key_id,json=rootKeyId,proto3" json:"root_key_id,omitempty"`
	// Informs the RPC on whether to allow external permissions that LND is not
	// aware of.
	AllowExternalPermissions bool `protobuf:"varint,3,opt,name=allow_external_permissions,json=allowExternalPermissions,proto3" json:"allow_external_permissions,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *BakeMacaroonRequest) Reset() {
	*x = BakeMacaroonRequest{}
	mi := &file_lightning_proto_msgTypes[186]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BakeMacaroonRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BakeMacaroonRequest) ProtoMessage() {}

func (x *BakeMacaroonRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[186]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BakeMacaroonRequest.ProtoReflect.Descriptor instead.
func (*BakeMacaroonRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{186}
}

func (x *BakeMacaroonRequest) GetPermissions() []*MacaroonPermission {
	if x != nil {
		return x.Permissions
	}
	return nil
}

func (x *BakeMacaroonRequest) GetRootKeyId() uint64 {
	if x != nil {
		return x.RootKeyId
	}
	return 0
}

func (x *BakeMacaroonRequest) GetAllowExternalPermissions() bool {
	if x != nil {
		return x.AllowExternalPermissions
	}
	return false
}

type BakeMacaroonResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The hex encoded macaroon, serialized in binary format.
	Macaroon      string `protobuf:"bytes,1,opt,name=macaroon,proto3" json:"macaroon,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BakeMacaroonResponse) Reset() {
	*x = BakeMacaroonResponse{}
	mi := &file_lightning_proto_msgTypes[187]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BakeMacaroonResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BakeMacaroonResponse) ProtoMessage() {}

func (x *BakeMacaroonResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[187]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BakeMacaroonResponse.ProtoReflect.Descriptor instead.
func (*BakeMacaroonResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{187}
}

func (x *BakeMacaroonResponse) GetMacaroon() string {
	if x != nil {
		return x.Macaroon
	}
	return ""
}

type ListMacaroonIDsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListMacaroonIDsRequest) Reset() {
	*x = ListMacaroonIDsRequest{}
	mi := &file_lightning_proto_msgTypes[188]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListMacaroonIDsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListMacaroonIDsRequest) ProtoMessage() {}

func (x *ListMacaroonIDsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[188]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListMacaroonIDsRequest.ProtoReflect.Descriptor instead.
func (*ListMacaroonIDsRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{188}
}

type ListMacaroonIDsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The list of root key IDs that are in use.
	RootKeyIds    []uint64 `protobuf:"varint,1,rep,packed,name=root_key_ids,json=rootKeyIds,proto3" json:"root_key_ids,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListMacaroonIDsResponse) Reset() {
	*x = ListMacaroonIDsResponse{}
	mi := &file_lightning_proto_msgTypes[189]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListMacaroonIDsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListMacaroonIDsResponse) ProtoMessage() {}

func (x *ListMacaroonIDsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[189]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListMacaroonIDsResponse.ProtoReflect.Descriptor instead.
func (*ListMacaroonIDsResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{189}
}

func (x *ListMacaroonIDsResponse) GetRootKeyIds() []uint64 {
	if x != nil {
		return x.RootKeyIds
	}
	return nil
}

type DeleteMacaroonIDRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The root key ID to be removed.
	RootKeyId     uint64 `protobuf:"varint,1,opt,name=root_key_id,json=rootKeyId,proto3" json:"root_key_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteMacaroonIDRequest) Reset() {
	*x = DeleteMacaroonIDRequest{}
	mi := &file_lightning_proto_msgTypes[190]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteMacaroonIDRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteMacaroonIDRequest) ProtoMessage() {}

func (x *DeleteMacaroonIDRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[190]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteMacaroonIDRequest.ProtoReflect.Descriptor instead.
func (*DeleteMacaroonIDRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{190}
}

func (x *DeleteMacaroonIDRequest) GetRootKeyId() uint64 {
	if x != nil {
		return x.RootKeyId
	}
	return 0
}

type DeleteMacaroonIDResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A boolean indicates that the deletion is successful.
	Deleted       bool `protobuf:"varint,1,opt,name=deleted,proto3" json:"deleted,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteMacaroonIDResponse) Reset() {
	*x = DeleteMacaroonIDResponse{}
	mi := &file_lightning_proto_msgTypes[191]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteMacaroonIDResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteMacaroonIDResponse) ProtoMessage() {}

func (x *DeleteMacaroonIDResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[191]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteMacaroonIDResponse.ProtoReflect.Descriptor instead.
func (*DeleteMacaroonIDResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{191}
}

func (x *DeleteMacaroonIDResponse) GetDeleted() bool {
	if x != nil {
		return x.Deleted
	}
	return false
}

type MacaroonPermissionList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of macaroon permissions.
	Permissions   []*MacaroonPermission `protobuf:"bytes,1,rep,name=permissions,proto3" json:"permissions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MacaroonPermissionList) Reset() {
	*x = MacaroonPermissionList{}
	mi := &file_lightning_proto_msgTypes[192]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MacaroonPermissionList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MacaroonPermissionList) ProtoMessage() {}

func (x *MacaroonPermissionList) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[192]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MacaroonPermissionList.ProtoReflect.Descriptor instead.
func (*MacaroonPermissionList) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{192}
}

func (x *MacaroonPermissionList) GetPermissions() []*MacaroonPermission {
	if x != nil {
		return x.Permissions
	}
	return nil
}

type ListPermissionsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListPermissionsRequest) Reset() {
	*x = ListPermissionsRequest{}
	mi := &file_lightning_proto_msgTypes[193]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPermissionsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPermissionsRequest) ProtoMessage() {}

func (x *ListPermissionsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[193]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPermissionsRequest.ProtoReflect.Descriptor instead.
func (*ListPermissionsRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{193}
}

type ListPermissionsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A map between all RPC method URIs and their required macaroon permissions to
	// access them.
	MethodPermissions map[string]*MacaroonPermissionList `protobuf:"bytes,1,rep,name=method_permissions,json=methodPermissions,proto3" json:"method_permissions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ListPermissionsResponse) Reset() {
	*x = ListPermissionsResponse{}
	mi := &file_lightning_proto_msgTypes[194]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPermissionsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPermissionsResponse) ProtoMessage() {}

func (x *ListPermissionsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[194]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPermissionsResponse.ProtoReflect.Descriptor instead.
func (*ListPermissionsResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{194}
}

func (x *ListPermissionsResponse) GetMethodPermissions() map[string]*MacaroonPermissionList {
	if x != nil {
		return x.MethodPermissions
	}
	return nil
}

type Failure struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Failure code as defined in the Lightning spec
	Code Failure_FailureCode `protobuf:"varint,1,opt,name=code,proto3,enum=lnrpc.Failure_FailureCode" json:"code,omitempty"`
	// An optional channel update message.
	ChannelUpdate *ChannelUpdate `protobuf:"bytes,3,opt,name=channel_update,json=channelUpdate,proto3" json:"channel_update,omitempty"`
	// A failure type-dependent htlc value.
	HtlcMsat uint64 `protobuf:"varint,4,opt,name=htlc_msat,json=htlcMsat,proto3" json:"htlc_msat,omitempty"`
	// The sha256 sum of the onion payload.
	OnionSha_256 []byte `protobuf:"bytes,5,opt,name=onion_sha_256,json=onionSha256,proto3" json:"onion_sha_256,omitempty"`
	// A failure type-dependent cltv expiry value.
	CltvExpiry uint32 `protobuf:"varint,6,opt,name=cltv_expiry,json=cltvExpiry,proto3" json:"cltv_expiry,omitempty"`
	// A failure type-dependent flags value.
	Flags uint32 `protobuf:"varint,7,opt,name=flags,proto3" json:"flags,omitempty"`
	// The position in the path of the intermediate or final node that generated
	// the failure message. Position zero is the sender node.
	FailureSourceIndex uint32 `protobuf:"varint,8,opt,name=failure_source_index,json=failureSourceIndex,proto3" json:"failure_source_index,omitempty"`
	// A failure type-dependent block height.
	Height        uint32 `protobuf:"varint,9,opt,name=height,proto3" json:"height,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Failure) Reset() {
	*x = Failure{}
	mi := &file_lightning_proto_msgTypes[195]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Failure) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Failure) ProtoMessage() {}

func (x *Failure) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[195]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Failure.ProtoReflect.Descriptor instead.
func (*Failure) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{195}
}

func (x *Failure) GetCode() Failure_FailureCode {
	if x != nil {
		return x.Code
	}
	return Failure_RESERVED
}

func (x *Failure) GetChannelUpdate() *ChannelUpdate {
	if x != nil {
		return x.ChannelUpdate
	}
	return nil
}

func (x *Failure) GetHtlcMsat() uint64 {
	if x != nil {
		return x.HtlcMsat
	}
	return 0
}

func (x *Failure) GetOnionSha_256() []byte {
	if x != nil {
		return x.OnionSha_256
	}
	return nil
}

func (x *Failure) GetCltvExpiry() uint32 {
	if x != nil {
		return x.CltvExpiry
	}
	return 0
}

func (x *Failure) GetFlags() uint32 {
	if x != nil {
		return x.Flags
	}
	return 0
}

func (x *Failure) GetFailureSourceIndex() uint32 {
	if x != nil {
		return x.FailureSourceIndex
	}
	return 0
}

func (x *Failure) GetHeight() uint32 {
	if x != nil {
		return x.Height
	}
	return 0
}

type ChannelUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The signature that validates the announced data and proves the ownership
	// of node id.
	Signature []byte `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	// The target chain that this channel was opened within. This value
	// should be the genesis hash of the target chain. Along with the short
	// channel ID, this uniquely identifies the channel globally in a
	// blockchain.
	ChainHash []byte `protobuf:"bytes,2,opt,name=chain_hash,json=chainHash,proto3" json:"chain_hash,omitempty"`
	// The unique description of the funding transaction.
	ChanId uint64 `protobuf:"varint,3,opt,name=chan_id,json=chanId,proto3" json:"chan_id,omitempty"`
	// A timestamp that allows ordering in the case of multiple announcements.
	// We should ignore the message if timestamp is not greater than the
	// last-received.
	Timestamp uint32 `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// The bitfield that describes whether optional fields are present in this
	// update. Currently, the least-significant bit must be set to 1 if the
	// optional field MaxHtlc is present.
	MessageFlags uint32 `protobuf:"varint,10,opt,name=message_flags,json=messageFlags,proto3" json:"message_flags,omitempty"`
	// The bitfield that describes additional meta-data concerning how the
	// update is to be interpreted. Currently, the least-significant bit must be
	// set to 0 if the creating node corresponds to the first node in the
	// previously sent channel announcement and 1 otherwise. If the second bit
	// is set, then the channel is set to be disabled.
	ChannelFlags uint32 `protobuf:"varint,5,opt,name=channel_flags,json=channelFlags,proto3" json:"channel_flags,omitempty"`
	// The minimum number of blocks this node requires to be added to the expiry
	// of HTLCs. This is a security parameter determined by the node operator.
	// This value represents the required gap between the time locks of the
	// incoming and outgoing HTLC's set to this node.
	TimeLockDelta uint32 `protobuf:"varint,6,opt,name=time_lock_delta,json=timeLockDelta,proto3" json:"time_lock_delta,omitempty"`
	// The minimum HTLC value which will be accepted.
	HtlcMinimumMsat uint64 `protobuf:"varint,7,opt,name=htlc_minimum_msat,json=htlcMinimumMsat,proto3" json:"htlc_minimum_msat,omitempty"`
	// The base fee that must be used for incoming HTLC's to this particular
	// channel. This value will be tacked onto the required for a payment
	// independent of the size of the payment.
	BaseFee uint32 `protobuf:"varint,8,opt,name=base_fee,json=baseFee,proto3" json:"base_fee,omitempty"`
	// The fee rate that will be charged per millionth of a satoshi.
	FeeRate uint32 `protobuf:"varint,9,opt,name=fee_rate,json=feeRate,proto3" json:"fee_rate,omitempty"`
	// The maximum HTLC value which will be accepted.
	HtlcMaximumMsat uint64 `protobuf:"varint,11,opt,name=htlc_maximum_msat,json=htlcMaximumMsat,proto3" json:"htlc_maximum_msat,omitempty"`
	// The set of data that was appended to this message, some of which we may
	// not actually know how to iterate or parse. By holding onto this data, we
	// ensure that we're able to properly validate the set of signatures that
	// cover these new fields, and ensure we're able to make upgrades to the
	// network in a forwards compatible manner.
	ExtraOpaqueData []byte `protobuf:"bytes,12,opt,name=extra_opaque_data,json=extraOpaqueData,proto3" json:"extra_opaque_data,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ChannelUpdate) Reset() {
	*x = ChannelUpdate{}
	mi := &file_lightning_proto_msgTypes[196]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelUpdate) ProtoMessage() {}

func (x *ChannelUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[196]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelUpdate.ProtoReflect.Descriptor instead.
func (*ChannelUpdate) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{196}
}

func (x *ChannelUpdate) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *ChannelUpdate) GetChainHash() []byte {
	if x != nil {
		return x.ChainHash
	}
	return nil
}

func (x *ChannelUpdate) GetChanId() uint64 {
	if x != nil {
		return x.ChanId
	}
	return 0
}

func (x *ChannelUpdate) GetTimestamp() uint32 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *ChannelUpdate) GetMessageFlags() uint32 {
	if x != nil {
		return x.MessageFlags
	}
	return 0
}

func (x *ChannelUpdate) GetChannelFlags() uint32 {
	if x != nil {
		return x.ChannelFlags
	}
	return 0
}

func (x *ChannelUpdate) GetTimeLockDelta() uint32 {
	if x != nil {
		return x.TimeLockDelta
	}
	return 0
}

func (x *ChannelUpdate) GetHtlcMinimumMsat() uint64 {
	if x != nil {
		return x.HtlcMinimumMsat
	}
	return 0
}

func (x *ChannelUpdate) GetBaseFee() uint32 {
	if x != nil {
		return x.BaseFee
	}
	return 0
}

func (x *ChannelUpdate) GetFeeRate() uint32 {
	if x != nil {
		return x.FeeRate
	}
	return 0
}

func (x *ChannelUpdate) GetHtlcMaximumMsat() uint64 {
	if x != nil {
		return x.HtlcMaximumMsat
	}
	return 0
}

func (x *ChannelUpdate) GetExtraOpaqueData() []byte {
	if x != nil {
		return x.ExtraOpaqueData
	}
	return nil
}

type MacaroonId struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Nonce         []byte                 `protobuf:"bytes,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	StorageId     []byte                 `protobuf:"bytes,2,opt,name=storageId,proto3" json:"storageId,omitempty"`
	Ops           []*Op                  `protobuf:"bytes,3,rep,name=ops,proto3" json:"ops,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MacaroonId) Reset() {
	*x = MacaroonId{}
	mi := &file_lightning_proto_msgTypes[197]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MacaroonId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MacaroonId) ProtoMessage() {}

func (x *MacaroonId) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[197]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MacaroonId.ProtoReflect.Descriptor instead.
func (*MacaroonId) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{197}
}

func (x *MacaroonId) GetNonce() []byte {
	if x != nil {
		return x.Nonce
	}
	return nil
}

func (x *MacaroonId) GetStorageId() []byte {
	if x != nil {
		return x.StorageId
	}
	return nil
}

func (x *MacaroonId) GetOps() []*Op {
	if x != nil {
		return x.Ops
	}
	return nil
}

type Op struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Entity        string                 `protobuf:"bytes,1,opt,name=entity,proto3" json:"entity,omitempty"`
	Actions       []string               `protobuf:"bytes,2,rep,name=actions,proto3" json:"actions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Op) Reset() {
	*x = Op{}
	mi := &file_lightning_proto_msgTypes[198]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Op) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Op) ProtoMessage() {}

func (x *Op) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[198]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Op.ProtoReflect.Descriptor instead.
func (*Op) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{198}
}

func (x *Op) GetEntity() string {
	if x != nil {
		return x.Entity
	}
	return ""
}

func (x *Op) GetActions() []string {
	if x != nil {
		return x.Actions
	}
	return nil
}

type CheckMacPermRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The macaroon to check permissions for, serialized in binary format. For
	// a macaroon to be valid, it must have been issued by lnd, must succeed all
	// caveat conditions, and must contain all of the permissions specified in
	// the permissions field.
	Macaroon []byte `protobuf:"bytes,1,opt,name=macaroon,proto3" json:"macaroon,omitempty"`
	// The list of permissions the macaroon should be checked against. Only if
	// the macaroon contains all of these permissions, it is considered valid.
	// If the list of permissions given is empty, then the macaroon is
	// considered valid only based on issuance authority and caveat validity.
	// An empty list of permissions is therefore equivalent to saying "skip
	// checking permissions" (unless check_default_perms_from_full_method is
	// specified).
	Permissions []*MacaroonPermission `protobuf:"bytes,2,rep,name=permissions,proto3" json:"permissions,omitempty"`
	// The RPC method to check the macaroon against. This is only used if there
	// are custom `uri:<rpcpackage>.<ServiceName>/<MethodName>` permissions in
	// the permission list above. To check a macaroon against the list of
	// permissions of a certain RPC method, query the `ListPermissions` RPC
	// first, extract the permissions for the method, and then pass them in the
	// `permissions` field above.
	FullMethod string `protobuf:"bytes,3,opt,name=fullMethod,proto3" json:"fullMethod,omitempty"`
	// If this field is set to true, then the permissions list above MUST be
	// empty. The default permissions for the provided fullMethod will be used
	// to check the macaroon. This is equivalent to looking up the permissions
	// for a method in the `ListPermissions` RPC and then calling this RPC with
	// the permission list returned from that call. Without this flag, the list
	// of permissions must be non-empty for the check to actually perform a
	// permission check.
	CheckDefaultPermsFromFullMethod bool `protobuf:"varint,4,opt,name=check_default_perms_from_full_method,json=checkDefaultPermsFromFullMethod,proto3" json:"check_default_perms_from_full_method,omitempty"`
	unknownFields                   protoimpl.UnknownFields
	sizeCache                       protoimpl.SizeCache
}

func (x *CheckMacPermRequest) Reset() {
	*x = CheckMacPermRequest{}
	mi := &file_lightning_proto_msgTypes[199]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckMacPermRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckMacPermRequest) ProtoMessage() {}

func (x *CheckMacPermRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[199]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckMacPermRequest.ProtoReflect.Descriptor instead.
func (*CheckMacPermRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{199}
}

func (x *CheckMacPermRequest) GetMacaroon() []byte {
	if x != nil {
		return x.Macaroon
	}
	return nil
}

func (x *CheckMacPermRequest) GetPermissions() []*MacaroonPermission {
	if x != nil {
		return x.Permissions
	}
	return nil
}

func (x *CheckMacPermRequest) GetFullMethod() string {
	if x != nil {
		return x.FullMethod
	}
	return ""
}

func (x *CheckMacPermRequest) GetCheckDefaultPermsFromFullMethod() bool {
	if x != nil {
		return x.CheckDefaultPermsFromFullMethod
	}
	return false
}

type CheckMacPermResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Valid         bool                   `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckMacPermResponse) Reset() {
	*x = CheckMacPermResponse{}
	mi := &file_lightning_proto_msgTypes[200]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckMacPermResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckMacPermResponse) ProtoMessage() {}

func (x *CheckMacPermResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[200]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckMacPermResponse.ProtoReflect.Descriptor instead.
func (*CheckMacPermResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{200}
}

func (x *CheckMacPermResponse) GetValid() bool {
	if x != nil {
		return x.Valid
	}
	return false
}

type RPCMiddlewareRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique ID of the intercepted original gRPC request. Useful for mapping
	// request to response when implementing full duplex message interception. For
	// streaming requests, this will be the same ID for all incoming and outgoing
	// middleware intercept messages of the _same_ stream.
	RequestId uint64 `protobuf:"varint,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// The raw bytes of the complete macaroon as sent by the gRPC client in the
	// original request. This might be empty for a request that doesn't require
	// macaroons such as the wallet unlocker RPCs.
	RawMacaroon []byte `protobuf:"bytes,2,opt,name=raw_macaroon,json=rawMacaroon,proto3" json:"raw_macaroon,omitempty"`
	// The parsed condition of the macaroon's custom caveat for convenient access.
	// This field only contains the value of the custom caveat that the handling
	// middleware has registered itself for. The condition _must_ be validated for
	// messages of intercept_type stream_auth and request!
	CustomCaveatCondition string `protobuf:"bytes,3,opt,name=custom_caveat_condition,json=customCaveatCondition,proto3" json:"custom_caveat_condition,omitempty"`
	// There are three types of messages that will be sent to the middleware for
	// inspection and approval: Stream authentication, request and response
	// interception. The first two can only be accepted (=forward to main RPC
	// server) or denied (=return error to client). Intercepted responses can also
	// be replaced/overwritten.
	//
	// Types that are valid to be assigned to InterceptType:
	//
	//	*RPCMiddlewareRequest_StreamAuth
	//	*RPCMiddlewareRequest_Request
	//	*RPCMiddlewareRequest_Response
	//	*RPCMiddlewareRequest_RegComplete
	InterceptType isRPCMiddlewareRequest_InterceptType `protobuf_oneof:"intercept_type"`
	// The unique message ID of this middleware intercept message. There can be
	// multiple middleware intercept messages per single gRPC request (one for the
	// incoming request and one for the outgoing response) or gRPC stream (one for
	// each incoming message and one for each outgoing response). This message ID
	// must be referenced when responding (accepting/rejecting/modifying) to an
	// intercept message.
	MsgId uint64 `protobuf:"varint,7,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
	// The metadata pairs that were sent along with the original gRPC request via
	// the golang context.Context using explicit [gRPC
	// metadata](https://grpc.io/docs/guides/metadata/). Context values are not
	// propagated via gRPC and so we send any pairs along explicitly here so that
	// the interceptor can access them.
	MetadataPairs map[string]*MetadataValues `protobuf:"bytes,9,rep,name=metadata_pairs,json=metadataPairs,proto3" json:"metadata_pairs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RPCMiddlewareRequest) Reset() {
	*x = RPCMiddlewareRequest{}
	mi := &file_lightning_proto_msgTypes[201]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RPCMiddlewareRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RPCMiddlewareRequest) ProtoMessage() {}

func (x *RPCMiddlewareRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[201]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RPCMiddlewareRequest.ProtoReflect.Descriptor instead.
func (*RPCMiddlewareRequest) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{201}
}

func (x *RPCMiddlewareRequest) GetRequestId() uint64 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *RPCMiddlewareRequest) GetRawMacaroon() []byte {
	if x != nil {
		return x.RawMacaroon
	}
	return nil
}

func (x *RPCMiddlewareRequest) GetCustomCaveatCondition() string {
	if x != nil {
		return x.CustomCaveatCondition
	}
	return ""
}

func (x *RPCMiddlewareRequest) GetInterceptType() isRPCMiddlewareRequest_InterceptType {
	if x != nil {
		return x.InterceptType
	}
	return nil
}

func (x *RPCMiddlewareRequest) GetStreamAuth() *StreamAuth {
	if x != nil {
		if x, ok := x.InterceptType.(*RPCMiddlewareRequest_StreamAuth); ok {
			return x.StreamAuth
		}
	}
	return nil
}

func (x *RPCMiddlewareRequest) GetRequest() *RPCMessage {
	if x != nil {
		if x, ok := x.InterceptType.(*RPCMiddlewareRequest_Request); ok {
			return x.Request
		}
	}
	return nil
}

func (x *RPCMiddlewareRequest) GetResponse() *RPCMessage {
	if x != nil {
		if x, ok := x.InterceptType.(*RPCMiddlewareRequest_Response); ok {
			return x.Response
		}
	}
	return nil
}

func (x *RPCMiddlewareRequest) GetRegComplete() bool {
	if x != nil {
		if x, ok := x.InterceptType.(*RPCMiddlewareRequest_RegComplete); ok {
			return x.RegComplete
		}
	}
	return false
}

func (x *RPCMiddlewareRequest) GetMsgId() uint64 {
	if x != nil {
		return x.MsgId
	}
	return 0
}

func (x *RPCMiddlewareRequest) GetMetadataPairs() map[string]*MetadataValues {
	if x != nil {
		return x.MetadataPairs
	}
	return nil
}

type isRPCMiddlewareRequest_InterceptType interface {
	isRPCMiddlewareRequest_InterceptType()
}

type RPCMiddlewareRequest_StreamAuth struct {
	// Intercept stream authentication: each new streaming RPC call that is
	// initiated against lnd and contains the middleware's custom macaroon
	// caveat can be approved or denied based upon the macaroon in the stream
	// header. This message will only be sent for streaming RPCs, unary RPCs
	// must handle the macaroon authentication in the request interception to
	// avoid an additional message round trip between lnd and the middleware.
	StreamAuth *StreamAuth `protobuf:"bytes,4,opt,name=stream_auth,json=streamAuth,proto3,oneof"`
}

type RPCMiddlewareRequest_Request struct {
	// Intercept incoming gRPC client request message: all incoming messages,
	// both on streaming and unary RPCs, are forwarded to the middleware for
	// inspection. For unary RPC messages the middleware is also expected to
	// validate the custom macaroon caveat of the request.
	Request *RPCMessage `protobuf:"bytes,5,opt,name=request,proto3,oneof"`
}

type RPCMiddlewareRequest_Response struct {
	// Intercept outgoing gRPC response message: all outgoing messages, both on
	// streaming and unary RPCs, are forwarded to the middleware for inspection
	// and amendment. The response in this message is the original response as
	// it was generated by the main RPC server. It can either be accepted
	// (=forwarded to the client), replaced/overwritten with a new message of
	// the same type, or replaced by an error message.
	Response *RPCMessage `protobuf:"bytes,6,opt,name=response,proto3,oneof"`
}

type RPCMiddlewareRequest_RegComplete struct {
	// This is used to indicate to the client that the server has successfully
	// registered the interceptor. This is only used in the very first message
	// that the server sends to the client after the client sends the server
	// the middleware registration message.
	RegComplete bool `protobuf:"varint,8,opt,name=reg_complete,json=regComplete,proto3,oneof"`
}

func (*RPCMiddlewareRequest_StreamAuth) isRPCMiddlewareRequest_InterceptType() {}

func (*RPCMiddlewareRequest_Request) isRPCMiddlewareRequest_InterceptType() {}

func (*RPCMiddlewareRequest_Response) isRPCMiddlewareRequest_InterceptType() {}

func (*RPCMiddlewareRequest_RegComplete) isRPCMiddlewareRequest_InterceptType() {}

type MetadataValues struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The set of metadata values that correspond to the metadata key.
	Values        []string `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MetadataValues) Reset() {
	*x = MetadataValues{}
	mi := &file_lightning_proto_msgTypes[202]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MetadataValues) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetadataValues) ProtoMessage() {}

func (x *MetadataValues) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[202]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MetadataValues.ProtoReflect.Descriptor instead.
func (*MetadataValues) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{202}
}

func (x *MetadataValues) GetValues() []string {
	if x != nil {
		return x.Values
	}
	return nil
}

type StreamAuth struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The full URI (in the format /<rpcpackage>.<ServiceName>/MethodName, for
	// example /lnrpc.Lightning/GetInfo) of the streaming RPC method that was just
	// established.
	MethodFullUri string `protobuf:"bytes,1,opt,name=method_full_uri,json=methodFullUri,proto3" json:"method_full_uri,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamAuth) Reset() {
	*x = StreamAuth{}
	mi := &file_lightning_proto_msgTypes[203]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamAuth) ProtoMessage() {}

func (x *StreamAuth) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[203]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamAuth.ProtoReflect.Descriptor instead.
func (*StreamAuth) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{203}
}

func (x *StreamAuth) GetMethodFullUri() string {
	if x != nil {
		return x.MethodFullUri
	}
	return ""
}

type RPCMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The full URI (in the format /<rpcpackage>.<ServiceName>/MethodName, for
	// example /lnrpc.Lightning/GetInfo) of the RPC method the message was sent
	// to/from.
	MethodFullUri string `protobuf:"bytes,1,opt,name=method_full_uri,json=methodFullUri,proto3" json:"method_full_uri,omitempty"`
	// Indicates whether the message was sent over a streaming RPC method or not.
	StreamRpc bool `protobuf:"varint,2,opt,name=stream_rpc,json=streamRpc,proto3" json:"stream_rpc,omitempty"`
	// The full canonical gRPC name of the message type (in the format
	// <rpcpackage>.TypeName, for example lnrpc.GetInfoRequest). In case of an
	// error being returned from lnd, this simply contains the string "error".
	TypeName string `protobuf:"bytes,3,opt,name=type_name,json=typeName,proto3" json:"type_name,omitempty"`
	// The full content of the gRPC message, serialized in the binary protobuf
	// format.
	Serialized []byte `protobuf:"bytes,4,opt,name=serialized,proto3" json:"serialized,omitempty"`
	// Indicates that the response from lnd was an error, not a gRPC response. If
	// this is set to true then the type_name contains the string "error" and
	// serialized contains the error string.
	IsError       bool `protobuf:"varint,5,opt,name=is_error,json=isError,proto3" json:"is_error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RPCMessage) Reset() {
	*x = RPCMessage{}
	mi := &file_lightning_proto_msgTypes[204]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RPCMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RPCMessage) ProtoMessage() {}

func (x *RPCMessage) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[204]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RPCMessage.ProtoReflect.Descriptor instead.
func (*RPCMessage) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{204}
}

func (x *RPCMessage) GetMethodFullUri() string {
	if x != nil {
		return x.MethodFullUri
	}
	return ""
}

func (x *RPCMessage) GetStreamRpc() bool {
	if x != nil {
		return x.StreamRpc
	}
	return false
}

func (x *RPCMessage) GetTypeName() string {
	if x != nil {
		return x.TypeName
	}
	return ""
}

func (x *RPCMessage) GetSerialized() []byte {
	if x != nil {
		return x.Serialized
	}
	return nil
}

func (x *RPCMessage) GetIsError() bool {
	if x != nil {
		return x.IsError
	}
	return false
}

type RPCMiddlewareResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The request message ID this response refers to. Must always be set when
	// giving feedback to an intercept but is ignored for the initial registration
	// message.
	RefMsgId uint64 `protobuf:"varint,1,opt,name=ref_msg_id,json=refMsgId,proto3" json:"ref_msg_id,omitempty"`
	// The middleware can only send two types of messages to lnd: The initial
	// registration message that identifies the middleware and after that only
	// feedback messages to requests sent to the middleware.
	//
	// Types that are valid to be assigned to MiddlewareMessage:
	//
	//	*RPCMiddlewareResponse_Register
	//	*RPCMiddlewareResponse_Feedback
	MiddlewareMessage isRPCMiddlewareResponse_MiddlewareMessage `protobuf_oneof:"middleware_message"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *RPCMiddlewareResponse) Reset() {
	*x = RPCMiddlewareResponse{}
	mi := &file_lightning_proto_msgTypes[205]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RPCMiddlewareResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RPCMiddlewareResponse) ProtoMessage() {}

func (x *RPCMiddlewareResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[205]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RPCMiddlewareResponse.ProtoReflect.Descriptor instead.
func (*RPCMiddlewareResponse) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{205}
}

func (x *RPCMiddlewareResponse) GetRefMsgId() uint64 {
	if x != nil {
		return x.RefMsgId
	}
	return 0
}

func (x *RPCMiddlewareResponse) GetMiddlewareMessage() isRPCMiddlewareResponse_MiddlewareMessage {
	if x != nil {
		return x.MiddlewareMessage
	}
	return nil
}

func (x *RPCMiddlewareResponse) GetRegister() *MiddlewareRegistration {
	if x != nil {
		if x, ok := x.MiddlewareMessage.(*RPCMiddlewareResponse_Register); ok {
			return x.Register
		}
	}
	return nil
}

func (x *RPCMiddlewareResponse) GetFeedback() *InterceptFeedback {
	if x != nil {
		if x, ok := x.MiddlewareMessage.(*RPCMiddlewareResponse_Feedback); ok {
			return x.Feedback
		}
	}
	return nil
}

type isRPCMiddlewareResponse_MiddlewareMessage interface {
	isRPCMiddlewareResponse_MiddlewareMessage()
}

type RPCMiddlewareResponse_Register struct {
	// The registration message identifies the middleware that's being
	// registered in lnd. The registration message must be sent immediately
	// after initiating the RegisterRpcMiddleware stream, otherwise lnd will
	// time out the attempt and terminate the request. NOTE: The middleware
	// will only receive interception messages for requests that contain a
	// macaroon with the custom caveat that the middleware declares it is
	// responsible for handling in the registration message! As a security
	// measure, _no_ middleware can intercept requests made with _unencumbered_
	// macaroons!
	Register *MiddlewareRegistration `protobuf:"bytes,2,opt,name=register,proto3,oneof"`
}

type RPCMiddlewareResponse_Feedback struct {
	// The middleware received an interception request and gives feedback to
	// it. The request_id indicates what message the feedback refers to.
	Feedback *InterceptFeedback `protobuf:"bytes,3,opt,name=feedback,proto3,oneof"`
}

func (*RPCMiddlewareResponse_Register) isRPCMiddlewareResponse_MiddlewareMessage() {}

func (*RPCMiddlewareResponse_Feedback) isRPCMiddlewareResponse_MiddlewareMessage() {}

type MiddlewareRegistration struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the middleware to register. The name should be as informative
	// as possible and is logged on registration.
	MiddlewareName string `protobuf:"bytes,1,opt,name=middleware_name,json=middlewareName,proto3" json:"middleware_name,omitempty"`
	// The name of the custom macaroon caveat that this middleware is responsible
	// for. Only requests/responses that contain a macaroon with the registered
	// custom caveat are forwarded for interception to the middleware. The
	// exception being the read-only mode: All requests/responses are forwarded to
	// a middleware that requests read-only access but such a middleware won't be
	// allowed to _alter_ responses. As a security measure, _no_ middleware can
	// change responses to requests made with _unencumbered_ macaroons!
	// NOTE: Cannot be used at the same time as read_only_mode.
	CustomMacaroonCaveatName string `protobuf:"bytes,2,opt,name=custom_macaroon_caveat_name,json=customMacaroonCaveatName,proto3" json:"custom_macaroon_caveat_name,omitempty"`
	// Instead of defining a custom macaroon caveat name a middleware can register
	// itself for read-only access only. In that mode all requests/responses are
	// forwarded to the middleware but the middleware isn't allowed to alter any of
	// the responses.
	// NOTE: Cannot be used at the same time as custom_macaroon_caveat_name.
	ReadOnlyMode  bool `protobuf:"varint,3,opt,name=read_only_mode,json=readOnlyMode,proto3" json:"read_only_mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MiddlewareRegistration) Reset() {
	*x = MiddlewareRegistration{}
	mi := &file_lightning_proto_msgTypes[206]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MiddlewareRegistration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MiddlewareRegistration) ProtoMessage() {}

func (x *MiddlewareRegistration) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[206]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MiddlewareRegistration.ProtoReflect.Descriptor instead.
func (*MiddlewareRegistration) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{206}
}

func (x *MiddlewareRegistration) GetMiddlewareName() string {
	if x != nil {
		return x.MiddlewareName
	}
	return ""
}

func (x *MiddlewareRegistration) GetCustomMacaroonCaveatName() string {
	if x != nil {
		return x.CustomMacaroonCaveatName
	}
	return ""
}

func (x *MiddlewareRegistration) GetReadOnlyMode() bool {
	if x != nil {
		return x.ReadOnlyMode
	}
	return false
}

type InterceptFeedback struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The error to return to the user. If this is non-empty, the incoming gRPC
	// stream/request is aborted and the error is returned to the gRPC client. If
	// this value is empty, it means the middleware accepts the stream/request/
	// response and the processing of it can continue.
	Error string `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// A boolean indicating that the gRPC message should be replaced/overwritten.
	// This boolean is needed because in protobuf an empty message is serialized as
	// a 0-length or nil byte slice and we wouldn't be able to distinguish between
	// an empty replacement message and the "don't replace anything" case.
	ReplaceResponse bool `protobuf:"varint,2,opt,name=replace_response,json=replaceResponse,proto3" json:"replace_response,omitempty"`
	// If the replace_response field is set to true, this field must contain the
	// binary serialized gRPC message in the protobuf format.
	ReplacementSerialized []byte `protobuf:"bytes,3,opt,name=replacement_serialized,json=replacementSerialized,proto3" json:"replacement_serialized,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *InterceptFeedback) Reset() {
	*x = InterceptFeedback{}
	mi := &file_lightning_proto_msgTypes[207]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InterceptFeedback) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InterceptFeedback) ProtoMessage() {}

func (x *InterceptFeedback) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[207]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InterceptFeedback.ProtoReflect.Descriptor instead.
func (*InterceptFeedback) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{207}
}

func (x *InterceptFeedback) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *InterceptFeedback) GetReplaceResponse() bool {
	if x != nil {
		return x.ReplaceResponse
	}
	return false
}

func (x *InterceptFeedback) GetReplacementSerialized() []byte {
	if x != nil {
		return x.ReplacementSerialized
	}
	return nil
}

type PendingChannelsResponse_PendingChannel struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RemoteNodePub string                 `protobuf:"bytes,1,opt,name=remote_node_pub,json=remoteNodePub,proto3" json:"remote_node_pub,omitempty"`
	ChannelPoint  string                 `protobuf:"bytes,2,opt,name=channel_point,json=channelPoint,proto3" json:"channel_point,omitempty"`
	Capacity      int64                  `protobuf:"varint,3,opt,name=capacity,proto3" json:"capacity,omitempty"`
	LocalBalance  int64                  `protobuf:"varint,4,opt,name=local_balance,json=localBalance,proto3" json:"local_balance,omitempty"`
	RemoteBalance int64                  `protobuf:"varint,5,opt,name=remote_balance,json=remoteBalance,proto3" json:"remote_balance,omitempty"`
	// The minimum satoshis this node is required to reserve in its
	// balance.
	LocalChanReserveSat int64 `protobuf:"varint,6,opt,name=local_chan_reserve_sat,json=localChanReserveSat,proto3" json:"local_chan_reserve_sat,omitempty"`
	// The minimum satoshis the other node is required to reserve in its
	// balance.
	RemoteChanReserveSat int64 `protobuf:"varint,7,opt,name=remote_chan_reserve_sat,json=remoteChanReserveSat,proto3" json:"remote_chan_reserve_sat,omitempty"`
	// The party that initiated opening the channel.
	Initiator Initiator `protobuf:"varint,8,opt,name=initiator,proto3,enum=lnrpc.Initiator" json:"initiator,omitempty"`
	// The commitment type used by this channel.
	CommitmentType CommitmentType `protobuf:"varint,9,opt,name=commitment_type,json=commitmentType,proto3,enum=lnrpc.CommitmentType" json:"commitment_type,omitempty"`
	// Total number of forwarding packages created in this channel.
	NumForwardingPackages int64 `protobuf:"varint,10,opt,name=num_forwarding_packages,json=numForwardingPackages,proto3" json:"num_forwarding_packages,omitempty"`
	// A set of flags showing the current state of the channel.
	ChanStatusFlags string `protobuf:"bytes,11,opt,name=chan_status_flags,json=chanStatusFlags,proto3" json:"chan_status_flags,omitempty"`
	// Whether this channel is advertised to the network or not.
	Private bool `protobuf:"varint,12,opt,name=private,proto3" json:"private,omitempty"`
	// An optional note-to-self to go along with the channel containing some
	// useful information. This is only ever stored locally and in no way
	// impacts the channel's operation.
	Memo string `protobuf:"bytes,13,opt,name=memo,proto3" json:"memo,omitempty"`
	// Custom channel data that might be populated in custom channels.
	CustomChannelData []byte `protobuf:"bytes,34,opt,name=custom_channel_data,json=customChannelData,proto3" json:"custom_channel_data,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *PendingChannelsResponse_PendingChannel) Reset() {
	*x = PendingChannelsResponse_PendingChannel{}
	mi := &file_lightning_proto_msgTypes[214]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PendingChannelsResponse_PendingChannel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingChannelsResponse_PendingChannel) ProtoMessage() {}

func (x *PendingChannelsResponse_PendingChannel) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[214]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PendingChannelsResponse_PendingChannel.ProtoReflect.Descriptor instead.
func (*PendingChannelsResponse_PendingChannel) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{93, 0}
}

func (x *PendingChannelsResponse_PendingChannel) GetRemoteNodePub() string {
	if x != nil {
		return x.RemoteNodePub
	}
	return ""
}

func (x *PendingChannelsResponse_PendingChannel) GetChannelPoint() string {
	if x != nil {
		return x.ChannelPoint
	}
	return ""
}

func (x *PendingChannelsResponse_PendingChannel) GetCapacity() int64 {
	if x != nil {
		return x.Capacity
	}
	return 0
}

func (x *PendingChannelsResponse_PendingChannel) GetLocalBalance() int64 {
	if x != nil {
		return x.LocalBalance
	}
	return 0
}

func (x *PendingChannelsResponse_PendingChannel) GetRemoteBalance() int64 {
	if x != nil {
		return x.RemoteBalance
	}
	return 0
}

func (x *PendingChannelsResponse_PendingChannel) GetLocalChanReserveSat() int64 {
	if x != nil {
		return x.LocalChanReserveSat
	}
	return 0
}

func (x *PendingChannelsResponse_PendingChannel) GetRemoteChanReserveSat() int64 {
	if x != nil {
		return x.RemoteChanReserveSat
	}
	return 0
}

func (x *PendingChannelsResponse_PendingChannel) GetInitiator() Initiator {
	if x != nil {
		return x.Initiator
	}
	return Initiator_INITIATOR_UNKNOWN
}

func (x *PendingChannelsResponse_PendingChannel) GetCommitmentType() CommitmentType {
	if x != nil {
		return x.CommitmentType
	}
	return CommitmentType_UNKNOWN_COMMITMENT_TYPE
}

func (x *PendingChannelsResponse_PendingChannel) GetNumForwardingPackages() int64 {
	if x != nil {
		return x.NumForwardingPackages
	}
	return 0
}

func (x *PendingChannelsResponse_PendingChannel) GetChanStatusFlags() string {
	if x != nil {
		return x.ChanStatusFlags
	}
	return ""
}

func (x *PendingChannelsResponse_PendingChannel) GetPrivate() bool {
	if x != nil {
		return x.Private
	}
	return false
}

func (x *PendingChannelsResponse_PendingChannel) GetMemo() string {
	if x != nil {
		return x.Memo
	}
	return ""
}

func (x *PendingChannelsResponse_PendingChannel) GetCustomChannelData() []byte {
	if x != nil {
		return x.CustomChannelData
	}
	return nil
}

type PendingChannelsResponse_PendingOpenChannel struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The pending channel
	Channel *PendingChannelsResponse_PendingChannel `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel,omitempty"`
	// The amount calculated to be paid in fees for the current set of
	// commitment transactions. The fee amount is persisted with the channel
	// in order to allow the fee amount to be removed and recalculated with
	// each channel state update, including updates that happen after a system
	// restart.
	CommitFee int64 `protobuf:"varint,4,opt,name=commit_fee,json=commitFee,proto3" json:"commit_fee,omitempty"`
	// The weight of the commitment transaction
	CommitWeight int64 `protobuf:"varint,5,opt,name=commit_weight,json=commitWeight,proto3" json:"commit_weight,omitempty"`
	// The required number of satoshis per kilo-weight that the requester will
	// pay at all times, for both the funding transaction and commitment
	// transaction. This value can later be updated once the channel is open.
	FeePerKw int64 `protobuf:"varint,6,opt,name=fee_per_kw,json=feePerKw,proto3" json:"fee_per_kw,omitempty"`
	// The number of blocks until the funding transaction is considered
	// expired. If this value gets close to zero, there is a risk that the
	// channel funding will be canceled by the channel responder. The
	// channel should be fee bumped using CPFP (see walletrpc.BumpFee) to
	// ensure that the channel confirms in time. Otherwise a force-close
	// will be necessary if the channel confirms after the funding
	// transaction expires. A negative value means the channel responder has
	// very likely canceled the funding and the channel will never become
	// fully operational.
	FundingExpiryBlocks int32 `protobuf:"varint,3,opt,name=funding_expiry_blocks,json=fundingExpiryBlocks,proto3" json:"funding_expiry_blocks,omitempty"`
	// The number of blocks remaining until the channel status changes from
	// pending to active. A value of 0 indicates that the channel is now
	// active.
	//
	// "Active" here means both channel peers have the channel marked OPEN
	// and can immediately start using it. For public channels, this does
	// not imply a channel_announcement has been gossiped. It only becomes
	// public on the network after 6 onchain confirmations.
	// See BOLT07 "Routing Gossip":
	// https://github.com/lightning/bolts/blob/master/07-routing-gossip.md
	//
	// ZeroConf channels bypass the pending state entirely: they are marked
	// active immediately upon creation, so they never show up as "pending".
	ConfirmationsUntilActive uint32 `protobuf:"varint,7,opt,name=confirmations_until_active,json=confirmationsUntilActive,proto3" json:"confirmations_until_active,omitempty"`
	// The confirmation height records the block height at which the funding
	// transaction was first confirmed.
	ConfirmationHeight uint32 `protobuf:"varint,8,opt,name=confirmation_height,json=confirmationHeight,proto3" json:"confirmation_height,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *PendingChannelsResponse_PendingOpenChannel) Reset() {
	*x = PendingChannelsResponse_PendingOpenChannel{}
	mi := &file_lightning_proto_msgTypes[215]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PendingChannelsResponse_PendingOpenChannel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingChannelsResponse_PendingOpenChannel) ProtoMessage() {}

func (x *PendingChannelsResponse_PendingOpenChannel) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[215]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PendingChannelsResponse_PendingOpenChannel.ProtoReflect.Descriptor instead.
func (*PendingChannelsResponse_PendingOpenChannel) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{93, 1}
}

func (x *PendingChannelsResponse_PendingOpenChannel) GetChannel() *PendingChannelsResponse_PendingChannel {
	if x != nil {
		return x.Channel
	}
	return nil
}

func (x *PendingChannelsResponse_PendingOpenChannel) GetCommitFee() int64 {
	if x != nil {
		return x.CommitFee
	}
	return 0
}

func (x *PendingChannelsResponse_PendingOpenChannel) GetCommitWeight() int64 {
	if x != nil {
		return x.CommitWeight
	}
	return 0
}

func (x *PendingChannelsResponse_PendingOpenChannel) GetFeePerKw() int64 {
	if x != nil {
		return x.FeePerKw
	}
	return 0
}

func (x *PendingChannelsResponse_PendingOpenChannel) GetFundingExpiryBlocks() int32 {
	if x != nil {
		return x.FundingExpiryBlocks
	}
	return 0
}

func (x *PendingChannelsResponse_PendingOpenChannel) GetConfirmationsUntilActive() uint32 {
	if x != nil {
		return x.ConfirmationsUntilActive
	}
	return 0
}

func (x *PendingChannelsResponse_PendingOpenChannel) GetConfirmationHeight() uint32 {
	if x != nil {
		return x.ConfirmationHeight
	}
	return 0
}

type PendingChannelsResponse_WaitingCloseChannel struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The pending channel waiting for closing tx to confirm
	Channel *PendingChannelsResponse_PendingChannel `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel,omitempty"`
	// The balance in satoshis encumbered in this channel
	LimboBalance int64 `protobuf:"varint,2,opt,name=limbo_balance,json=limboBalance,proto3" json:"limbo_balance,omitempty"`
	// A list of valid commitment transactions. Any of these can confirm at
	// this point.
	Commitments *PendingChannelsResponse_Commitments `protobuf:"bytes,3,opt,name=commitments,proto3" json:"commitments,omitempty"`
	// The transaction id of the closing transaction
	ClosingTxid string `protobuf:"bytes,4,opt,name=closing_txid,json=closingTxid,proto3" json:"closing_txid,omitempty"`
	// The raw hex encoded bytes of the closing transaction. Included if
	// include_raw_tx in the request is true.
	ClosingTxHex  string `protobuf:"bytes,5,opt,name=closing_tx_hex,json=closingTxHex,proto3" json:"closing_tx_hex,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PendingChannelsResponse_WaitingCloseChannel) Reset() {
	*x = PendingChannelsResponse_WaitingCloseChannel{}
	mi := &file_lightning_proto_msgTypes[216]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PendingChannelsResponse_WaitingCloseChannel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingChannelsResponse_WaitingCloseChannel) ProtoMessage() {}

func (x *PendingChannelsResponse_WaitingCloseChannel) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[216]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PendingChannelsResponse_WaitingCloseChannel.ProtoReflect.Descriptor instead.
func (*PendingChannelsResponse_WaitingCloseChannel) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{93, 2}
}

func (x *PendingChannelsResponse_WaitingCloseChannel) GetChannel() *PendingChannelsResponse_PendingChannel {
	if x != nil {
		return x.Channel
	}
	return nil
}

func (x *PendingChannelsResponse_WaitingCloseChannel) GetLimboBalance() int64 {
	if x != nil {
		return x.LimboBalance
	}
	return 0
}

func (x *PendingChannelsResponse_WaitingCloseChannel) GetCommitments() *PendingChannelsResponse_Commitments {
	if x != nil {
		return x.Commitments
	}
	return nil
}

func (x *PendingChannelsResponse_WaitingCloseChannel) GetClosingTxid() string {
	if x != nil {
		return x.ClosingTxid
	}
	return ""
}

func (x *PendingChannelsResponse_WaitingCloseChannel) GetClosingTxHex() string {
	if x != nil {
		return x.ClosingTxHex
	}
	return ""
}

type PendingChannelsResponse_Commitments struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Hash of the local version of the commitment tx.
	LocalTxid string `protobuf:"bytes,1,opt,name=local_txid,json=localTxid,proto3" json:"local_txid,omitempty"`
	// Hash of the remote version of the commitment tx.
	RemoteTxid string `protobuf:"bytes,2,opt,name=remote_txid,json=remoteTxid,proto3" json:"remote_txid,omitempty"`
	// Hash of the remote pending version of the commitment tx.
	RemotePendingTxid string `protobuf:"bytes,3,opt,name=remote_pending_txid,json=remotePendingTxid,proto3" json:"remote_pending_txid,omitempty"`
	// The amount in satoshis calculated to be paid in fees for the local
	// commitment.
	LocalCommitFeeSat uint64 `protobuf:"varint,4,opt,name=local_commit_fee_sat,json=localCommitFeeSat,proto3" json:"local_commit_fee_sat,omitempty"`
	// The amount in satoshis calculated to be paid in fees for the remote
	// commitment.
	RemoteCommitFeeSat uint64 `protobuf:"varint,5,opt,name=remote_commit_fee_sat,json=remoteCommitFeeSat,proto3" json:"remote_commit_fee_sat,omitempty"`
	// The amount in satoshis calculated to be paid in fees for the remote
	// pending commitment.
	RemotePendingCommitFeeSat uint64 `protobuf:"varint,6,opt,name=remote_pending_commit_fee_sat,json=remotePendingCommitFeeSat,proto3" json:"remote_pending_commit_fee_sat,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *PendingChannelsResponse_Commitments) Reset() {
	*x = PendingChannelsResponse_Commitments{}
	mi := &file_lightning_proto_msgTypes[217]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PendingChannelsResponse_Commitments) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingChannelsResponse_Commitments) ProtoMessage() {}

func (x *PendingChannelsResponse_Commitments) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[217]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PendingChannelsResponse_Commitments.ProtoReflect.Descriptor instead.
func (*PendingChannelsResponse_Commitments) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{93, 3}
}

func (x *PendingChannelsResponse_Commitments) GetLocalTxid() string {
	if x != nil {
		return x.LocalTxid
	}
	return ""
}

func (x *PendingChannelsResponse_Commitments) GetRemoteTxid() string {
	if x != nil {
		return x.RemoteTxid
	}
	return ""
}

func (x *PendingChannelsResponse_Commitments) GetRemotePendingTxid() string {
	if x != nil {
		return x.RemotePendingTxid
	}
	return ""
}

func (x *PendingChannelsResponse_Commitments) GetLocalCommitFeeSat() uint64 {
	if x != nil {
		return x.LocalCommitFeeSat
	}
	return 0
}

func (x *PendingChannelsResponse_Commitments) GetRemoteCommitFeeSat() uint64 {
	if x != nil {
		return x.RemoteCommitFeeSat
	}
	return 0
}

func (x *PendingChannelsResponse_Commitments) GetRemotePendingCommitFeeSat() uint64 {
	if x != nil {
		return x.RemotePendingCommitFeeSat
	}
	return 0
}

type PendingChannelsResponse_ClosedChannel struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The pending channel to be closed
	Channel *PendingChannelsResponse_PendingChannel `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel,omitempty"`
	// The transaction id of the closing transaction
	ClosingTxid   string `protobuf:"bytes,2,opt,name=closing_txid,json=closingTxid,proto3" json:"closing_txid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PendingChannelsResponse_ClosedChannel) Reset() {
	*x = PendingChannelsResponse_ClosedChannel{}
	mi := &file_lightning_proto_msgTypes[218]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PendingChannelsResponse_ClosedChannel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingChannelsResponse_ClosedChannel) ProtoMessage() {}

func (x *PendingChannelsResponse_ClosedChannel) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[218]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PendingChannelsResponse_ClosedChannel.ProtoReflect.Descriptor instead.
func (*PendingChannelsResponse_ClosedChannel) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{93, 4}
}

func (x *PendingChannelsResponse_ClosedChannel) GetChannel() *PendingChannelsResponse_PendingChannel {
	if x != nil {
		return x.Channel
	}
	return nil
}

func (x *PendingChannelsResponse_ClosedChannel) GetClosingTxid() string {
	if x != nil {
		return x.ClosingTxid
	}
	return ""
}

type PendingChannelsResponse_ForceClosedChannel struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The pending channel to be force closed
	Channel *PendingChannelsResponse_PendingChannel `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel,omitempty"`
	// The transaction id of the closing transaction
	ClosingTxid string `protobuf:"bytes,2,opt,name=closing_txid,json=closingTxid,proto3" json:"closing_txid,omitempty"`
	// The balance in satoshis encumbered in this pending channel
	LimboBalance int64 `protobuf:"varint,3,opt,name=limbo_balance,json=limboBalance,proto3" json:"limbo_balance,omitempty"`
	// The height at which funds can be swept into the wallet
	MaturityHeight uint32 `protobuf:"varint,4,opt,name=maturity_height,json=maturityHeight,proto3" json:"maturity_height,omitempty"`
	// Remaining # of blocks until the commitment output can be swept.
	// Negative values indicate how many blocks have passed since becoming
	// mature.
	BlocksTilMaturity int32 `protobuf:"varint,5,opt,name=blocks_til_maturity,json=blocksTilMaturity,proto3" json:"blocks_til_maturity,omitempty"`
	// The total value of funds successfully recovered from this channel
	RecoveredBalance int64                                                  `protobuf:"varint,6,opt,name=recovered_balance,json=recoveredBalance,proto3" json:"recovered_balance,omitempty"`
	PendingHtlcs     []*PendingHTLC                                         `protobuf:"bytes,8,rep,name=pending_htlcs,json=pendingHtlcs,proto3" json:"pending_htlcs,omitempty"`
	Anchor           PendingChannelsResponse_ForceClosedChannel_AnchorState `protobuf:"varint,9,opt,name=anchor,proto3,enum=lnrpc.PendingChannelsResponse_ForceClosedChannel_AnchorState" json:"anchor,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *PendingChannelsResponse_ForceClosedChannel) Reset() {
	*x = PendingChannelsResponse_ForceClosedChannel{}
	mi := &file_lightning_proto_msgTypes[219]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PendingChannelsResponse_ForceClosedChannel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PendingChannelsResponse_ForceClosedChannel) ProtoMessage() {}

func (x *PendingChannelsResponse_ForceClosedChannel) ProtoReflect() protoreflect.Message {
	mi := &file_lightning_proto_msgTypes[219]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PendingChannelsResponse_ForceClosedChannel.ProtoReflect.Descriptor instead.
func (*PendingChannelsResponse_ForceClosedChannel) Descriptor() ([]byte, []int) {
	return file_lightning_proto_rawDescGZIP(), []int{93, 5}
}

func (x *PendingChannelsResponse_ForceClosedChannel) GetChannel() *PendingChannelsResponse_PendingChannel {
	if x != nil {
		return x.Channel
	}
	return nil
}

func (x *PendingChannelsResponse_ForceClosedChannel) GetClosingTxid() string {
	if x != nil {
		return x.ClosingTxid
	}
	return ""
}

func (x *PendingChannelsResponse_ForceClosedChannel) GetLimboBalance() int64 {
	if x != nil {
		return x.LimboBalance
	}
	return 0
}

func (x *PendingChannelsResponse_ForceClosedChannel) GetMaturityHeight() uint32 {
	if x != nil {
		return x.MaturityHeight
	}
	return 0
}

func (x *PendingChannelsResponse_ForceClosedChannel) GetBlocksTilMaturity() int32 {
	if x != nil {
		return x.BlocksTilMaturity
	}
	return 0
}

func (x *PendingChannelsResponse_ForceClosedChannel) GetRecoveredBalance() int64 {
	if x != nil {
		return x.RecoveredBalance
	}
	return 0
}

func (x *PendingChannelsResponse_ForceClosedChannel) GetPendingHtlcs() []*PendingHTLC {
	if x != nil {
		return x.PendingHtlcs
	}
	return nil
}

func (x *PendingChannelsResponse_ForceClosedChannel) GetAnchor() PendingChannelsResponse_ForceClosedChannel_AnchorState {
	if x != nil {
		return x.Anchor
	}
	return PendingChannelsResponse_ForceClosedChannel_LIMBO
}

var File_lightning_proto protoreflect.FileDescriptor

const file_lightning_proto_rawDesc = "" +
	"\n" +
	"\x0flightning.proto\x12\x05lnrpc\"U\n" +
	"\x1bLookupHtlcResolutionRequest\x12\x17\n" +
	"\achan_id\x18\x01 \x01(\x04R\x06chanId\x12\x1d\n" +
	"\n" +
	"htlc_index\x18\x02 \x01(\x04R\thtlcIndex\"T\n" +
	"\x1cLookupHtlcResolutionResponse\x12\x18\n" +
	"\asettled\x18\x01 \x01(\bR\asettled\x12\x1a\n" +
	"\boffchain\x18\x02 \x01(\bR\boffchain\" \n" +
	"\x1eSubscribeCustomMessagesRequest\"K\n" +
	"\rCustomMessage\x12\x12\n" +
	"\x04peer\x18\x01 \x01(\fR\x04peer\x12\x12\n" +
	"\x04type\x18\x02 \x01(\rR\x04type\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\"V\n" +
	"\x18SendCustomMessageRequest\x12\x12\n" +
	"\x04peer\x18\x01 \x01(\fR\x04peer\x12\x12\n" +
	"\x04type\x18\x02 \x01(\rR\x04type\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\"3\n" +
	"\x19SendCustomMessageResponse\x12\x16\n" +
	"\x06status\x18\x01 \x01(\tR\x06status\"\x1f\n" +
	"\x1dSubscribeOnionMessagesRequest\"S\n" +
	"\fOnionMessage\x12\x12\n" +
	"\x04peer\x18\x01 \x01(\fR\x04peer\x12\x19\n" +
	"\bpath_key\x18\x02 \x01(\fR\apathKey\x12\x14\n" +
	"\x05onion\x18\x03 \x01(\fR\x05onion\"^\n" +
	"\x17SendOnionMessageRequest\x12\x12\n" +
	"\x04peer\x18\x01 \x01(\fR\x04peer\x12\x19\n" +
	"\bpath_key\x18\x02 \x01(\fR\apathKey\x12\x14\n" +
	"\x05onion\x18\x03 \x01(\fR\x05onion\"2\n" +
	"\x18SendOnionMessageResponse\x12\x16\n" +
	"\x06status\x18\x01 \x01(\tR\x06status\"\xe6\x01\n" +
	"\x04Utxo\x125\n" +
	"\faddress_type\x18\x01 \x01(\x0e2\x12.lnrpc.AddressTypeR\vaddressType\x12\x18\n" +
	"\aaddress\x18\x02 \x01(\tR\aaddress\x12\x1d\n" +
	"\n" +
	"amount_sat\x18\x03 \x01(\x03R\tamountSat\x12\x1b\n" +
	"\tpk_script\x18\x04 \x01(\tR\bpkScript\x12+\n" +
	"\boutpoint\x18\x05 \x01(\v2\x0f.lnrpc.OutPointR\boutpoint\x12$\n" +
	"\rconfirmations\x18\x06 \x01(\x03R\rconfirmations\"\xe0\x01\n" +
	"\fOutputDetail\x128\n" +
	"\voutput_type\x18\x01 \x01(\x0e2\x17.lnrpc.OutputScriptTypeR\n" +
	"outputType\x12\x18\n" +
	"\aaddress\x18\x02 \x01(\tR\aaddress\x12\x1b\n" +
	"\tpk_script\x18\x03 \x01(\tR\bpkScript\x12!\n" +
	"\foutput_index\x18\x04 \x01(\x03R\voutputIndex\x12\x16\n" +
	"\x06amount\x18\x05 \x01(\x03R\x06amount\x12$\n" +
	"\x0eis_our_address\x18\x06 \x01(\bR\fisOurAddress\"\xce\x03\n" +
	"\vTransaction\x12\x17\n" +
	"\atx_hash\x18\x01 \x01(\tR\x06txHash\x12\x16\n" +
	"\x06amount\x18\x02 \x01(\x03R\x06amount\x12+\n" +
	"\x11num_confirmations\x18\x03 \x01(\x05R\x10numConfirmations\x12\x1d\n" +
	"\n" +
	"block_hash\x18\x04 \x01(\tR\tblockHash\x12!\n" +
	"\fblock_height\x18\x05 \x01(\x05R\vblockHeight\x12\x1d\n" +
	"\n" +
	"time_stamp\x18\x06 \x01(\x03R\ttimeStamp\x12\x1d\n" +
	"\n" +
	"total_fees\x18\a \x01(\x03R\ttotalFees\x12)\n" +
	"\x0edest_addresses\x18\b \x03(\tB\x02\x18\x01R\rdestAddresses\x12:\n" +
	"\x0eoutput_details\x18\v \x03(\v2\x13.lnrpc.OutputDetailR\routputDetails\x12\x1c\n" +
	"\n" +
	"raw_tx_hex\x18\t \x01(\tR\brawTxHex\x12\x14\n" +
	"\x05label\x18\n" +
	" \x01(\tR\x05label\x12F\n" +
	"\x12previous_outpoints\x18\f \x03(\v2\x17.lnrpc.PreviousOutPointR\x11previousOutpoints\"\xc2\x01\n" +
	"\x16GetTransactionsRequest\x12!\n" +
	"\fstart_height\x18\x01 \x01(\x05R\vstartHeight\x12\x1d\n" +
	"\n" +
	"end_height\x18\x02 \x01(\x05R\tendHeight\x12\x18\n" +
	"\aaccount\x18\x03 \x01(\tR\aaccount\x12!\n" +
	"\findex_offset\x18\x04 \x01(\rR\vindexOffset\x12)\n" +
	"\x10max_transactions\x18\x05 \x01(\rR\x0fmaxTransactions\"\x8c\x01\n" +
	"\x12TransactionDetails\x126\n" +
	"\ftransactions\x18\x01 \x03(\v2\x12.lnrpc.TransactionR\ftransactions\x12\x1d\n" +
	"\n" +
	"last_index\x18\x02 \x01(\x04R\tlastIndex\x12\x1f\n" +
	"\vfirst_index\x18\x03 \x01(\x04R\n" +
	"firstIndex\"h\n" +
	"\bFeeLimit\x12\x16\n" +
	"\x05fixed\x18\x01 \x01(\x03H\x00R\x05fixed\x12\x1f\n" +
	"\n" +
	"fixed_msat\x18\x03 \x01(\x03H\x00R\tfixedMsat\x12\x1a\n" +
	"\apercent\x18\x02 \x01(\x03H\x00R\apercentB\a\n" +
	"\x05limit\"\xea\x05\n" +
	"\vSendRequest\x12\x12\n" +
	"\x04dest\x18\x01 \x01(\fR\x04dest\x12#\n" +
	"\vdest_string\x18\x02 \x01(\tB\x02\x18\x01R\n" +
	"destString\x12\x10\n" +
	"\x03amt\x18\x03 \x01(\x03R\x03amt\x12\x19\n" +
	"\bamt_msat\x18\f \x01(\x03R\aamtMsat\x12!\n" +
	"\fpayment_hash\x18\x04 \x01(\fR\vpaymentHash\x122\n" +
	"\x13payment_hash_string\x18\x05 \x01(\tB\x02\x18\x01R\x11paymentHashString\x12'\n" +
	"\x0fpayment_request\x18\x06 \x01(\tR\x0epaymentRequest\x12(\n" +
	"\x10final_cltv_delta\x18\a \x01(\x05R\x0efinalCltvDelta\x12,\n" +
	"\tfee_limit\x18\b \x01(\v2\x0f.lnrpc.FeeLimitR\bfeeLimit\x12,\n" +
	"\x10outgoing_chan_id\x18\t \x01(\x04B\x020\x01R\x0eoutgoingChanId\x12&\n" +
	"\x0flast_hop_pubkey\x18\r \x01(\fR\rlastHopPubkey\x12\x1d\n" +
	"\n" +
	"cltv_limit\x18\n" +
	" \x01(\rR\tcltvLimit\x12Y\n" +
	"\x13dest_custom_records\x18\v \x03(\v2).lnrpc.SendRequest.DestCustomRecordsEntryR\x11destCustomRecords\x12,\n" +
	"\x12allow_self_payment\x18\x0e \x01(\bR\x10allowSelfPayment\x126\n" +
	"\rdest_features\x18\x0f \x03(\x0e2\x11.lnrpc.FeatureBitR\fdestFeatures\x12!\n" +
	"\fpayment_addr\x18\x10 \x01(\fR\vpaymentAddr\x1aD\n" +
	"\x16DestCustomRecordsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x04R\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"\xb4\x01\n" +
	"\fSendResponse\x12#\n" +
	"\rpayment_error\x18\x01 \x01(\tR\fpaymentError\x12)\n" +
	"\x10payment_preimage\x18\x02 \x01(\fR\x0fpaymentPreimage\x121\n" +
	"\rpayment_route\x18\x03 \x01(\v2\f.lnrpc.RouteR\fpaymentRoute\x12!\n" +
	"\fpayment_hash\x18\x04 \x01(\fR\vpaymentHash\"\x95\x01\n" +
	"\x12SendToRouteRequest\x12!\n" +
	"\fpayment_hash\x18\x01 \x01(\fR\vpaymentHash\x122\n" +
	"\x13payment_hash_string\x18\x02 \x01(\tB\x02\x18\x01R\x11paymentHashString\x12\"\n" +
	"\x05route\x18\x04 \x01(\v2\f.lnrpc.RouteR\x05routeJ\x04\b\x03\x10\x04\"\xec\x04\n" +
	"\x14ChannelAcceptRequest\x12\x1f\n" +
	"\vnode_pubkey\x18\x01 \x01(\fR\n" +
	"nodePubkey\x12\x1d\n" +
	"\n" +
	"chain_hash\x18\x02 \x01(\fR\tchainHash\x12&\n" +
	"\x0fpending_chan_id\x18\x03 \x01(\fR\rpendingChanId\x12\x1f\n" +
	"\vfunding_amt\x18\x04 \x01(\x04R\n" +
	"fundingAmt\x12\x19\n" +
	"\bpush_amt\x18\x05 \x01(\x04R\apushAmt\x12\x1d\n" +
	"\n" +
	"dust_limit\x18\x06 \x01(\x04R\tdustLimit\x12-\n" +
	"\x13max_value_in_flight\x18\a \x01(\x04R\x10maxValueInFlight\x12'\n" +
	"\x0fchannel_reserve\x18\b \x01(\x04R\x0echannelReserve\x12\x19\n" +
	"\bmin_htlc\x18\t \x01(\x04R\aminHtlc\x12\x1c\n" +
	"\n" +
	"fee_per_kw\x18\n" +
	" \x01(\x04R\bfeePerKw\x12\x1b\n" +
	"\tcsv_delay\x18\v \x01(\rR\bcsvDelay\x12,\n" +
	"\x12max_accepted_htlcs\x18\f \x01(\rR\x10maxAcceptedHtlcs\x12#\n" +
	"\rchannel_flags\x18\r \x01(\rR\fchannelFlags\x12>\n" +
	"\x0fcommitment_type\x18\x0e \x01(\x0e2\x15.lnrpc.CommitmentTypeR\x0ecommitmentType\x12&\n" +
	"\x0fwants_zero_conf\x18\x0f \x01(\bR\rwantsZeroConf\x12(\n" +
	"\x10wants_scid_alias\x18\x10 \x01(\bR\x0ewantsScidAlias\"\x90\x03\n" +
	"\x15ChannelAcceptResponse\x12\x16\n" +
	"\x06accept\x18\x01 \x01(\bR\x06accept\x12&\n" +
	"\x0fpending_chan_id\x18\x02 \x01(\fR\rpendingChanId\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\x12)\n" +
	"\x10upfront_shutdown\x18\x04 \x01(\tR\x0fupfrontShutdown\x12\x1b\n" +
	"\tcsv_delay\x18\x05 \x01(\rR\bcsvDelay\x12\x1f\n" +
	"\vreserve_sat\x18\x06 \x01(\x04R\n" +
	"reserveSat\x12+\n" +
	"\x12in_flight_max_msat\x18\a \x01(\x04R\x0finFlightMaxMsat\x12$\n" +
	"\x0emax_htlc_count\x18\b \x01(\rR\fmaxHtlcCount\x12\x1e\n" +
	"\vmin_htlc_in\x18\t \x01(\x04R\tminHtlcIn\x12(\n" +
	"\x10min_accept_depth\x18\n" +
	" \x01(\rR\x0eminAcceptDepth\x12\x1b\n" +
	"\tzero_conf\x18\v \x01(\bR\bzeroConf\"\x9d\x01\n" +
	"\fChannelPoint\x12.\n" +
	"\x12funding_txid_bytes\x18\x01 \x01(\fH\x00R\x10fundingTxidBytes\x12*\n" +
	"\x10funding_txid_str\x18\x02 \x01(\tH\x00R\x0efundingTxidStr\x12!\n" +
	"\foutput_index\x18\x03 \x01(\rR\voutputIndexB\x0e\n" +
	"\ffunding_txid\"g\n" +
	"\bOutPoint\x12\x1d\n" +
	"\n" +
	"txid_bytes\x18\x01 \x01(\fR\ttxidBytes\x12\x19\n" +
	"\btxid_str\x18\x02 \x01(\tR\atxidStr\x12!\n" +
	"\foutput_index\x18\x03 \x01(\rR\voutputIndex\"R\n" +
	"\x10PreviousOutPoint\x12\x1a\n" +
	"\boutpoint\x18\x01 \x01(\tR\boutpoint\x12\"\n" +
	"\ris_our_output\x18\x02 \x01(\bR\visOurOutput\">\n" +
	"\x10LightningAddress\x12\x16\n" +
	"\x06pubkey\x18\x01 \x01(\tR\x06pubkey\x12\x12\n" +
	"\x04host\x18\x02 \x01(\tR\x04host\"\xe7\x02\n" +
	"\x12EstimateFeeRequest\x12O\n" +
	"\fAddrToAmount\x18\x01 \x03(\v2+.lnrpc.EstimateFeeRequest.AddrToAmountEntryR\fAddrToAmount\x12\x1f\n" +
	"\vtarget_conf\x18\x02 \x01(\x05R\n" +
	"targetConf\x12\x1b\n" +
	"\tmin_confs\x18\x03 \x01(\x05R\bminConfs\x12+\n" +
	"\x11spend_unconfirmed\x18\x04 \x01(\bR\x10spendUnconfirmed\x12T\n" +
	"\x17coin_selection_strategy\x18\x05 \x01(\x0e2\x1c.lnrpc.CoinSelectionStrategyR\x15coinSelectionStrategy\x1a?\n" +
	"\x11AddrToAmountEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x03R\x05value:\x028\x01\"\x87\x01\n" +
	"\x13EstimateFeeResponse\x12\x17\n" +
	"\afee_sat\x18\x01 \x01(\x03R\x06feeSat\x123\n" +
	"\x14feerate_sat_per_byte\x18\x02 \x01(\x03B\x02\x18\x01R\x11feerateSatPerByte\x12\"\n" +
	"\rsat_per_vbyte\x18\x03 \x01(\x04R\vsatPerVbyte\"\xc1\x03\n" +
	"\x0fSendManyRequest\x12L\n" +
	"\fAddrToAmount\x18\x01 \x03(\v2(.lnrpc.SendManyRequest.AddrToAmountEntryR\fAddrToAmount\x12\x1f\n" +
	"\vtarget_conf\x18\x03 \x01(\x05R\n" +
	"targetConf\x12\"\n" +
	"\rsat_per_vbyte\x18\x04 \x01(\x04R\vsatPerVbyte\x12$\n" +
	"\fsat_per_byte\x18\x05 \x01(\x03B\x02\x18\x01R\n" +
	"satPerByte\x12\x14\n" +
	"\x05label\x18\x06 \x01(\tR\x05label\x12\x1b\n" +
	"\tmin_confs\x18\a \x01(\x05R\bminConfs\x12+\n" +
	"\x11spend_unconfirmed\x18\b \x01(\bR\x10spendUnconfirmed\x12T\n" +
	"\x17coin_selection_strategy\x18\t \x01(\x0e2\x1c.lnrpc.CoinSelectionStrategyR\x15coinSelectionStrategy\x1a?\n" +
	"\x11AddrToAmountEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x03R\x05value:\x028\x01\"&\n" +
	"\x10SendManyResponse\x12\x12\n" +
	"\x04txid\x18\x01 \x01(\tR\x04txid\"\xa9\x03\n" +
	"\x10SendCoinsRequest\x12\x12\n" +
	"\x04addr\x18\x01 \x01(\tR\x04addr\x12\x16\n" +
	"\x06amount\x18\x02 \x01(\x03R\x06amount\x12\x1f\n" +
	"\vtarget_conf\x18\x03 \x01(\x05R\n" +
	"targetConf\x12\"\n" +
	"\rsat_per_vbyte\x18\x04 \x01(\x04R\vsatPerVbyte\x12$\n" +
	"\fsat_per_byte\x18\x05 \x01(\x03B\x02\x18\x01R\n" +
	"satPerByte\x12\x19\n" +
	"\bsend_all\x18\x06 \x01(\bR\asendAll\x12\x14\n" +
	"\x05label\x18\a \x01(\tR\x05label\x12\x1b\n" +
	"\tmin_confs\x18\b \x01(\x05R\bminConfs\x12+\n" +
	"\x11spend_unconfirmed\x18\t \x01(\bR\x10spendUnconfirmed\x12T\n" +
	"\x17coin_selection_strategy\x18\n" +
	" \x01(\x0e2\x1c.lnrpc.CoinSelectionStrategyR\x15coinSelectionStrategy\x12-\n" +
	"\toutpoints\x18\v \x03(\v2\x0f.lnrpc.OutPointR\toutpoints\"'\n" +
	"\x11SendCoinsResponse\x12\x12\n" +
	"\x04txid\x18\x01 \x01(\tR\x04txid\"h\n" +
	"\x12ListUnspentRequest\x12\x1b\n" +
	"\tmin_confs\x18\x01 \x01(\x05R\bminConfs\x12\x1b\n" +
	"\tmax_confs\x18\x02 \x01(\x05R\bmaxConfs\x12\x18\n" +
	"\aaccount\x18\x03 \x01(\tR\aaccount\"8\n" +
	"\x13ListUnspentResponse\x12!\n" +
	"\x05utxos\x18\x01 \x03(\v2\v.lnrpc.UtxoR\x05utxos\"U\n" +
	"\x11NewAddressRequest\x12&\n" +
	"\x04type\x18\x01 \x01(\x0e2\x12.lnrpc.AddressTypeR\x04type\x12\x18\n" +
	"\aaccount\x18\x02 \x01(\tR\aaccount\".\n" +
	"\x12NewAddressResponse\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\"G\n" +
	"\x12SignMessageRequest\x12\x10\n" +
	"\x03msg\x18\x01 \x01(\fR\x03msg\x12\x1f\n" +
	"\vsingle_hash\x18\x02 \x01(\bR\n" +
	"singleHash\"3\n" +
	"\x13SignMessageResponse\x12\x1c\n" +
	"\tsignature\x18\x01 \x01(\tR\tsignature\"F\n" +
	"\x14VerifyMessageRequest\x12\x10\n" +
	"\x03msg\x18\x01 \x01(\fR\x03msg\x12\x1c\n" +
	"\tsignature\x18\x02 \x01(\tR\tsignature\"E\n" +
	"\x15VerifyMessageResponse\x12\x14\n" +
	"\x05valid\x18\x01 \x01(\bR\x05valid\x12\x16\n" +
	"\x06pubkey\x18\x02 \x01(\tR\x06pubkey\"o\n" +
	"\x12ConnectPeerRequest\x12+\n" +
	"\x04addr\x18\x01 \x01(\v2\x17.lnrpc.LightningAddressR\x04addr\x12\x12\n" +
	"\x04perm\x18\x02 \x01(\bR\x04perm\x12\x18\n" +
	"\atimeout\x18\x03 \x01(\x04R\atimeout\"-\n" +
	"\x13ConnectPeerResponse\x12\x16\n" +
	"\x06status\x18\x01 \x01(\tR\x06status\"0\n" +
	"\x15DisconnectPeerRequest\x12\x17\n" +
	"\apub_key\x18\x01 \x01(\tR\x06pubKey\"0\n" +
	"\x16DisconnectPeerResponse\x12\x16\n" +
	"\x06status\x18\x01 \x01(\tR\x06status\"\xa3\x02\n" +
	"\x04HTLC\x12\x1a\n" +
	"\bincoming\x18\x01 \x01(\bR\bincoming\x12\x16\n" +
	"\x06amount\x18\x02 \x01(\x03R\x06amount\x12\x1b\n" +
	"\thash_lock\x18\x03 \x01(\fR\bhashLock\x12+\n" +
	"\x11expiration_height\x18\x04 \x01(\rR\x10expirationHeight\x12\x1d\n" +
	"\n" +
	"htlc_index\x18\x05 \x01(\x04R\thtlcIndex\x12-\n" +
	"\x12forwarding_channel\x18\x06 \x01(\x04R\x11forwardingChannel\x122\n" +
	"\x15forwarding_htlc_index\x18\a \x01(\x04R\x13forwardingHtlcIndex\x12\x1b\n" +
	"\tlocked_in\x18\b \x01(\bR\blockedIn\"\x84\x02\n" +
	"\x12ChannelConstraints\x12\x1b\n" +
	"\tcsv_delay\x18\x01 \x01(\rR\bcsvDelay\x12(\n" +
	"\x10chan_reserve_sat\x18\x02 \x01(\x04R\x0echanReserveSat\x12$\n" +
	"\x0edust_limit_sat\x18\x03 \x01(\x04R\fdustLimitSat\x12/\n" +
	"\x14max_pending_amt_msat\x18\x04 \x01(\x04R\x11maxPendingAmtMsat\x12\"\n" +
	"\rmin_htlc_msat\x18\x05 \x01(\x04R\vminHtlcMsat\x12,\n" +
	"\x12max_accepted_htlcs\x18\x06 \x01(\rR\x10maxAcceptedHtlcs\"\xdd\v\n" +
	"\aChannel\x12\x16\n" +
	"\x06active\x18\x01 \x01(\bR\x06active\x12#\n" +
	"\rremote_pubkey\x18\x02 \x01(\tR\fremotePubkey\x12#\n" +
	"\rchannel_point\x18\x03 \x01(\tR\fchannelPoint\x12\x1b\n" +
	"\achan_id\x18\x04 \x01(\x04B\x020\x01R\x06chanId\x12\x1a\n" +
	"\bcapacity\x18\x05 \x01(\x03R\bcapacity\x12#\n" +
	"\rlocal_balance\x18\x06 \x01(\x03R\flocalBalance\x12%\n" +
	"\x0eremote_balance\x18\a \x01(\x03R\rremoteBalance\x12\x1d\n" +
	"\n" +
	"commit_fee\x18\b \x01(\x03R\tcommitFee\x12#\n" +
	"\rcommit_weight\x18\t \x01(\x03R\fcommitWeight\x12\x1c\n" +
	"\n" +
	"fee_per_kw\x18\n" +
	" \x01(\x03R\bfeePerKw\x12+\n" +
	"\x11unsettled_balance\x18\v \x01(\x03R\x10unsettledBalance\x12.\n" +
	"\x13total_satoshis_sent\x18\f \x01(\x03R\x11totalSatoshisSent\x126\n" +
	"\x17total_satoshis_received\x18\r \x01(\x03R\x15totalSatoshisReceived\x12\x1f\n" +
	"\vnum_updates\x18\x0e \x01(\x04R\n" +
	"numUpdates\x120\n" +
	"\rpending_htlcs\x18\x0f \x03(\v2\v.lnrpc.HTLCR\fpendingHtlcs\x12\x1f\n" +
	"\tcsv_delay\x18\x10 \x01(\rB\x02\x18\x01R\bcsvDelay\x12\x18\n" +
	"\aprivate\x18\x11 \x01(\bR\aprivate\x12\x1c\n" +
	"\tinitiator\x18\x12 \x01(\bR\tinitiator\x12*\n" +
	"\x11chan_status_flags\x18\x13 \x01(\tR\x0fchanStatusFlags\x127\n" +
	"\x16local_chan_reserve_sat\x18\x14 \x01(\x03B\x02\x18\x01R\x13localChanReserveSat\x129\n" +
	"\x17remote_chan_reserve_sat\x18\x15 \x01(\x03B\x02\x18\x01R\x14remoteChanReserveSat\x12.\n" +
	"\x11static_remote_key\x18\x16 \x01(\bB\x02\x18\x01R\x0fstaticRemoteKey\x12>\n" +
	"\x0fcommitment_type\x18\x1a \x01(\x0e2\x15.lnrpc.CommitmentTypeR\x0ecommitmentType\x12\x1a\n" +
	"\blifetime\x18\x17 \x01(\x03R\blifetime\x12\x16\n" +
	"\x06uptime\x18\x18 \x01(\x03R\x06uptime\x12#\n" +
	"\rclose_address\x18\x19 \x01(\tR\fcloseAddress\x12&\n" +
	"\x0fpush_amount_sat\x18\x1b \x01(\x04R\rpushAmountSat\x12\x1f\n" +
	"\vthaw_height\x18\x1c \x01(\rR\n" +
	"thawHeight\x12F\n" +
	"\x11local_constraints\x18\x1d \x01(\v2\x19.lnrpc.ChannelConstraintsR\x10localConstraints\x12H\n" +
	"\x12remote_constraints\x18\x1e \x01(\v2\x19.lnrpc.ChannelConstraintsR\x11remoteConstraints\x12\x1f\n" +
	"\valias_scids\x18\x1f \x03(\x04R\n" +
	"aliasScids\x12\x1b\n" +
	"\tzero_conf\x18  \x01(\bR\bzeroConf\x127\n" +
	"\x18zero_conf_confirmed_scid\x18! \x01(\x04R\x15zeroConfConfirmedScid\x12\x1d\n" +
	"\n" +
	"peer_alias\x18\" \x01(\tR\tpeerAlias\x12*\n" +
	"\x0fpeer_scid_alias\x18# \x01(\x04B\x020\x01R\rpeerScidAlias\x12\x12\n" +
	"\x04memo\x18$ \x01(\tR\x04memo\x12.\n" +
	"\x13custom_channel_data\x18% \x01(\fR\x11customChannelData\"\xdf\x01\n" +
	"\x13ListChannelsRequest\x12\x1f\n" +
	"\vactive_only\x18\x01 \x01(\bR\n" +
	"activeOnly\x12#\n" +
	"\rinactive_only\x18\x02 \x01(\bR\finactiveOnly\x12\x1f\n" +
	"\vpublic_only\x18\x03 \x01(\bR\n" +
	"publicOnly\x12!\n" +
	"\fprivate_only\x18\x04 \x01(\bR\vprivateOnly\x12\x12\n" +
	"\x04peer\x18\x05 \x01(\fR\x04peer\x12*\n" +
	"\x11peer_alias_lookup\x18\x06 \x01(\bR\x0fpeerAliasLookup\"B\n" +
	"\x14ListChannelsResponse\x12*\n" +
	"\bchannels\x18\v \x03(\v2\x0e.lnrpc.ChannelR\bchannels\"A\n" +
	"\bAliasMap\x12\x1b\n" +
	"\tbase_scid\x18\x01 \x01(\x04R\bbaseScid\x12\x18\n" +
	"\aaliases\x18\x02 \x03(\x04R\aaliases\"\x14\n" +
	"\x12ListAliasesRequest\"E\n" +
	"\x13ListAliasesResponse\x12.\n" +
	"\n" +
	"alias_maps\x18\x01 \x03(\v2\x0f.lnrpc.AliasMapR\taliasMaps\"\xe6\x06\n" +
	"\x13ChannelCloseSummary\x12#\n" +
	"\rchannel_point\x18\x01 \x01(\tR\fchannelPoint\x12\x1b\n" +
	"\achan_id\x18\x02 \x01(\x04B\x020\x01R\x06chanId\x12\x1d\n" +
	"\n" +
	"chain_hash\x18\x03 \x01(\tR\tchainHash\x12&\n" +
	"\x0fclosing_tx_hash\x18\x04 \x01(\tR\rclosingTxHash\x12#\n" +
	"\rremote_pubkey\x18\x05 \x01(\tR\fremotePubkey\x12\x1a\n" +
	"\bcapacity\x18\x06 \x01(\x03R\bcapacity\x12!\n" +
	"\fclose_height\x18\a \x01(\rR\vcloseHeight\x12'\n" +
	"\x0fsettled_balance\x18\b \x01(\x03R\x0esettledBalance\x12.\n" +
	"\x13time_locked_balance\x18\t \x01(\x03R\x11timeLockedBalance\x12E\n" +
	"\n" +
	"close_type\x18\n" +
	" \x01(\x0e2&.lnrpc.ChannelCloseSummary.ClosureTypeR\tcloseType\x127\n" +
	"\x0eopen_initiator\x18\v \x01(\x0e2\x10.lnrpc.InitiatorR\ropenInitiator\x129\n" +
	"\x0fclose_initiator\x18\f \x01(\x0e2\x10.lnrpc.InitiatorR\x0ecloseInitiator\x123\n" +
	"\vresolutions\x18\r \x03(\v2\x11.lnrpc.ResolutionR\vresolutions\x12\x1f\n" +
	"\valias_scids\x18\x0e \x03(\x04R\n" +
	"aliasScids\x12;\n" +
	"\x18zero_conf_confirmed_scid\x18\x0f \x01(\x04B\x020\x01R\x15zeroConfConfirmedScid\x12.\n" +
	"\x13custom_channel_data\x18\x10 \x01(\fR\x11customChannelData\"\x8a\x01\n" +
	"\vClosureType\x12\x15\n" +
	"\x11COOPERATIVE_CLOSE\x10\x00\x12\x15\n" +
	"\x11LOCAL_FORCE_CLOSE\x10\x01\x12\x16\n" +
	"\x12REMOTE_FORCE_CLOSE\x10\x02\x12\x10\n" +
	"\fBREACH_CLOSE\x10\x03\x12\x14\n" +
	"\x10FUNDING_CANCELED\x10\x04\x12\r\n" +
	"\tABANDONED\x10\x05\"\xeb\x01\n" +
	"\n" +
	"Resolution\x12>\n" +
	"\x0fresolution_type\x18\x01 \x01(\x0e2\x15.lnrpc.ResolutionTypeR\x0eresolutionType\x122\n" +
	"\aoutcome\x18\x02 \x01(\x0e2\x18.lnrpc.ResolutionOutcomeR\aoutcome\x12+\n" +
	"\boutpoint\x18\x03 \x01(\v2\x0f.lnrpc.OutPointR\boutpoint\x12\x1d\n" +
	"\n" +
	"amount_sat\x18\x04 \x01(\x04R\tamountSat\x12\x1d\n" +
	"\n" +
	"sweep_txid\x18\x05 \x01(\tR\tsweepTxid\"\xde\x01\n" +
	"\x15ClosedChannelsRequest\x12 \n" +
	"\vcooperative\x18\x01 \x01(\bR\vcooperative\x12\x1f\n" +
	"\vlocal_force\x18\x02 \x01(\bR\n" +
	"localForce\x12!\n" +
	"\fremote_force\x18\x03 \x01(\bR\vremoteForce\x12\x16\n" +
	"\x06breach\x18\x04 \x01(\bR\x06breach\x12)\n" +
	"\x10funding_canceled\x18\x05 \x01(\bR\x0ffundingCanceled\x12\x1c\n" +
	"\tabandoned\x18\x06 \x01(\bR\tabandoned\"P\n" +
	"\x16ClosedChannelsResponse\x126\n" +
	"\bchannels\x18\x01 \x03(\v2\x1a.lnrpc.ChannelCloseSummaryR\bchannels\"\x8b\x05\n" +
	"\x04Peer\x12\x17\n" +
	"\apub_key\x18\x01 \x01(\tR\x06pubKey\x12\x18\n" +
	"\aaddress\x18\x03 \x01(\tR\aaddress\x12\x1d\n" +
	"\n" +
	"bytes_sent\x18\x04 \x01(\x04R\tbytesSent\x12\x1d\n" +
	"\n" +
	"bytes_recv\x18\x05 \x01(\x04R\tbytesRecv\x12\x19\n" +
	"\bsat_sent\x18\x06 \x01(\x03R\asatSent\x12\x19\n" +
	"\bsat_recv\x18\a \x01(\x03R\asatRecv\x12\x18\n" +
	"\ainbound\x18\b \x01(\bR\ainbound\x12\x1b\n" +
	"\tping_time\x18\t \x01(\x03R\bpingTime\x121\n" +
	"\tsync_type\x18\n" +
	" \x01(\x0e2\x14.lnrpc.Peer.SyncTypeR\bsyncType\x125\n" +
	"\bfeatures\x18\v \x03(\v2\x19.lnrpc.Peer.FeaturesEntryR\bfeatures\x12/\n" +
	"\x06errors\x18\f \x03(\v2\x17.lnrpc.TimestampedErrorR\x06errors\x12\x1d\n" +
	"\n" +
	"flap_count\x18\r \x01(\x05R\tflapCount\x12 \n" +
	"\flast_flap_ns\x18\x0e \x01(\x03R\n" +
	"lastFlapNs\x12*\n" +
	"\x11last_ping_payload\x18\x0f \x01(\fR\x0flastPingPayload\x1aK\n" +
	"\rFeaturesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\rR\x03key\x12$\n" +
	"\x05value\x18\x02 \x01(\v2\x0e.lnrpc.FeatureR\x05value:\x028\x01\"P\n" +
	"\bSyncType\x12\x10\n" +
	"\fUNKNOWN_SYNC\x10\x00\x12\x0f\n" +
	"\vACTIVE_SYNC\x10\x01\x12\x10\n" +
	"\fPASSIVE_SYNC\x10\x02\x12\x0f\n" +
	"\vPINNED_SYNC\x10\x03\"F\n" +
	"\x10TimestampedError\x12\x1c\n" +
	"\ttimestamp\x18\x01 \x01(\x04R\ttimestamp\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"5\n" +
	"\x10ListPeersRequest\x12!\n" +
	"\flatest_error\x18\x01 \x01(\bR\vlatestError\"6\n" +
	"\x11ListPeersResponse\x12!\n" +
	"\x05peers\x18\x01 \x03(\v2\v.lnrpc.PeerR\x05peers\"\x17\n" +
	"\x15PeerEventSubscription\"\x84\x01\n" +
	"\tPeerEvent\x12\x17\n" +
	"\apub_key\x18\x01 \x01(\tR\x06pubKey\x12.\n" +
	"\x04type\x18\x02 \x01(\x0e2\x1a.lnrpc.PeerEvent.EventTypeR\x04type\".\n" +
	"\tEventType\x12\x0f\n" +
	"\vPEER_ONLINE\x10\x00\x12\x10\n" +
	"\fPEER_OFFLINE\x10\x01\"\x10\n" +
	"\x0eGetInfoRequest\"\x82\a\n" +
	"\x0fGetInfoResponse\x12\x18\n" +
	"\aversion\x18\x0e \x01(\tR\aversion\x12\x1f\n" +
	"\vcommit_hash\x18\x14 \x01(\tR\n" +
	"commitHash\x12'\n" +
	"\x0fidentity_pubkey\x18\x01 \x01(\tR\x0eidentityPubkey\x12\x14\n" +
	"\x05alias\x18\x02 \x01(\tR\x05alias\x12\x14\n" +
	"\x05color\x18\x11 \x01(\tR\x05color\x120\n" +
	"\x14num_pending_channels\x18\x03 \x01(\rR\x12numPendingChannels\x12.\n" +
	"\x13num_active_channels\x18\x04 \x01(\rR\x11numActiveChannels\x122\n" +
	"\x15num_inactive_channels\x18\x0f \x01(\rR\x13numInactiveChannels\x12\x1b\n" +
	"\tnum_peers\x18\x05 \x01(\rR\bnumPeers\x12!\n" +
	"\fblock_height\x18\x06 \x01(\rR\vblockHeight\x12\x1d\n" +
	"\n" +
	"block_hash\x18\b \x01(\tR\tblockHash\x122\n" +
	"\x15best_header_timestamp\x18\r \x01(\x03R\x13bestHeaderTimestamp\x12&\n" +
	"\x0fsynced_to_chain\x18\t \x01(\bR\rsyncedToChain\x12&\n" +
	"\x0fsynced_to_graph\x18\x12 \x01(\bR\rsyncedToGraph\x12\x1c\n" +
	"\atestnet\x18\n" +
	" \x01(\bB\x02\x18\x01R\atestnet\x12$\n" +
	"\x06chains\x18\x10 \x03(\v2\f.lnrpc.ChainR\x06chains\x12\x12\n" +
	"\x04uris\x18\f \x03(\tR\x04uris\x12@\n" +
	"\bfeatures\x18\x13 \x03(\v2$.lnrpc.GetInfoResponse.FeaturesEntryR\bfeatures\x128\n" +
	"\x18require_htlc_interceptor\x18\x15 \x01(\bR\x16requireHtlcInterceptor\x12?\n" +
	"\x1cstore_final_htlc_resolutions\x18\x16 \x01(\bR\x19storeFinalHtlcResolutions\x1aK\n" +
	"\rFeaturesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\rR\x03key\x12$\n" +
	"\x05value\x18\x02 \x01(\v2\x0e.lnrpc.FeatureR\x05value:\x028\x01J\x04\b\v\x10\f\"\x15\n" +
	"\x13GetDebugInfoRequest\"\xa4\x01\n" +
	"\x14GetDebugInfoResponse\x12?\n" +
	"\x06config\x18\x01 \x03(\v2'.lnrpc.GetDebugInfoResponse.ConfigEntryR\x06config\x12\x10\n" +
	"\x03log\x18\x02 \x03(\tR\x03log\x1a9\n" +
	"\vConfigEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x18\n" +
	"\x16GetRecoveryInfoRequest\"\x87\x01\n" +
	"\x17GetRecoveryInfoResponse\x12#\n" +
	"\rrecovery_mode\x18\x01 \x01(\bR\frecoveryMode\x12+\n" +
	"\x11recovery_finished\x18\x02 \x01(\bR\x10recoveryFinished\x12\x1a\n" +
	"\bprogress\x18\x03 \x01(\x01R\bprogress\";\n" +
	"\x05Chain\x12\x18\n" +
	"\x05chain\x18\x01 \x01(\tB\x02\x18\x01R\x05chain\x12\x18\n" +
	"\anetwork\x18\x02 \x01(\tR\anetwork\"M\n" +
	"\x11ChannelOpenUpdate\x128\n" +
	"\rchannel_point\x18\x01 \x01(\v2\x13.lnrpc.ChannelPointR\fchannelPoint\"\x94\x01\n" +
	"\vCloseOutput\x12\x1d\n" +
	"\n" +
	"amount_sat\x18\x01 \x01(\x03R\tamountSat\x12\x1b\n" +
	"\tpk_script\x18\x02 \x01(\fR\bpkScript\x12\x19\n" +
	"\bis_local\x18\x03 \x01(\bR\aisLocal\x12.\n" +
	"\x13custom_channel_data\x18\x04 \x01(\fR\x11customChannelData\"\x9a\x02\n" +
	"\x12ChannelCloseUpdate\x12!\n" +
	"\fclosing_txid\x18\x01 \x01(\fR\vclosingTxid\x12\x18\n" +
	"\asuccess\x18\x02 \x01(\bR\asuccess\x12@\n" +
	"\x12local_close_output\x18\x03 \x01(\v2\x12.lnrpc.CloseOutputR\x10localCloseOutput\x12B\n" +
	"\x13remote_close_output\x18\x04 \x01(\v2\x12.lnrpc.CloseOutputR\x11remoteCloseOutput\x12A\n" +
	"\x12additional_outputs\x18\x05 \x03(\v2\x12.lnrpc.CloseOutputR\x11additionalOutputs\"\xbf\x02\n" +
	"\x13CloseChannelRequest\x128\n" +
	"\rchannel_point\x18\x01 \x01(\v2\x13.lnrpc.ChannelPointR\fchannelPoint\x12\x14\n" +
	"\x05force\x18\x02 \x01(\bR\x05force\x12\x1f\n" +
	"\vtarget_conf\x18\x03 \x01(\x05R\n" +
	"targetConf\x12$\n" +
	"\fsat_per_byte\x18\x04 \x01(\x03B\x02\x18\x01R\n" +
	"satPerByte\x12)\n" +
	"\x10delivery_address\x18\x05 \x01(\tR\x0fdeliveryAddress\x12\"\n" +
	"\rsat_per_vbyte\x18\x06 \x01(\x04R\vsatPerVbyte\x12)\n" +
	"\x11max_fee_per_vbyte\x18\a \x01(\x04R\x0emaxFeePerVbyte\x12\x17\n" +
	"\ano_wait\x18\b \x01(\bR\x06noWait\"\xd3\x01\n" +
	"\x11CloseStatusUpdate\x12;\n" +
	"\rclose_pending\x18\x01 \x01(\v2\x14.lnrpc.PendingUpdateH\x00R\fclosePending\x12:\n" +
	"\n" +
	"chan_close\x18\x03 \x01(\v2\x19.lnrpc.ChannelCloseUpdateH\x00R\tchanClose\x12;\n" +
	"\rclose_instant\x18\x04 \x01(\v2\x14.lnrpc.InstantUpdateH\x00R\fcloseInstantB\b\n" +
	"\x06update\"\x90\x01\n" +
	"\rPendingUpdate\x12\x12\n" +
	"\x04txid\x18\x01 \x01(\fR\x04txid\x12!\n" +
	"\foutput_index\x18\x02 \x01(\rR\voutputIndex\x12\"\n" +
	"\rfee_per_vbyte\x18\x03 \x01(\x03R\vfeePerVbyte\x12$\n" +
	"\x0elocal_close_tx\x18\x04 \x01(\bR\flocalCloseTx\";\n" +
	"\rInstantUpdate\x12*\n" +
	"\x11num_pending_htlcs\x18\x01 \x01(\x05R\x0fnumPendingHtlcs\"y\n" +
	"\x13ReadyForPsbtFunding\x12'\n" +
	"\x0ffunding_address\x18\x01 \x01(\tR\x0efundingAddress\x12%\n" +
	"\x0efunding_amount\x18\x02 \x01(\x03R\rfundingAmount\x12\x12\n" +
	"\x04psbt\x18\x03 \x01(\fR\x04psbt\"\xc9\x02\n" +
	"\x17BatchOpenChannelRequest\x123\n" +
	"\bchannels\x18\x01 \x03(\v2\x17.lnrpc.BatchOpenChannelR\bchannels\x12\x1f\n" +
	"\vtarget_conf\x18\x02 \x01(\x05R\n" +
	"targetConf\x12\"\n" +
	"\rsat_per_vbyte\x18\x03 \x01(\x03R\vsatPerVbyte\x12\x1b\n" +
	"\tmin_confs\x18\x04 \x01(\x05R\bminConfs\x12+\n" +
	"\x11spend_unconfirmed\x18\x05 \x01(\bR\x10spendUnconfirmed\x12\x14\n" +
	"\x05label\x18\x06 \x01(\tR\x05label\x12T\n" +
	"\x17coin_selection_strategy\x18\a \x01(\x0e2\x1c.lnrpc.CoinSelectionStrategyR\x15coinSelectionStrategy\"\x89\x06\n" +
	"\x10BatchOpenChannel\x12\x1f\n" +
	"\vnode_pubkey\x18\x01 \x01(\fR\n" +
	"nodePubkey\x120\n" +
	"\x14local_funding_amount\x18\x02 \x01(\x03R\x12localFundingAmount\x12\x19\n" +
	"\bpush_sat\x18\x03 \x01(\x03R\apushSat\x12\x18\n" +
	"\aprivate\x18\x04 \x01(\bR\aprivate\x12\"\n" +
	"\rmin_htlc_msat\x18\x05 \x01(\x03R\vminHtlcMsat\x12(\n" +
	"\x10remote_csv_delay\x18\x06 \x01(\rR\x0eremoteCsvDelay\x12#\n" +
	"\rclose_address\x18\a \x01(\tR\fcloseAddress\x12&\n" +
	"\x0fpending_chan_id\x18\b \x01(\fR\rpendingChanId\x12>\n" +
	"\x0fcommitment_type\x18\t \x01(\x0e2\x15.lnrpc.CommitmentTypeR\x0ecommitmentType\x12C\n" +
	"\x1fremote_max_value_in_flight_msat\x18\n" +
	" \x01(\x04R\x1aremoteMaxValueInFlightMsat\x12(\n" +
	"\x10remote_max_htlcs\x18\v \x01(\rR\x0eremoteMaxHtlcs\x12\"\n" +
	"\rmax_local_csv\x18\f \x01(\rR\vmaxLocalCsv\x12\x1b\n" +
	"\tzero_conf\x18\r \x01(\bR\bzeroConf\x12\x1d\n" +
	"\n" +
	"scid_alias\x18\x0e \x01(\bR\tscidAlias\x12\x19\n" +
	"\bbase_fee\x18\x0f \x01(\x04R\abaseFee\x12\x19\n" +
	"\bfee_rate\x18\x10 \x01(\x04R\afeeRate\x12 \n" +
	"\fuse_base_fee\x18\x11 \x01(\bR\n" +
	"useBaseFee\x12 \n" +
	"\fuse_fee_rate\x18\x12 \x01(\bR\n" +
	"useFeeRate\x125\n" +
	"\x17remote_chan_reserve_sat\x18\x13 \x01(\x04R\x14remoteChanReserveSat\x12\x12\n" +
	"\x04memo\x18\x14 \x01(\tR\x04memo\"[\n" +
	"\x18BatchOpenChannelResponse\x12?\n" +
	"\x10pending_channels\x18\x01 \x03(\v2\x14.lnrpc.PendingUpdateR\x0fpendingChannels\"\xcb\b\n" +
	"\x12OpenChannelRequest\x12\"\n" +
	"\rsat_per_vbyte\x18\x01 \x01(\x04R\vsatPerVbyte\x12\x1f\n" +
	"\vnode_pubkey\x18\x02 \x01(\fR\n" +
	"nodePubkey\x120\n" +
	"\x12node_pubkey_string\x18\x03 \x01(\tB\x02\x18\x01R\x10nodePubkeyString\x120\n" +
	"\x14local_funding_amount\x18\x04 \x01(\x03R\x12localFundingAmount\x12\x19\n" +
	"\bpush_sat\x18\x05 \x01(\x03R\apushSat\x12\x1f\n" +
	"\vtarget_conf\x18\x06 \x01(\x05R\n" +
	"targetConf\x12$\n" +
	"\fsat_per_byte\x18\a \x01(\x03B\x02\x18\x01R\n" +
	"satPerByte\x12\x18\n" +
	"\aprivate\x18\b \x01(\bR\aprivate\x12\"\n" +
	"\rmin_htlc_msat\x18\t \x01(\x03R\vminHtlcMsat\x12(\n" +
	"\x10remote_csv_delay\x18\n" +
	" \x01(\rR\x0eremoteCsvDelay\x12\x1b\n" +
	"\tmin_confs\x18\v \x01(\x05R\bminConfs\x12+\n" +
	"\x11spend_unconfirmed\x18\f \x01(\bR\x10spendUnconfirmed\x12#\n" +
	"\rclose_address\x18\r \x01(\tR\fcloseAddress\x125\n" +
	"\ffunding_shim\x18\x0e \x01(\v2\x12.lnrpc.FundingShimR\vfundingShim\x12C\n" +
	"\x1fremote_max_value_in_flight_msat\x18\x0f \x01(\x04R\x1aremoteMaxValueInFlightMsat\x12(\n" +
	"\x10remote_max_htlcs\x18\x10 \x01(\rR\x0eremoteMaxHtlcs\x12\"\n" +
	"\rmax_local_csv\x18\x11 \x01(\rR\vmaxLocalCsv\x12>\n" +
	"\x0fcommitment_type\x18\x12 \x01(\x0e2\x15.lnrpc.CommitmentTypeR\x0ecommitmentType\x12\x1b\n" +
	"\tzero_conf\x18\x13 \x01(\bR\bzeroConf\x12\x1d\n" +
	"\n" +
	"scid_alias\x18\x14 \x01(\bR\tscidAlias\x12\x19\n" +
	"\bbase_fee\x18\x15 \x01(\x04R\abaseFee\x12\x19\n" +
	"\bfee_rate\x18\x16 \x01(\x04R\afeeRate\x12 \n" +
	"\fuse_base_fee\x18\x17 \x01(\bR\n" +
	"useBaseFee\x12 \n" +
	"\fuse_fee_rate\x18\x18 \x01(\bR\n" +
	"useFeeRate\x125\n" +
	"\x17remote_chan_reserve_sat\x18\x19 \x01(\x04R\x14remoteChanReserveSat\x12\x19\n" +
	"\bfund_max\x18\x1a \x01(\bR\afundMax\x12\x12\n" +
	"\x04memo\x18\x1b \x01(\tR\x04memo\x12-\n" +
	"\toutpoints\x18\x1c \x03(\v2\x0f.lnrpc.OutPointR\toutpoints\"\xf3\x01\n" +
	"\x10OpenStatusUpdate\x129\n" +
	"\fchan_pending\x18\x01 \x01(\v2\x14.lnrpc.PendingUpdateH\x00R\vchanPending\x127\n" +
	"\tchan_open\x18\x03 \x01(\v2\x18.lnrpc.ChannelOpenUpdateH\x00R\bchanOpen\x129\n" +
	"\tpsbt_fund\x18\x05 \x01(\v2\x1a.lnrpc.ReadyForPsbtFundingH\x00R\bpsbtFund\x12&\n" +
	"\x0fpending_chan_id\x18\x04 \x01(\fR\rpendingChanIdB\b\n" +
	"\x06update\"H\n" +
	"\n" +
	"KeyLocator\x12\x1d\n" +
	"\n" +
	"key_family\x18\x01 \x01(\x05R\tkeyFamily\x12\x1b\n" +
	"\tkey_index\x18\x02 \x01(\x05R\bkeyIndex\"_\n" +
	"\rKeyDescriptor\x12\"\n" +
	"\rraw_key_bytes\x18\x01 \x01(\fR\vrawKeyBytes\x12*\n" +
	"\akey_loc\x18\x02 \x01(\v2\x11.lnrpc.KeyLocatorR\x06keyLoc\"\x88\x02\n" +
	"\rChanPointShim\x12\x10\n" +
	"\x03amt\x18\x01 \x01(\x03R\x03amt\x122\n" +
	"\n" +
	"chan_point\x18\x02 \x01(\v2\x13.lnrpc.ChannelPointR\tchanPoint\x121\n" +
	"\tlocal_key\x18\x03 \x01(\v2\x14.lnrpc.KeyDescriptorR\blocalKey\x12\x1d\n" +
	"\n" +
	"remote_key\x18\x04 \x01(\fR\tremoteKey\x12&\n" +
	"\x0fpending_chan_id\x18\x05 \x01(\fR\rpendingChanId\x12\x1f\n" +
	"\vthaw_height\x18\x06 \x01(\rR\n" +
	"thawHeight\x12\x16\n" +
	"\x06musig2\x18\a \x01(\bR\x06musig2\"n\n" +
	"\bPsbtShim\x12&\n" +
	"\x0fpending_chan_id\x18\x01 \x01(\fR\rpendingChanId\x12\x1b\n" +
	"\tbase_psbt\x18\x02 \x01(\fR\bbasePsbt\x12\x1d\n" +
	"\n" +
	"no_publish\x18\x03 \x01(\bR\tnoPublish\"\x85\x01\n" +
	"\vFundingShim\x12>\n" +
	"\x0fchan_point_shim\x18\x01 \x01(\v2\x14.lnrpc.ChanPointShimH\x00R\rchanPointShim\x12.\n" +
	"\tpsbt_shim\x18\x02 \x01(\v2\x0f.lnrpc.PsbtShimH\x00R\bpsbtShimB\x06\n" +
	"\x04shim\";\n" +
	"\x11FundingShimCancel\x12&\n" +
	"\x0fpending_chan_id\x18\x01 \x01(\fR\rpendingChanId\"\x81\x01\n" +
	"\x11FundingPsbtVerify\x12\x1f\n" +
	"\vfunded_psbt\x18\x01 \x01(\fR\n" +
	"fundedPsbt\x12&\n" +
	"\x0fpending_chan_id\x18\x02 \x01(\fR\rpendingChanId\x12#\n" +
	"\rskip_finalize\x18\x03 \x01(\bR\fskipFinalize\"\x80\x01\n" +
	"\x13FundingPsbtFinalize\x12\x1f\n" +
	"\vsigned_psbt\x18\x01 \x01(\fR\n" +
	"signedPsbt\x12&\n" +
	"\x0fpending_chan_id\x18\x02 \x01(\fR\rpendingChanId\x12 \n" +
	"\ffinal_raw_tx\x18\x03 \x01(\fR\n" +
	"finalRawTx\"\x99\x02\n" +
	"\x14FundingTransitionMsg\x129\n" +
	"\rshim_register\x18\x01 \x01(\v2\x12.lnrpc.FundingShimH\x00R\fshimRegister\x12;\n" +
	"\vshim_cancel\x18\x02 \x01(\v2\x18.lnrpc.FundingShimCancelH\x00R\n" +
	"shimCancel\x12;\n" +
	"\vpsbt_verify\x18\x03 \x01(\v2\x18.lnrpc.FundingPsbtVerifyH\x00R\n" +
	"psbtVerify\x12A\n" +
	"\rpsbt_finalize\x18\x04 \x01(\v2\x1a.lnrpc.FundingPsbtFinalizeH\x00R\fpsbtFinalizeB\t\n" +
	"\atrigger\"\x16\n" +
	"\x14FundingStateStepResp\"\xcc\x01\n" +
	"\vPendingHTLC\x12\x1a\n" +
	"\bincoming\x18\x01 \x01(\bR\bincoming\x12\x16\n" +
	"\x06amount\x18\x02 \x01(\x03R\x06amount\x12\x1a\n" +
	"\boutpoint\x18\x03 \x01(\tR\boutpoint\x12'\n" +
	"\x0fmaturity_height\x18\x04 \x01(\rR\x0ematurityHeight\x12.\n" +
	"\x13blocks_til_maturity\x18\x05 \x01(\x05R\x11blocksTilMaturity\x12\x14\n" +
	"\x05stage\x18\x06 \x01(\rR\x05stage\">\n" +
	"\x16PendingChannelsRequest\x12$\n" +
	"\x0einclude_raw_tx\x18\x01 \x01(\bR\fincludeRawTx\"\x80\x15\n" +
	"\x17PendingChannelsResponse\x12.\n" +
	"\x13total_limbo_balance\x18\x01 \x01(\x03R\x11totalLimboBalance\x12e\n" +
	"\x15pending_open_channels\x18\x02 \x03(\v21.lnrpc.PendingChannelsResponse.PendingOpenChannelR\x13pendingOpenChannels\x12j\n" +
	"\x18pending_closing_channels\x18\x03 \x03(\v2,.lnrpc.PendingChannelsResponse.ClosedChannelB\x02\x18\x01R\x16pendingClosingChannels\x12v\n" +
	"\x1epending_force_closing_channels\x18\x04 \x03(\v21.lnrpc.PendingChannelsResponse.ForceClosedChannelR\x1bpendingForceClosingChannels\x12h\n" +
	"\x16waiting_close_channels\x18\x05 \x03(\v22.lnrpc.PendingChannelsResponse.WaitingCloseChannelR\x14waitingCloseChannels\x1a\xe3\x04\n" +
	"\x0ePendingChannel\x12&\n" +
	"\x0fremote_node_pub\x18\x01 \x01(\tR\rremoteNodePub\x12#\n" +
	"\rchannel_point\x18\x02 \x01(\tR\fchannelPoint\x12\x1a\n" +
	"\bcapacity\x18\x03 \x01(\x03R\bcapacity\x12#\n" +
	"\rlocal_balance\x18\x04 \x01(\x03R\flocalBalance\x12%\n" +
	"\x0eremote_balance\x18\x05 \x01(\x03R\rremoteBalance\x123\n" +
	"\x16local_chan_reserve_sat\x18\x06 \x01(\x03R\x13localChanReserveSat\x125\n" +
	"\x17remote_chan_reserve_sat\x18\a \x01(\x03R\x14remoteChanReserveSat\x12.\n" +
	"\tinitiator\x18\b \x01(\x0e2\x10.lnrpc.InitiatorR\tinitiator\x12>\n" +
	"\x0fcommitment_type\x18\t \x01(\x0e2\x15.lnrpc.CommitmentTypeR\x0ecommitmentType\x126\n" +
	"\x17num_forwarding_packages\x18\n" +
	" \x01(\x03R\x15numForwardingPackages\x12*\n" +
	"\x11chan_status_flags\x18\v \x01(\tR\x0fchanStatusFlags\x12\x18\n" +
	"\aprivate\x18\f \x01(\bR\aprivate\x12\x12\n" +
	"\x04memo\x18\r \x01(\tR\x04memo\x12.\n" +
	"\x13custom_channel_data\x18\" \x01(\fR\x11customChannelData\x1a\xe8\x02\n" +
	"\x12PendingOpenChannel\x12G\n" +
	"\achannel\x18\x01 \x01(\v2-.lnrpc.PendingChannelsResponse.PendingChannelR\achannel\x12\x1d\n" +
	"\n" +
	"commit_fee\x18\x04 \x01(\x03R\tcommitFee\x12#\n" +
	"\rcommit_weight\x18\x05 \x01(\x03R\fcommitWeight\x12\x1c\n" +
	"\n" +
	"fee_per_kw\x18\x06 \x01(\x03R\bfeePerKw\x122\n" +
	"\x15funding_expiry_blocks\x18\x03 \x01(\x05R\x13fundingExpiryBlocks\x12<\n" +
	"\x1aconfirmations_until_active\x18\a \x01(\rR\x18confirmationsUntilActive\x12/\n" +
	"\x13confirmation_height\x18\b \x01(\rR\x12confirmationHeightJ\x04\b\x02\x10\x03\x1a\x9a\x02\n" +
	"\x13WaitingCloseChannel\x12G\n" +
	"\achannel\x18\x01 \x01(\v2-.lnrpc.PendingChannelsResponse.PendingChannelR\achannel\x12#\n" +
	"\rlimbo_balance\x18\x02 \x01(\x03R\flimboBalance\x12L\n" +
	"\vcommitments\x18\x03 \x01(\v2*.lnrpc.PendingChannelsResponse.CommitmentsR\vcommitments\x12!\n" +
	"\fclosing_txid\x18\x04 \x01(\tR\vclosingTxid\x12$\n" +
	"\x0eclosing_tx_hex\x18\x05 \x01(\tR\fclosingTxHex\x1a\xa3\x02\n" +
	"\vCommitments\x12\x1d\n" +
	"\n" +
	"local_txid\x18\x01 \x01(\tR\tlocalTxid\x12\x1f\n" +
	"\vremote_txid\x18\x02 \x01(\tR\n" +
	"remoteTxid\x12.\n" +
	"\x13remote_pending_txid\x18\x03 \x01(\tR\x11remotePendingTxid\x12/\n" +
	"\x14local_commit_fee_sat\x18\x04 \x01(\x04R\x11localCommitFeeSat\x121\n" +
	"\x15remote_commit_fee_sat\x18\x05 \x01(\x04R\x12remoteCommitFeeSat\x12@\n" +
	"\x1dremote_pending_commit_fee_sat\x18\x06 \x01(\x04R\x19remotePendingCommitFeeSat\x1a{\n" +
	"\rClosedChannel\x12G\n" +
	"\achannel\x18\x01 \x01(\v2-.lnrpc.PendingChannelsResponse.PendingChannelR\achannel\x12!\n" +
	"\fclosing_txid\x18\x02 \x01(\tR\vclosingTxid\x1a\xee\x03\n" +
	"\x12ForceClosedChannel\x12G\n" +
	"\achannel\x18\x01 \x01(\v2-.lnrpc.PendingChannelsResponse.PendingChannelR\achannel\x12!\n" +
	"\fclosing_txid\x18\x02 \x01(\tR\vclosingTxid\x12#\n" +
	"\rlimbo_balance\x18\x03 \x01(\x03R\flimboBalance\x12'\n" +
	"\x0fmaturity_height\x18\x04 \x01(\rR\x0ematurityHeight\x12.\n" +
	"\x13blocks_til_maturity\x18\x05 \x01(\x05R\x11blocksTilMaturity\x12+\n" +
	"\x11recovered_balance\x18\x06 \x01(\x03R\x10recoveredBalance\x127\n" +
	"\rpending_htlcs\x18\b \x03(\v2\x12.lnrpc.PendingHTLCR\fpendingHtlcs\x12U\n" +
	"\x06anchor\x18\t \x01(\x0e2=.lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorStateR\x06anchor\"1\n" +
	"\vAnchorState\x12\t\n" +
	"\x05LIMBO\x10\x00\x12\r\n" +
	"\tRECOVERED\x10\x01\x12\b\n" +
	"\x04LOST\x10\x02\"\x1a\n" +
	"\x18ChannelEventSubscription\"\xeb\x05\n" +
	"\x12ChannelEventUpdate\x123\n" +
	"\fopen_channel\x18\x01 \x01(\v2\x0e.lnrpc.ChannelH\x00R\vopenChannel\x12C\n" +
	"\x0eclosed_channel\x18\x02 \x01(\v2\x1a.lnrpc.ChannelCloseSummaryH\x00R\rclosedChannel\x12<\n" +
	"\x0eactive_channel\x18\x03 \x01(\v2\x13.lnrpc.ChannelPointH\x00R\ractiveChannel\x12@\n" +
	"\x10inactive_channel\x18\x04 \x01(\v2\x13.lnrpc.ChannelPointH\x00R\x0finactiveChannel\x12H\n" +
	"\x14pending_open_channel\x18\x06 \x01(\v2\x14.lnrpc.PendingUpdateH\x00R\x12pendingOpenChannel\x12K\n" +
	"\x16fully_resolved_channel\x18\a \x01(\v2\x13.lnrpc.ChannelPointH\x00R\x14fullyResolvedChannel\x12M\n" +
	"\x17channel_funding_timeout\x18\b \x01(\v2\x13.lnrpc.ChannelPointH\x00R\x15channelFundingTimeout\x128\n" +
	"\x04type\x18\x05 \x01(\x0e2$.lnrpc.ChannelEventUpdate.UpdateTypeR\x04type\"\xaf\x01\n" +
	"\n" +
	"UpdateType\x12\x10\n" +
	"\fOPEN_CHANNEL\x10\x00\x12\x12\n" +
	"\x0eCLOSED_CHANNEL\x10\x01\x12\x12\n" +
	"\x0eACTIVE_CHANNEL\x10\x02\x12\x14\n" +
	"\x10INACTIVE_CHANNEL\x10\x03\x12\x18\n" +
	"\x14PENDING_OPEN_CHANNEL\x10\x04\x12\x1a\n" +
	"\x16FULLY_RESOLVED_CHANNEL\x10\x05\x12\x1b\n" +
	"\x17CHANNEL_FUNDING_TIMEOUT\x10\x06B\t\n" +
	"\achannel\"t\n" +
	"\x14WalletAccountBalance\x12+\n" +
	"\x11confirmed_balance\x18\x01 \x01(\x03R\x10confirmedBalance\x12/\n" +
	"\x13unconfirmed_balance\x18\x02 \x01(\x03R\x12unconfirmedBalance\"M\n" +
	"\x14WalletBalanceRequest\x12\x18\n" +
	"\aaccount\x18\x01 \x01(\tR\aaccount\x12\x1b\n" +
	"\tmin_confs\x18\x02 \x01(\x05R\bminConfs\"\xbd\x03\n" +
	"\x15WalletBalanceResponse\x12#\n" +
	"\rtotal_balance\x18\x01 \x01(\x03R\ftotalBalance\x12+\n" +
	"\x11confirmed_balance\x18\x02 \x01(\x03R\x10confirmedBalance\x12/\n" +
	"\x13unconfirmed_balance\x18\x03 \x01(\x03R\x12unconfirmedBalance\x12%\n" +
	"\x0elocked_balance\x18\x05 \x01(\x03R\rlockedBalance\x12?\n" +
	"\x1creserved_balance_anchor_chan\x18\x06 \x01(\x03R\x19reservedBalanceAnchorChan\x12Y\n" +
	"\x0faccount_balance\x18\x04 \x03(\v20.lnrpc.WalletBalanceResponse.AccountBalanceEntryR\x0eaccountBalance\x1a^\n" +
	"\x13AccountBalanceEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x121\n" +
	"\x05value\x18\x02 \x01(\v2\x1b.lnrpc.WalletAccountBalanceR\x05value:\x028\x01\".\n" +
	"\x06Amount\x12\x10\n" +
	"\x03sat\x18\x01 \x01(\x04R\x03sat\x12\x12\n" +
	"\x04msat\x18\x02 \x01(\x04R\x04msat\"\x17\n" +
	"\x15ChannelBalanceRequest\"\xb0\x04\n" +
	"\x16ChannelBalanceResponse\x12\x1c\n" +
	"\abalance\x18\x01 \x01(\x03B\x02\x18\x01R\abalance\x124\n" +
	"\x14pending_open_balance\x18\x02 \x01(\x03B\x02\x18\x01R\x12pendingOpenBalance\x122\n" +
	"\rlocal_balance\x18\x03 \x01(\v2\r.lnrpc.AmountR\flocalBalance\x124\n" +
	"\x0eremote_balance\x18\x04 \x01(\v2\r.lnrpc.AmountR\rremoteBalance\x12E\n" +
	"\x17unsettled_local_balance\x18\x05 \x01(\v2\r.lnrpc.AmountR\x15unsettledLocalBalance\x12G\n" +
	"\x18unsettled_remote_balance\x18\x06 \x01(\v2\r.lnrpc.AmountR\x16unsettledRemoteBalance\x12J\n" +
	"\x1apending_open_local_balance\x18\a \x01(\v2\r.lnrpc.AmountR\x17pendingOpenLocalBalance\x12L\n" +
	"\x1bpending_open_remote_balance\x18\b \x01(\v2\r.lnrpc.AmountR\x18pendingOpenRemoteBalance\x12.\n" +
	"\x13custom_channel_data\x18\t \x01(\fR\x11customChannelData\"\xc8\a\n" +
	"\x12QueryRoutesRequest\x12\x17\n" +
	"\apub_key\x18\x01 \x01(\tR\x06pubKey\x12\x10\n" +
	"\x03amt\x18\x02 \x01(\x03R\x03amt\x12\x19\n" +
	"\bamt_msat\x18\f \x01(\x03R\aamtMsat\x12(\n" +
	"\x10final_cltv_delta\x18\x04 \x01(\x05R\x0efinalCltvDelta\x12,\n" +
	"\tfee_limit\x18\x05 \x01(\v2\x0f.lnrpc.FeeLimitR\bfeeLimit\x12#\n" +
	"\rignored_nodes\x18\x06 \x03(\fR\fignoredNodes\x12;\n" +
	"\rignored_edges\x18\a \x03(\v2\x12.lnrpc.EdgeLocatorB\x02\x18\x01R\fignoredEdges\x12$\n" +
	"\x0esource_pub_key\x18\b \x01(\tR\fsourcePubKey\x12.\n" +
	"\x13use_mission_control\x18\t \x01(\bR\x11useMissionControl\x124\n" +
	"\rignored_pairs\x18\n" +
	" \x03(\v2\x0f.lnrpc.NodePairR\fignoredPairs\x12\x1d\n" +
	"\n" +
	"cltv_limit\x18\v \x01(\rR\tcltvLimit\x12`\n" +
	"\x13dest_custom_records\x18\r \x03(\v20.lnrpc.QueryRoutesRequest.DestCustomRecordsEntryR\x11destCustomRecords\x12.\n" +
	"\x10outgoing_chan_id\x18\x0e \x01(\x04B\x04\x18\x010\x01R\x0eoutgoingChanId\x12&\n" +
	"\x0flast_hop_pubkey\x18\x0f \x01(\fR\rlastHopPubkey\x121\n" +
	"\vroute_hints\x18\x10 \x03(\v2\x10.lnrpc.RouteHintR\n" +
	"routeHints\x12M\n" +
	"\x15blinded_payment_paths\x18\x13 \x03(\v2\x19.lnrpc.BlindedPaymentPathR\x13blindedPaymentPaths\x126\n" +
	"\rdest_features\x18\x11 \x03(\x0e2\x11.lnrpc.FeatureBitR\fdestFeatures\x12\x1b\n" +
	"\ttime_pref\x18\x12 \x01(\x01R\btimePref\x12*\n" +
	"\x11outgoing_chan_ids\x18\x14 \x03(\x04R\x0foutgoingChanIds\x1aD\n" +
	"\x16DestCustomRecordsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x04R\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01J\x04\b\x03\x10\x04\".\n" +
	"\bNodePair\x12\x12\n" +
	"\x04from\x18\x01 \x01(\fR\x04from\x12\x0e\n" +
	"\x02to\x18\x02 \x01(\fR\x02to\"]\n" +
	"\vEdgeLocator\x12!\n" +
	"\n" +
	"channel_id\x18\x01 \x01(\x04B\x020\x01R\tchannelId\x12+\n" +
	"\x11direction_reverse\x18\x02 \x01(\bR\x10directionReverse\"^\n" +
	"\x13QueryRoutesResponse\x12$\n" +
	"\x06routes\x18\x01 \x03(\v2\f.lnrpc.RouteR\x06routes\x12!\n" +
	"\fsuccess_prob\x18\x02 \x01(\x01R\vsuccessProb\"\xa5\x05\n" +
	"\x03Hop\x12\x1b\n" +
	"\achan_id\x18\x01 \x01(\x04B\x020\x01R\x06chanId\x12'\n" +
	"\rchan_capacity\x18\x02 \x01(\x03B\x02\x18\x01R\fchanCapacity\x12(\n" +
	"\x0eamt_to_forward\x18\x03 \x01(\x03B\x02\x18\x01R\famtToForward\x12\x14\n" +
	"\x03fee\x18\x04 \x01(\x03B\x02\x18\x01R\x03fee\x12\x16\n" +
	"\x06expiry\x18\x05 \x01(\rR\x06expiry\x12-\n" +
	"\x13amt_to_forward_msat\x18\x06 \x01(\x03R\x10amtToForwardMsat\x12\x19\n" +
	"\bfee_msat\x18\a \x01(\x03R\afeeMsat\x12\x17\n" +
	"\apub_key\x18\b \x01(\tR\x06pubKey\x12#\n" +
	"\vtlv_payload\x18\t \x01(\bB\x02\x18\x01R\n" +
	"tlvPayload\x12/\n" +
	"\n" +
	"mpp_record\x18\n" +
	" \x01(\v2\x10.lnrpc.MPPRecordR\tmppRecord\x12/\n" +
	"\n" +
	"amp_record\x18\f \x01(\v2\x10.lnrpc.AMPRecordR\tampRecord\x12D\n" +
	"\x0ecustom_records\x18\v \x03(\v2\x1d.lnrpc.Hop.CustomRecordsEntryR\rcustomRecords\x12\x1a\n" +
	"\bmetadata\x18\r \x01(\fR\bmetadata\x12%\n" +
	"\x0eblinding_point\x18\x0e \x01(\fR\rblindingPoint\x12%\n" +
	"\x0eencrypted_data\x18\x0f \x01(\fR\rencryptedData\x12$\n" +
	"\x0etotal_amt_msat\x18\x10 \x01(\x04R\ftotalAmtMsat\x1a@\n" +
	"\x12CustomRecordsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x04R\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"T\n" +
	"\tMPPRecord\x12!\n" +
	"\fpayment_addr\x18\v \x01(\fR\vpaymentAddr\x12$\n" +
	"\x0etotal_amt_msat\x18\n" +
	" \x01(\x03R\ftotalAmtMsat\"b\n" +
	"\tAMPRecord\x12\x1d\n" +
	"\n" +
	"root_share\x18\x01 \x01(\fR\trootShare\x12\x15\n" +
	"\x06set_id\x18\x02 \x01(\fR\x05setId\x12\x1f\n" +
	"\vchild_index\x18\x03 \x01(\rR\n" +
	"childIndex\"\xc4\x02\n" +
	"\x05Route\x12&\n" +
	"\x0ftotal_time_lock\x18\x01 \x01(\rR\rtotalTimeLock\x12!\n" +
	"\n" +
	"total_fees\x18\x02 \x01(\x03B\x02\x18\x01R\ttotalFees\x12\x1f\n" +
	"\ttotal_amt\x18\x03 \x01(\x03B\x02\x18\x01R\btotalAmt\x12\x1e\n" +
	"\x04hops\x18\x04 \x03(\v2\n" +
	".lnrpc.HopR\x04hops\x12&\n" +
	"\x0ftotal_fees_msat\x18\x05 \x01(\x03R\rtotalFeesMsat\x12$\n" +
	"\x0etotal_amt_msat\x18\x06 \x01(\x03R\ftotalAmtMsat\x121\n" +
	"\x15first_hop_amount_msat\x18\a \x01(\x03R\x12firstHopAmountMsat\x12.\n" +
	"\x13custom_channel_data\x18\b \x01(\fR\x11customChannelData\"\x83\x01\n" +
	"\x0fNodeInfoRequest\x12\x17\n" +
	"\apub_key\x18\x01 \x01(\tR\x06pubKey\x12)\n" +
	"\x10include_channels\x18\x02 \x01(\bR\x0fincludeChannels\x12,\n" +
	"\x12include_auth_proof\x18\x03 \x01(\bR\x10includeAuthProof\"\xae\x01\n" +
	"\bNodeInfo\x12(\n" +
	"\x04node\x18\x01 \x01(\v2\x14.lnrpc.LightningNodeR\x04node\x12!\n" +
	"\fnum_channels\x18\x02 \x01(\rR\vnumChannels\x12%\n" +
	"\x0etotal_capacity\x18\x03 \x01(\x03R\rtotalCapacity\x12.\n" +
	"\bchannels\x18\x04 \x03(\v2\x12.lnrpc.ChannelEdgeR\bchannels\"\xc6\x03\n" +
	"\rLightningNode\x12\x1f\n" +
	"\vlast_update\x18\x01 \x01(\rR\n" +
	"lastUpdate\x12\x17\n" +
	"\apub_key\x18\x02 \x01(\tR\x06pubKey\x12\x14\n" +
	"\x05alias\x18\x03 \x01(\tR\x05alias\x120\n" +
	"\taddresses\x18\x04 \x03(\v2\x12.lnrpc.NodeAddressR\taddresses\x12\x14\n" +
	"\x05color\x18\x05 \x01(\tR\x05color\x12>\n" +
	"\bfeatures\x18\x06 \x03(\v2\".lnrpc.LightningNode.FeaturesEntryR\bfeatures\x12N\n" +
	"\x0ecustom_records\x18\a \x03(\v2'.lnrpc.LightningNode.CustomRecordsEntryR\rcustomRecords\x1aK\n" +
	"\rFeaturesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\rR\x03key\x12$\n" +
	"\x05value\x18\x02 \x01(\v2\x0e.lnrpc.FeatureR\x05value:\x028\x01\x1a@\n" +
	"\x12CustomRecordsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x04R\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\";\n" +
	"\vNodeAddress\x12\x18\n" +
	"\anetwork\x18\x01 \x01(\tR\anetwork\x12\x12\n" +
	"\x04addr\x18\x02 \x01(\tR\x04addr\"\x89\x04\n" +
	"\rRoutingPolicy\x12&\n" +
	"\x0ftime_lock_delta\x18\x01 \x01(\rR\rtimeLockDelta\x12\x19\n" +
	"\bmin_htlc\x18\x02 \x01(\x03R\aminHtlc\x12\"\n" +
	"\rfee_base_msat\x18\x03 \x01(\x03R\vfeeBaseMsat\x12-\n" +
	"\x13fee_rate_milli_msat\x18\x04 \x01(\x03R\x10feeRateMilliMsat\x12\x1a\n" +
	"\bdisabled\x18\x05 \x01(\bR\bdisabled\x12\"\n" +
	"\rmax_htlc_msat\x18\x06 \x01(\x04R\vmaxHtlcMsat\x12\x1f\n" +
	"\vlast_update\x18\a \x01(\rR\n" +
	"lastUpdate\x12N\n" +
	"\x0ecustom_records\x18\b \x03(\v2'.lnrpc.RoutingPolicy.CustomRecordsEntryR\rcustomRecords\x121\n" +
	"\x15inbound_fee_base_msat\x18\t \x01(\x05R\x12inboundFeeBaseMsat\x12<\n" +
	"\x1binbound_fee_rate_milli_msat\x18\n" +
	" \x01(\x05R\x17inboundFeeRateMilliMsat\x1a@\n" +
	"\x12CustomRecordsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x04R\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"\x92\x01\n" +
	"\x10ChannelAuthProof\x12\x1b\n" +
	"\tnode_sig1\x18\x01 \x01(\fR\bnodeSig1\x12!\n" +
	"\fbitcoin_sig1\x18\x02 \x01(\fR\vbitcoinSig1\x12\x1b\n" +
	"\tnode_sig2\x18\x03 \x01(\fR\bnodeSig2\x12!\n" +
	"\fbitcoin_sig2\x18\x04 \x01(\fR\vbitcoinSig2\"\x84\x04\n" +
	"\vChannelEdge\x12!\n" +
	"\n" +
	"channel_id\x18\x01 \x01(\x04B\x020\x01R\tchannelId\x12\x1d\n" +
	"\n" +
	"chan_point\x18\x02 \x01(\tR\tchanPoint\x12#\n" +
	"\vlast_update\x18\x03 \x01(\rB\x02\x18\x01R\n" +
	"lastUpdate\x12\x1b\n" +
	"\tnode1_pub\x18\x04 \x01(\tR\bnode1Pub\x12\x1b\n" +
	"\tnode2_pub\x18\x05 \x01(\tR\bnode2Pub\x12\x1a\n" +
	"\bcapacity\x18\x06 \x01(\x03R\bcapacity\x127\n" +
	"\fnode1_policy\x18\a \x01(\v2\x14.lnrpc.RoutingPolicyR\vnode1Policy\x127\n" +
	"\fnode2_policy\x18\b \x01(\v2\x14.lnrpc.RoutingPolicyR\vnode2Policy\x12L\n" +
	"\x0ecustom_records\x18\t \x03(\v2%.lnrpc.ChannelEdge.CustomRecordsEntryR\rcustomRecords\x126\n" +
	"\n" +
	"auth_proof\x18\n" +
	" \x01(\v2\x17.lnrpc.ChannelAuthProofR\tauthProof\x1a@\n" +
	"\x12CustomRecordsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x04R\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"t\n" +
	"\x13ChannelGraphRequest\x12/\n" +
	"\x13include_unannounced\x18\x01 \x01(\bR\x12includeUnannounced\x12,\n" +
	"\x12include_auth_proof\x18\x02 \x01(\bR\x10includeAuthProof\"d\n" +
	"\fChannelGraph\x12*\n" +
	"\x05nodes\x18\x01 \x03(\v2\x14.lnrpc.LightningNodeR\x05nodes\x12(\n" +
	"\x05edges\x18\x02 \x03(\v2\x12.lnrpc.ChannelEdgeR\x05edges\"A\n" +
	"\x12NodeMetricsRequest\x12+\n" +
	"\x05types\x18\x01 \x03(\x0e2\x15.lnrpc.NodeMetricTypeR\x05types\"\xe1\x01\n" +
	"\x13NodeMetricsResponse\x12l\n" +
	"\x16betweenness_centrality\x18\x01 \x03(\v25.lnrpc.NodeMetricsResponse.BetweennessCentralityEntryR\x15betweennessCentrality\x1a\\\n" +
	"\x1aBetweennessCentralityEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.lnrpc.FloatMetricR\x05value:\x028\x01\"N\n" +
	"\vFloatMetric\x12\x14\n" +
	"\x05value\x18\x01 \x01(\x01R\x05value\x12)\n" +
	"\x10normalized_value\x18\x02 \x01(\x01R\x0fnormalizedValue\"{\n" +
	"\x0fChanInfoRequest\x12\x1b\n" +
	"\achan_id\x18\x01 \x01(\x04B\x020\x01R\x06chanId\x12\x1d\n" +
	"\n" +
	"chan_point\x18\x02 \x01(\tR\tchanPoint\x12,\n" +
	"\x12include_auth_proof\x18\x03 \x01(\bR\x10includeAuthProof\"\x14\n" +
	"\x12NetworkInfoRequest\"\xd5\x03\n" +
	"\vNetworkInfo\x12%\n" +
	"\x0egraph_diameter\x18\x01 \x01(\rR\rgraphDiameter\x12$\n" +
	"\x0eavg_out_degree\x18\x02 \x01(\x01R\favgOutDegree\x12$\n" +
	"\x0emax_out_degree\x18\x03 \x01(\rR\fmaxOutDegree\x12\x1b\n" +
	"\tnum_nodes\x18\x04 \x01(\rR\bnumNodes\x12!\n" +
	"\fnum_channels\x18\x05 \x01(\rR\vnumChannels\x124\n" +
	"\x16total_network_capacity\x18\x06 \x01(\x03R\x14totalNetworkCapacity\x12(\n" +
	"\x10avg_channel_size\x18\a \x01(\x01R\x0eavgChannelSize\x12(\n" +
	"\x10min_channel_size\x18\b \x01(\x03R\x0eminChannelSize\x12(\n" +
	"\x10max_channel_size\x18\t \x01(\x03R\x0emaxChannelSize\x125\n" +
	"\x17median_channel_size_sat\x18\n" +
	" \x01(\x03R\x14medianChannelSizeSat\x12(\n" +
	"\x10num_zombie_chans\x18\v \x01(\x04R\x0enumZombieChans\"\r\n" +
	"\vStopRequest\"&\n" +
	"\fStopResponse\x12\x16\n" +
	"\x06status\x18\x01 \x01(\tR\x06status\"\x1b\n" +
	"\x19GraphTopologySubscription\"\xcd\x01\n" +
	"\x13GraphTopologyUpdate\x124\n" +
	"\fnode_updates\x18\x01 \x03(\v2\x11.lnrpc.NodeUpdateR\vnodeUpdates\x12A\n" +
	"\x0fchannel_updates\x18\x02 \x03(\v2\x18.lnrpc.ChannelEdgeUpdateR\x0echannelUpdates\x12=\n" +
	"\fclosed_chans\x18\x03 \x03(\v2\x1a.lnrpc.ClosedChannelUpdateR\vclosedChans\"\xef\x02\n" +
	"\n" +
	"NodeUpdate\x12 \n" +
	"\taddresses\x18\x01 \x03(\tB\x02\x18\x01R\taddresses\x12!\n" +
	"\fidentity_key\x18\x02 \x01(\tR\videntityKey\x12+\n" +
	"\x0fglobal_features\x18\x03 \x01(\fB\x02\x18\x01R\x0eglobalFeatures\x12\x14\n" +
	"\x05alias\x18\x04 \x01(\tR\x05alias\x12\x14\n" +
	"\x05color\x18\x05 \x01(\tR\x05color\x129\n" +
	"\x0enode_addresses\x18\a \x03(\v2\x12.lnrpc.NodeAddressR\rnodeAddresses\x12;\n" +
	"\bfeatures\x18\x06 \x03(\v2\x1f.lnrpc.NodeUpdate.FeaturesEntryR\bfeatures\x1aK\n" +
	"\rFeaturesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\rR\x03key\x12$\n" +
	"\x05value\x18\x02 \x01(\v2\x0e.lnrpc.FeatureR\x05value:\x028\x01\"\x91\x02\n" +
	"\x11ChannelEdgeUpdate\x12\x1b\n" +
	"\achan_id\x18\x01 \x01(\x04B\x020\x01R\x06chanId\x122\n" +
	"\n" +
	"chan_point\x18\x02 \x01(\v2\x13.lnrpc.ChannelPointR\tchanPoint\x12\x1a\n" +
	"\bcapacity\x18\x03 \x01(\x03R\bcapacity\x12;\n" +
	"\x0erouting_policy\x18\x04 \x01(\v2\x14.lnrpc.RoutingPolicyR\rroutingPolicy\x12)\n" +
	"\x10advertising_node\x18\x05 \x01(\tR\x0fadvertisingNode\x12'\n" +
	"\x0fconnecting_node\x18\x06 \x01(\tR\x0econnectingNode\"\xa7\x01\n" +
	"\x13ClosedChannelUpdate\x12\x1b\n" +
	"\achan_id\x18\x01 \x01(\x04B\x020\x01R\x06chanId\x12\x1a\n" +
	"\bcapacity\x18\x02 \x01(\x03R\bcapacity\x12#\n" +
	"\rclosed_height\x18\x03 \x01(\rR\fclosedHeight\x122\n" +
	"\n" +
	"chan_point\x18\x04 \x01(\v2\x13.lnrpc.ChannelPointR\tchanPoint\"\xcf\x01\n" +
	"\aHopHint\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x1b\n" +
	"\achan_id\x18\x02 \x01(\x04B\x020\x01R\x06chanId\x12\"\n" +
	"\rfee_base_msat\x18\x03 \x01(\rR\vfeeBaseMsat\x12>\n" +
	"\x1bfee_proportional_millionths\x18\x04 \x01(\rR\x19feeProportionalMillionths\x12*\n" +
	"\x11cltv_expiry_delta\x18\x05 \x01(\rR\x0fcltvExpiryDelta\"\x1e\n" +
	"\x05SetID\x12\x15\n" +
	"\x06set_id\x18\x01 \x01(\fR\x05setId\"8\n" +
	"\tRouteHint\x12+\n" +
	"\thop_hints\x18\x01 \x03(\v2\x0e.lnrpc.HopHintR\bhopHints\"\xc4\x02\n" +
	"\x12BlindedPaymentPath\x125\n" +
	"\fblinded_path\x18\x01 \x01(\v2\x12.lnrpc.BlindedPathR\vblindedPath\x12\"\n" +
	"\rbase_fee_msat\x18\x02 \x01(\x04R\vbaseFeeMsat\x122\n" +
	"\x15proportional_fee_rate\x18\x03 \x01(\rR\x13proportionalFeeRate\x12(\n" +
	"\x10total_cltv_delta\x18\x04 \x01(\rR\x0etotalCltvDelta\x12\"\n" +
	"\rhtlc_min_msat\x18\x05 \x01(\x04R\vhtlcMinMsat\x12\"\n" +
	"\rhtlc_max_msat\x18\x06 \x01(\x04R\vhtlcMaxMsat\x12-\n" +
	"\bfeatures\x18\a \x03(\x0e2\x11.lnrpc.FeatureBitR\bfeatures\"\x97\x01\n" +
	"\vBlindedPath\x12+\n" +
	"\x11introduction_node\x18\x01 \x01(\fR\x10introductionNode\x12%\n" +
	"\x0eblinding_point\x18\x02 \x01(\fR\rblindingPoint\x124\n" +
	"\fblinded_hops\x18\x03 \x03(\v2\x11.lnrpc.BlindedHopR\vblindedHops\"V\n" +
	"\n" +
	"BlindedHop\x12!\n" +
	"\fblinded_node\x18\x01 \x01(\fR\vblindedNode\x12%\n" +
	"\x0eencrypted_data\x18\x02 \x01(\fR\rencryptedData\"\xa8\x01\n" +
	"\x0fAMPInvoiceState\x12-\n" +
	"\x05state\x18\x01 \x01(\x0e2\x17.lnrpc.InvoiceHTLCStateR\x05state\x12!\n" +
	"\fsettle_index\x18\x02 \x01(\x04R\vsettleIndex\x12\x1f\n" +
	"\vsettle_time\x18\x03 \x01(\x03R\n" +
	"settleTime\x12\"\n" +
	"\ramt_paid_msat\x18\x05 \x01(\x03R\vamtPaidMsat\"\xac\n" +
	"\n" +
	"\aInvoice\x12\x12\n" +
	"\x04memo\x18\x01 \x01(\tR\x04memo\x12\x1d\n" +
	"\n" +
	"r_preimage\x18\x03 \x01(\fR\trPreimage\x12\x15\n" +
	"\x06r_hash\x18\x04 \x01(\fR\x05rHash\x12\x14\n" +
	"\x05value\x18\x05 \x01(\x03R\x05value\x12\x1d\n" +
	"\n" +
	"value_msat\x18\x17 \x01(\x03R\tvalueMsat\x12\x1c\n" +
	"\asettled\x18\x06 \x01(\bB\x02\x18\x01R\asettled\x12#\n" +
	"\rcreation_date\x18\a \x01(\x03R\fcreationDate\x12\x1f\n" +
	"\vsettle_date\x18\b \x01(\x03R\n" +
	"settleDate\x12'\n" +
	"\x0fpayment_request\x18\t \x01(\tR\x0epaymentRequest\x12)\n" +
	"\x10description_hash\x18\n" +
	" \x01(\fR\x0fdescriptionHash\x12\x16\n" +
	"\x06expiry\x18\v \x01(\x03R\x06expiry\x12#\n" +
	"\rfallback_addr\x18\f \x01(\tR\ffallbackAddr\x12\x1f\n" +
	"\vcltv_expiry\x18\r \x01(\x04R\n" +
	"cltvExpiry\x121\n" +
	"\vroute_hints\x18\x0e \x03(\v2\x10.lnrpc.RouteHintR\n" +
	"routeHints\x12\x18\n" +
	"\aprivate\x18\x0f \x01(\bR\aprivate\x12\x1b\n" +
	"\tadd_index\x18\x10 \x01(\x04R\baddIndex\x12!\n" +
	"\fsettle_index\x18\x11 \x01(\x04R\vsettleIndex\x12\x1d\n" +
	"\bamt_paid\x18\x12 \x01(\x03B\x02\x18\x01R\aamtPaid\x12 \n" +
	"\famt_paid_sat\x18\x13 \x01(\x03R\n" +
	"amtPaidSat\x12\"\n" +
	"\ramt_paid_msat\x18\x14 \x01(\x03R\vamtPaidMsat\x121\n" +
	"\x05state\x18\x15 \x01(\x0e2\x1b.lnrpc.Invoice.InvoiceStateR\x05state\x12(\n" +
	"\x05htlcs\x18\x16 \x03(\v2\x12.lnrpc.InvoiceHTLCR\x05htlcs\x128\n" +
	"\bfeatures\x18\x18 \x03(\v2\x1c.lnrpc.Invoice.FeaturesEntryR\bfeatures\x12\x1d\n" +
	"\n" +
	"is_keysend\x18\x19 \x01(\bR\tisKeysend\x12!\n" +
	"\fpayment_addr\x18\x1a \x01(\fR\vpaymentAddr\x12\x15\n" +
	"\x06is_amp\x18\x1b \x01(\bR\x05isAmp\x12O\n" +
	"\x11amp_invoice_state\x18\x1c \x03(\v2#.lnrpc.Invoice.AmpInvoiceStateEntryR\x0fampInvoiceState\x12\x1d\n" +
	"\n" +
	"is_blinded\x18\x1d \x01(\bR\tisBlinded\x12H\n" +
	"\x13blinded_path_config\x18\x1e \x01(\v2\x18.lnrpc.BlindedPathConfigR\x11blindedPathConfig\x1aK\n" +
	"\rFeaturesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\rR\x03key\x12$\n" +
	"\x05value\x18\x02 \x01(\v2\x0e.lnrpc.FeatureR\x05value:\x028\x01\x1aZ\n" +
	"\x14AmpInvoiceStateEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12,\n" +
	"\x05value\x18\x02 \x01(\v2\x16.lnrpc.AMPInvoiceStateR\x05value:\x028\x01\"A\n" +
	"\fInvoiceState\x12\b\n" +
	"\x04OPEN\x10\x00\x12\v\n" +
	"\aSETTLED\x10\x01\x12\f\n" +
	"\bCANCELED\x10\x02\x12\f\n" +
	"\bACCEPTED\x10\x03J\x04\b\x02\x10\x03\"\xa3\x02\n" +
	"\x11BlindedPathConfig\x12.\n" +
	"\x11min_num_real_hops\x18\x01 \x01(\rH\x00R\x0eminNumRealHops\x88\x01\x01\x12\x1e\n" +
	"\bnum_hops\x18\x02 \x01(\rH\x01R\anumHops\x88\x01\x01\x12'\n" +
	"\rmax_num_paths\x18\x03 \x01(\rH\x02R\vmaxNumPaths\x88\x01\x01\x12,\n" +
	"\x12node_omission_list\x18\x04 \x03(\fR\x10nodeOmissionList\x122\n" +
	"\x15incoming_channel_list\x18\x05 \x03(\x04R\x13incomingChannelListB\x14\n" +
	"\x12_min_num_real_hopsB\v\n" +
	"\t_num_hopsB\x10\n" +
	"\x0e_max_num_paths\"\xac\x04\n" +
	"\vInvoiceHTLC\x12\x1b\n" +
	"\achan_id\x18\x01 \x01(\x04B\x020\x01R\x06chanId\x12\x1d\n" +
	"\n" +
	"htlc_index\x18\x02 \x01(\x04R\thtlcIndex\x12\x19\n" +
	"\bamt_msat\x18\x03 \x01(\x04R\aamtMsat\x12#\n" +
	"\raccept_height\x18\x04 \x01(\x05R\facceptHeight\x12\x1f\n" +
	"\vaccept_time\x18\x05 \x01(\x03R\n" +
	"acceptTime\x12!\n" +
	"\fresolve_time\x18\x06 \x01(\x03R\vresolveTime\x12#\n" +
	"\rexpiry_height\x18\a \x01(\x05R\fexpiryHeight\x12-\n" +
	"\x05state\x18\b \x01(\x0e2\x17.lnrpc.InvoiceHTLCStateR\x05state\x12L\n" +
	"\x0ecustom_records\x18\t \x03(\v2%.lnrpc.InvoiceHTLC.CustomRecordsEntryR\rcustomRecords\x12+\n" +
	"\x12mpp_total_amt_msat\x18\n" +
	" \x01(\x04R\x0fmppTotalAmtMsat\x12\x1c\n" +
	"\x03amp\x18\v \x01(\v2\n" +
	".lnrpc.AMPR\x03amp\x12.\n" +
	"\x13custom_channel_data\x18\f \x01(\fR\x11customChannelData\x1a@\n" +
	"\x12CustomRecordsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x04R\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"\x8c\x01\n" +
	"\x03AMP\x12\x1d\n" +
	"\n" +
	"root_share\x18\x01 \x01(\fR\trootShare\x12\x15\n" +
	"\x06set_id\x18\x02 \x01(\fR\x05setId\x12\x1f\n" +
	"\vchild_index\x18\x03 \x01(\rR\n" +
	"childIndex\x12\x12\n" +
	"\x04hash\x18\x04 \x01(\fR\x04hash\x12\x1a\n" +
	"\bpreimage\x18\x05 \x01(\fR\bpreimage\"\x94\x01\n" +
	"\x12AddInvoiceResponse\x12\x15\n" +
	"\x06r_hash\x18\x01 \x01(\fR\x05rHash\x12'\n" +
	"\x0fpayment_request\x18\x02 \x01(\tR\x0epaymentRequest\x12\x1b\n" +
	"\tadd_index\x18\x10 \x01(\x04R\baddIndex\x12!\n" +
	"\fpayment_addr\x18\x11 \x01(\fR\vpaymentAddr\"F\n" +
	"\vPaymentHash\x12 \n" +
	"\n" +
	"r_hash_str\x18\x01 \x01(\tB\x02\x18\x01R\brHashStr\x12\x15\n" +
	"\x06r_hash\x18\x02 \x01(\fR\x05rHash\"\xfc\x01\n" +
	"\x12ListInvoiceRequest\x12!\n" +
	"\fpending_only\x18\x01 \x01(\bR\vpendingOnly\x12!\n" +
	"\findex_offset\x18\x04 \x01(\x04R\vindexOffset\x12(\n" +
	"\x10num_max_invoices\x18\x05 \x01(\x04R\x0enumMaxInvoices\x12\x1a\n" +
	"\breversed\x18\x06 \x01(\bR\breversed\x12.\n" +
	"\x13creation_date_start\x18\a \x01(\x04R\x11creationDateStart\x12*\n" +
	"\x11creation_date_end\x18\b \x01(\x04R\x0fcreationDateEnd\"\x9b\x01\n" +
	"\x13ListInvoiceResponse\x12*\n" +
	"\binvoices\x18\x01 \x03(\v2\x0e.lnrpc.InvoiceR\binvoices\x12*\n" +
	"\x11last_index_offset\x18\x02 \x01(\x04R\x0flastIndexOffset\x12,\n" +
	"\x12first_index_offset\x18\x03 \x01(\x04R\x10firstIndexOffset\"U\n" +
	"\x13InvoiceSubscription\x12\x1b\n" +
	"\tadd_index\x18\x01 \x01(\x04R\baddIndex\x12!\n" +
	"\fsettle_index\x18\x02 \x01(\x04R\vsettleIndex\":\n" +
	"\x15DelCanceledInvoiceReq\x12!\n" +
	"\finvoice_hash\x18\x01 \x01(\tR\vinvoiceHash\"0\n" +
	"\x16DelCanceledInvoiceResp\x12\x16\n" +
	"\x06status\x18\x01 \x01(\tR\x06status\"\xcb\x06\n" +
	"\aPayment\x12!\n" +
	"\fpayment_hash\x18\x01 \x01(\tR\vpaymentHash\x12\x18\n" +
	"\x05value\x18\x02 \x01(\x03B\x02\x18\x01R\x05value\x12'\n" +
	"\rcreation_date\x18\x03 \x01(\x03B\x02\x18\x01R\fcreationDate\x12\x14\n" +
	"\x03fee\x18\x05 \x01(\x03B\x02\x18\x01R\x03fee\x12)\n" +
	"\x10payment_preimage\x18\x06 \x01(\tR\x0fpaymentPreimage\x12\x1b\n" +
	"\tvalue_sat\x18\a \x01(\x03R\bvalueSat\x12\x1d\n" +
	"\n" +
	"value_msat\x18\b \x01(\x03R\tvalueMsat\x12'\n" +
	"\x0fpayment_request\x18\t \x01(\tR\x0epaymentRequest\x124\n" +
	"\x06status\x18\n" +
	" \x01(\x0e2\x1c.lnrpc.Payment.PaymentStatusR\x06status\x12\x17\n" +
	"\afee_sat\x18\v \x01(\x03R\x06feeSat\x12\x19\n" +
	"\bfee_msat\x18\f \x01(\x03R\afeeMsat\x12(\n" +
	"\x10creation_time_ns\x18\r \x01(\x03R\x0ecreationTimeNs\x12(\n" +
	"\x05htlcs\x18\x0e \x03(\v2\x12.lnrpc.HTLCAttemptR\x05htlcs\x12#\n" +
	"\rpayment_index\x18\x0f \x01(\x04R\fpaymentIndex\x12B\n" +
	"\x0efailure_reason\x18\x10 \x01(\x0e2\x1b.lnrpc.PaymentFailureReasonR\rfailureReason\x12b\n" +
	"\x18first_hop_custom_records\x18\x11 \x03(\v2).lnrpc.Payment.FirstHopCustomRecordsEntryR\x15firstHopCustomRecords\x1aH\n" +
	"\x1aFirstHopCustomRecordsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x04R\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"Y\n" +
	"\rPaymentStatus\x12\x0f\n" +
	"\aUNKNOWN\x10\x00\x1a\x02\b\x01\x12\r\n" +
	"\tIN_FLIGHT\x10\x01\x12\r\n" +
	"\tSUCCEEDED\x10\x02\x12\n" +
	"\n" +
	"\x06FAILED\x10\x03\x12\r\n" +
	"\tINITIATED\x10\x04J\x04\b\x04\x10\x05\"\xd5\x02\n" +
	"\vHTLCAttempt\x12\x1d\n" +
	"\n" +
	"attempt_id\x18\a \x01(\x04R\tattemptId\x125\n" +
	"\x06status\x18\x01 \x01(\x0e2\x1d.lnrpc.HTLCAttempt.HTLCStatusR\x06status\x12\"\n" +
	"\x05route\x18\x02 \x01(\v2\f.lnrpc.RouteR\x05route\x12&\n" +
	"\x0fattempt_time_ns\x18\x03 \x01(\x03R\rattemptTimeNs\x12&\n" +
	"\x0fresolve_time_ns\x18\x04 \x01(\x03R\rresolveTimeNs\x12(\n" +
	"\afailure\x18\x05 \x01(\v2\x0e.lnrpc.FailureR\afailure\x12\x1a\n" +
	"\bpreimage\x18\x06 \x01(\fR\bpreimage\"6\n" +
	"\n" +
	"HTLCStatus\x12\r\n" +
	"\tIN_FLIGHT\x10\x00\x12\r\n" +
	"\tSUCCEEDED\x10\x01\x12\n" +
	"\n" +
	"\x06FAILED\x10\x02\"\xb4\x02\n" +
	"\x13ListPaymentsRequest\x12-\n" +
	"\x12include_incomplete\x18\x01 \x01(\bR\x11includeIncomplete\x12!\n" +
	"\findex_offset\x18\x02 \x01(\x04R\vindexOffset\x12!\n" +
	"\fmax_payments\x18\x03 \x01(\x04R\vmaxPayments\x12\x1a\n" +
	"\breversed\x18\x04 \x01(\bR\breversed\x120\n" +
	"\x14count_total_payments\x18\x05 \x01(\bR\x12countTotalPayments\x12.\n" +
	"\x13creation_date_start\x18\x06 \x01(\x04R\x11creationDateStart\x12*\n" +
	"\x11creation_date_end\x18\a \x01(\x04R\x0fcreationDateEnd\"\xca\x01\n" +
	"\x14ListPaymentsResponse\x12*\n" +
	"\bpayments\x18\x01 \x03(\v2\x0e.lnrpc.PaymentR\bpayments\x12,\n" +
	"\x12first_index_offset\x18\x02 \x01(\x04R\x10firstIndexOffset\x12*\n" +
	"\x11last_index_offset\x18\x03 \x01(\x04R\x0flastIndexOffset\x12,\n" +
	"\x12total_num_payments\x18\x04 \x01(\x04R\x10totalNumPayments\"e\n" +
	"\x14DeletePaymentRequest\x12!\n" +
	"\fpayment_hash\x18\x01 \x01(\fR\vpaymentHash\x12*\n" +
	"\x11failed_htlcs_only\x18\x02 \x01(\bR\x0ffailedHtlcsOnly\"\x9b\x01\n" +
	"\x18DeleteAllPaymentsRequest\x120\n" +
	"\x14failed_payments_only\x18\x01 \x01(\bR\x12failedPaymentsOnly\x12*\n" +
	"\x11failed_htlcs_only\x18\x02 \x01(\bR\x0ffailedHtlcsOnly\x12!\n" +
	"\fall_payments\x18\x03 \x01(\bR\vallPayments\"/\n" +
	"\x15DeletePaymentResponse\x12\x16\n" +
	"\x06status\x18\x01 \x01(\tR\x06status\"3\n" +
	"\x19DeleteAllPaymentsResponse\x12\x16\n" +
	"\x06status\x18\x01 \x01(\tR\x06status\"\xbf\x01\n" +
	"\x15AbandonChannelRequest\x128\n" +
	"\rchannel_point\x18\x01 \x01(\v2\x13.lnrpc.ChannelPointR\fchannelPoint\x129\n" +
	"\x19pending_funding_shim_only\x18\x02 \x01(\bR\x16pendingFundingShimOnly\x121\n" +
	"\x16i_know_what_i_am_doing\x18\x03 \x01(\bR\x11iKnowWhatIAmDoing\"0\n" +
	"\x16AbandonChannelResponse\x12\x16\n" +
	"\x06status\x18\x01 \x01(\tR\x06status\"F\n" +
	"\x11DebugLevelRequest\x12\x12\n" +
	"\x04show\x18\x01 \x01(\bR\x04show\x12\x1d\n" +
	"\n" +
	"level_spec\x18\x02 \x01(\tR\tlevelSpec\"5\n" +
	"\x12DebugLevelResponse\x12\x1f\n" +
	"\vsub_systems\x18\x01 \x01(\tR\n" +
	"subSystems\"'\n" +
	"\fPayReqString\x12\x17\n" +
	"\apay_req\x18\x01 \x01(\tR\x06payReq\"\xf0\x04\n" +
	"\x06PayReq\x12 \n" +
	"\vdestination\x18\x01 \x01(\tR\vdestination\x12!\n" +
	"\fpayment_hash\x18\x02 \x01(\tR\vpaymentHash\x12!\n" +
	"\fnum_satoshis\x18\x03 \x01(\x03R\vnumSatoshis\x12\x1c\n" +
	"\ttimestamp\x18\x04 \x01(\x03R\ttimestamp\x12\x16\n" +
	"\x06expiry\x18\x05 \x01(\x03R\x06expiry\x12 \n" +
	"\vdescription\x18\x06 \x01(\tR\vdescription\x12)\n" +
	"\x10description_hash\x18\a \x01(\tR\x0fdescriptionHash\x12#\n" +
	"\rfallback_addr\x18\b \x01(\tR\ffallbackAddr\x12\x1f\n" +
	"\vcltv_expiry\x18\t \x01(\x03R\n" +
	"cltvExpiry\x121\n" +
	"\vroute_hints\x18\n" +
	" \x03(\v2\x10.lnrpc.RouteHintR\n" +
	"routeHints\x12!\n" +
	"\fpayment_addr\x18\v \x01(\fR\vpaymentAddr\x12\x19\n" +
	"\bnum_msat\x18\f \x01(\x03R\anumMsat\x127\n" +
	"\bfeatures\x18\r \x03(\v2\x1b.lnrpc.PayReq.FeaturesEntryR\bfeatures\x12>\n" +
	"\rblinded_paths\x18\x0e \x03(\v2\x19.lnrpc.BlindedPaymentPathR\fblindedPaths\x1aK\n" +
	"\rFeaturesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\rR\x03key\x12$\n" +
	"\x05value\x18\x02 \x01(\v2\x0e.lnrpc.FeatureR\x05value:\x028\x01\"Y\n" +
	"\aFeature\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x1f\n" +
	"\vis_required\x18\x03 \x01(\bR\n" +
	"isRequired\x12\x19\n" +
	"\bis_known\x18\x04 \x01(\bR\aisKnown\"\x12\n" +
	"\x10FeeReportRequest\"\x95\x02\n" +
	"\x10ChannelFeeReport\x12\x1b\n" +
	"\achan_id\x18\x05 \x01(\x04B\x020\x01R\x06chanId\x12#\n" +
	"\rchannel_point\x18\x01 \x01(\tR\fchannelPoint\x12\"\n" +
	"\rbase_fee_msat\x18\x02 \x01(\x03R\vbaseFeeMsat\x12\x1e\n" +
	"\vfee_per_mil\x18\x03 \x01(\x03R\tfeePerMil\x12\x19\n" +
	"\bfee_rate\x18\x04 \x01(\x01R\afeeRate\x121\n" +
	"\x15inbound_base_fee_msat\x18\x06 \x01(\x05R\x12inboundBaseFeeMsat\x12-\n" +
	"\x13inbound_fee_per_mil\x18\a \x01(\x05R\x10inboundFeePerMil\"\xb5\x01\n" +
	"\x11FeeReportResponse\x12:\n" +
	"\fchannel_fees\x18\x01 \x03(\v2\x17.lnrpc.ChannelFeeReportR\vchannelFees\x12\x1e\n" +
	"\vday_fee_sum\x18\x02 \x01(\x04R\tdayFeeSum\x12 \n" +
	"\fweek_fee_sum\x18\x03 \x01(\x04R\n" +
	"weekFeeSum\x12\"\n" +
	"\rmonth_fee_sum\x18\x04 \x01(\x04R\vmonthFeeSum\"R\n" +
	"\n" +
	"InboundFee\x12\"\n" +
	"\rbase_fee_msat\x18\x01 \x01(\x05R\vbaseFeeMsat\x12 \n" +
	"\ffee_rate_ppm\x18\x02 \x01(\x05R\n" +
	"feeRatePpm\"\xda\x03\n" +
	"\x13PolicyUpdateRequest\x12\x18\n" +
	"\x06global\x18\x01 \x01(\bH\x00R\x06global\x124\n" +
	"\n" +
	"chan_point\x18\x02 \x01(\v2\x13.lnrpc.ChannelPointH\x00R\tchanPoint\x12\"\n" +
	"\rbase_fee_msat\x18\x03 \x01(\x03R\vbaseFeeMsat\x12\x19\n" +
	"\bfee_rate\x18\x04 \x01(\x01R\afeeRate\x12 \n" +
	"\ffee_rate_ppm\x18\t \x01(\rR\n" +
	"feeRatePpm\x12&\n" +
	"\x0ftime_lock_delta\x18\x05 \x01(\rR\rtimeLockDelta\x12\"\n" +
	"\rmax_htlc_msat\x18\x06 \x01(\x04R\vmaxHtlcMsat\x12\"\n" +
	"\rmin_htlc_msat\x18\a \x01(\x04R\vminHtlcMsat\x125\n" +
	"\x17min_htlc_msat_specified\x18\b \x01(\bR\x14minHtlcMsatSpecified\x122\n" +
	"\vinbound_fee\x18\n" +
	" \x01(\v2\x11.lnrpc.InboundFeeR\n" +
	"inboundFee\x12.\n" +
	"\x13create_missing_edge\x18\v \x01(\bR\x11createMissingEdgeB\a\n" +
	"\x05scope\"\x8c\x01\n" +
	"\fFailedUpdate\x12+\n" +
	"\boutpoint\x18\x01 \x01(\v2\x0f.lnrpc.OutPointR\boutpoint\x12,\n" +
	"\x06reason\x18\x02 \x01(\x0e2\x14.lnrpc.UpdateFailureR\x06reason\x12!\n" +
	"\fupdate_error\x18\x03 \x01(\tR\vupdateError\"R\n" +
	"\x14PolicyUpdateResponse\x12:\n" +
	"\x0efailed_updates\x18\x01 \x03(\v2\x13.lnrpc.FailedUpdateR\rfailedUpdates\"\xa1\x02\n" +
	"\x18ForwardingHistoryRequest\x12\x1d\n" +
	"\n" +
	"start_time\x18\x01 \x01(\x04R\tstartTime\x12\x19\n" +
	"\bend_time\x18\x02 \x01(\x04R\aendTime\x12!\n" +
	"\findex_offset\x18\x03 \x01(\rR\vindexOffset\x12$\n" +
	"\x0enum_max_events\x18\x04 \x01(\rR\fnumMaxEvents\x12*\n" +
	"\x11peer_alias_lookup\x18\x05 \x01(\bR\x0fpeerAliasLookup\x12*\n" +
	"\x11incoming_chan_ids\x18\x06 \x03(\x04R\x0fincomingChanIds\x12*\n" +
	"\x11outgoing_chan_ids\x18\a \x03(\x04R\x0foutgoingChanIds\"\x8d\x04\n" +
	"\x0fForwardingEvent\x12 \n" +
	"\ttimestamp\x18\x01 \x01(\x04B\x02\x18\x01R\ttimestamp\x12 \n" +
	"\n" +
	"chan_id_in\x18\x02 \x01(\x04B\x020\x01R\bchanIdIn\x12\"\n" +
	"\vchan_id_out\x18\x04 \x01(\x04B\x020\x01R\tchanIdOut\x12\x15\n" +
	"\x06amt_in\x18\x05 \x01(\x04R\x05amtIn\x12\x17\n" +
	"\aamt_out\x18\x06 \x01(\x04R\x06amtOut\x12\x10\n" +
	"\x03fee\x18\a \x01(\x04R\x03fee\x12\x19\n" +
	"\bfee_msat\x18\b \x01(\x04R\afeeMsat\x12\x1e\n" +
	"\vamt_in_msat\x18\t \x01(\x04R\tamtInMsat\x12 \n" +
	"\famt_out_msat\x18\n" +
	" \x01(\x04R\n" +
	"amtOutMsat\x12!\n" +
	"\ftimestamp_ns\x18\v \x01(\x04R\vtimestampNs\x12\"\n" +
	"\rpeer_alias_in\x18\f \x01(\tR\vpeerAliasIn\x12$\n" +
	"\x0epeer_alias_out\x18\r \x01(\tR\fpeerAliasOut\x12-\n" +
	"\x10incoming_htlc_id\x18\x0e \x01(\x04H\x00R\x0eincomingHtlcId\x88\x01\x01\x12-\n" +
	"\x10outgoing_htlc_id\x18\x0f \x01(\x04H\x01R\x0eoutgoingHtlcId\x88\x01\x01B\x13\n" +
	"\x11_incoming_htlc_idB\x13\n" +
	"\x11_outgoing_htlc_id\"\x8c\x01\n" +
	"\x19ForwardingHistoryResponse\x12C\n" +
	"\x11forwarding_events\x18\x01 \x03(\v2\x16.lnrpc.ForwardingEventR\x10forwardingEvents\x12*\n" +
	"\x11last_offset_index\x18\x02 \x01(\rR\x0flastOffsetIndex\"P\n" +
	"\x1aExportChannelBackupRequest\x122\n" +
	"\n" +
	"chan_point\x18\x01 \x01(\v2\x13.lnrpc.ChannelPointR\tchanPoint\"d\n" +
	"\rChannelBackup\x122\n" +
	"\n" +
	"chan_point\x18\x01 \x01(\v2\x13.lnrpc.ChannelPointR\tchanPoint\x12\x1f\n" +
	"\vchan_backup\x18\x02 \x01(\fR\n" +
	"chanBackup\"s\n" +
	"\x0fMultiChanBackup\x124\n" +
	"\vchan_points\x18\x01 \x03(\v2\x13.lnrpc.ChannelPointR\n" +
	"chanPoints\x12*\n" +
	"\x11multi_chan_backup\x18\x02 \x01(\fR\x0fmultiChanBackup\"\x19\n" +
	"\x17ChanBackupExportRequest\"\x9f\x01\n" +
	"\x12ChanBackupSnapshot\x12E\n" +
	"\x13single_chan_backups\x18\x01 \x01(\v2\x15.lnrpc.ChannelBackupsR\x11singleChanBackups\x12B\n" +
	"\x11multi_chan_backup\x18\x02 \x01(\v2\x16.lnrpc.MultiChanBackupR\x0fmultiChanBackup\"I\n" +
	"\x0eChannelBackups\x127\n" +
	"\fchan_backups\x18\x01 \x03(\v2\x14.lnrpc.ChannelBackupR\vchanBackups\"\x8e\x01\n" +
	"\x18RestoreChanBackupRequest\x12:\n" +
	"\fchan_backups\x18\x01 \x01(\v2\x15.lnrpc.ChannelBackupsH\x00R\vchanBackups\x12,\n" +
	"\x11multi_chan_backup\x18\x02 \x01(\fH\x00R\x0fmultiChanBackupB\b\n" +
	"\x06backup\":\n" +
	"\x15RestoreBackupResponse\x12!\n" +
	"\fnum_restored\x18\x01 \x01(\rR\vnumRestored\"\x1b\n" +
	"\x19ChannelBackupSubscription\";\n" +
	"\x18VerifyChanBackupResponse\x12\x1f\n" +
	"\vchan_points\x18\x01 \x03(\tR\n" +
	"chanPoints\"D\n" +
	"\x12MacaroonPermission\x12\x16\n" +
	"\x06entity\x18\x01 \x01(\tR\x06entity\x12\x16\n" +
	"\x06action\x18\x02 \x01(\tR\x06action\"\xb0\x01\n" +
	"\x13BakeMacaroonRequest\x12;\n" +
	"\vpermissions\x18\x01 \x03(\v2\x19.lnrpc.MacaroonPermissionR\vpermissions\x12\x1e\n" +
	"\vroot_key_id\x18\x02 \x01(\x04R\trootKeyId\x12<\n" +
	"\x1aallow_external_permissions\x18\x03 \x01(\bR\x18allowExternalPermissions\"2\n" +
	"\x14BakeMacaroonResponse\x12\x1a\n" +
	"\bmacaroon\x18\x01 \x01(\tR\bmacaroon\"\x18\n" +
	"\x16ListMacaroonIDsRequest\";\n" +
	"\x17ListMacaroonIDsResponse\x12 \n" +
	"\froot_key_ids\x18\x01 \x03(\x04R\n" +
	"rootKeyIds\"9\n" +
	"\x17DeleteMacaroonIDRequest\x12\x1e\n" +
	"\vroot_key_id\x18\x01 \x01(\x04R\trootKeyId\"4\n" +
	"\x18DeleteMacaroonIDResponse\x12\x18\n" +
	"\adeleted\x18\x01 \x01(\bR\adeleted\"U\n" +
	"\x16MacaroonPermissionList\x12;\n" +
	"\vpermissions\x18\x01 \x03(\v2\x19.lnrpc.MacaroonPermissionR\vpermissions\"\x18\n" +
	"\x16ListPermissionsRequest\"\xe4\x01\n" +
	"\x17ListPermissionsResponse\x12d\n" +
	"\x12method_permissions\x18\x01 \x03(\v25.lnrpc.ListPermissionsResponse.MethodPermissionsEntryR\x11methodPermissions\x1ac\n" +
	"\x16MethodPermissionsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x123\n" +
	"\x05value\x18\x02 \x01(\v2\x1d.lnrpc.MacaroonPermissionListR\x05value:\x028\x01\"\xcc\b\n" +
	"\aFailure\x12.\n" +
	"\x04code\x18\x01 \x01(\x0e2\x1a.lnrpc.Failure.FailureCodeR\x04code\x12;\n" +
	"\x0echannel_update\x18\x03 \x01(\v2\x14.lnrpc.ChannelUpdateR\rchannelUpdate\x12\x1b\n" +
	"\thtlc_msat\x18\x04 \x01(\x04R\bhtlcMsat\x12\"\n" +
	"\ronion_sha_256\x18\x05 \x01(\fR\vonionSha256\x12\x1f\n" +
	"\vcltv_expiry\x18\x06 \x01(\rR\n" +
	"cltvExpiry\x12\x14\n" +
	"\x05flags\x18\a \x01(\rR\x05flags\x120\n" +
	"\x14failure_source_index\x18\b \x01(\rR\x12failureSourceIndex\x12\x16\n" +
	"\x06height\x18\t \x01(\rR\x06height\"\x8b\x06\n" +
	"\vFailureCode\x12\f\n" +
	"\bRESERVED\x10\x00\x12(\n" +
	"$INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS\x10\x01\x12\x1c\n" +
	"\x18INCORRECT_PAYMENT_AMOUNT\x10\x02\x12\x1f\n" +
	"\x1bFINAL_INCORRECT_CLTV_EXPIRY\x10\x03\x12\x1f\n" +
	"\x1bFINAL_INCORRECT_HTLC_AMOUNT\x10\x04\x12\x19\n" +
	"\x15FINAL_EXPIRY_TOO_SOON\x10\x05\x12\x11\n" +
	"\rINVALID_REALM\x10\x06\x12\x13\n" +
	"\x0fEXPIRY_TOO_SOON\x10\a\x12\x19\n" +
	"\x15INVALID_ONION_VERSION\x10\b\x12\x16\n" +
	"\x12INVALID_ONION_HMAC\x10\t\x12\x15\n" +
	"\x11INVALID_ONION_KEY\x10\n" +
	"\x12\x18\n" +
	"\x14AMOUNT_BELOW_MINIMUM\x10\v\x12\x14\n" +
	"\x10FEE_INSUFFICIENT\x10\f\x12\x19\n" +
	"\x15INCORRECT_CLTV_EXPIRY\x10\r\x12\x14\n" +
	"\x10CHANNEL_DISABLED\x10\x0e\x12\x1d\n" +
	"\x19TEMPORARY_CHANNEL_FAILURE\x10\x0f\x12!\n" +
	"\x1dREQUIRED_NODE_FEATURE_MISSING\x10\x10\x12$\n" +
	" REQUIRED_CHANNEL_FEATURE_MISSING\x10\x11\x12\x15\n" +
	"\x11UNKNOWN_NEXT_PEER\x10\x12\x12\x1a\n" +
	"\x16TEMPORARY_NODE_FAILURE\x10\x13\x12\x1a\n" +
	"\x16PERMANENT_NODE_FAILURE\x10\x14\x12\x1d\n" +
	"\x19PERMANENT_CHANNEL_FAILURE\x10\x15\x12\x12\n" +
	"\x0eEXPIRY_TOO_FAR\x10\x16\x12\x0f\n" +
	"\vMPP_TIMEOUT\x10\x17\x12\x19\n" +
	"\x15INVALID_ONION_PAYLOAD\x10\x18\x12\x1a\n" +
	"\x16INVALID_ONION_BLINDING\x10\x19\x12\x15\n" +
	"\x10INTERNAL_FAILURE\x10\xe5\a\x12\x14\n" +
	"\x0fUNKNOWN_FAILURE\x10\xe6\a\x12\x17\n" +
	"\x12UNREADABLE_FAILURE\x10\xe7\aJ\x04\b\x02\x10\x03\"\xb3\x03\n" +
	"\rChannelUpdate\x12\x1c\n" +
	"\tsignature\x18\x01 \x01(\fR\tsignature\x12\x1d\n" +
	"\n" +
	"chain_hash\x18\x02 \x01(\fR\tchainHash\x12\x1b\n" +
	"\achan_id\x18\x03 \x01(\x04B\x020\x01R\x06chanId\x12\x1c\n" +
	"\ttimestamp\x18\x04 \x01(\rR\ttimestamp\x12#\n" +
	"\rmessage_flags\x18\n" +
	" \x01(\rR\fmessageFlags\x12#\n" +
	"\rchannel_flags\x18\x05 \x01(\rR\fchannelFlags\x12&\n" +
	"\x0ftime_lock_delta\x18\x06 \x01(\rR\rtimeLockDelta\x12*\n" +
	"\x11htlc_minimum_msat\x18\a \x01(\x04R\x0fhtlcMinimumMsat\x12\x19\n" +
	"\bbase_fee\x18\b \x01(\rR\abaseFee\x12\x19\n" +
	"\bfee_rate\x18\t \x01(\rR\afeeRate\x12*\n" +
	"\x11htlc_maximum_msat\x18\v \x01(\x04R\x0fhtlcMaximumMsat\x12*\n" +
	"\x11extra_opaque_data\x18\f \x01(\fR\x0fextraOpaqueData\"]\n" +
	"\n" +
	"MacaroonId\x12\x14\n" +
	"\x05nonce\x18\x01 \x01(\fR\x05nonce\x12\x1c\n" +
	"\tstorageId\x18\x02 \x01(\fR\tstorageId\x12\x1b\n" +
	"\x03ops\x18\x03 \x03(\v2\t.lnrpc.OpR\x03ops\"6\n" +
	"\x02Op\x12\x16\n" +
	"\x06entity\x18\x01 \x01(\tR\x06entity\x12\x18\n" +
	"\aactions\x18\x02 \x03(\tR\aactions\"\xdd\x01\n" +
	"\x13CheckMacPermRequest\x12\x1a\n" +
	"\bmacaroon\x18\x01 \x01(\fR\bmacaroon\x12;\n" +
	"\vpermissions\x18\x02 \x03(\v2\x19.lnrpc.MacaroonPermissionR\vpermissions\x12\x1e\n" +
	"\n" +
	"fullMethod\x18\x03 \x01(\tR\n" +
	"fullMethod\x12M\n" +
	"$check_default_perms_from_full_method\x18\x04 \x01(\bR\x1fcheckDefaultPermsFromFullMethod\",\n" +
	"\x14CheckMacPermResponse\x12\x14\n" +
	"\x05valid\x18\x01 \x01(\bR\x05valid\"\xa4\x04\n" +
	"\x14RPCMiddlewareRequest\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\x04R\trequestId\x12!\n" +
	"\fraw_macaroon\x18\x02 \x01(\fR\vrawMacaroon\x126\n" +
	"\x17custom_caveat_condition\x18\x03 \x01(\tR\x15customCaveatCondition\x124\n" +
	"\vstream_auth\x18\x04 \x01(\v2\x11.lnrpc.StreamAuthH\x00R\n" +
	"streamAuth\x12-\n" +
	"\arequest\x18\x05 \x01(\v2\x11.lnrpc.RPCMessageH\x00R\arequest\x12/\n" +
	"\bresponse\x18\x06 \x01(\v2\x11.lnrpc.RPCMessageH\x00R\bresponse\x12#\n" +
	"\freg_complete\x18\b \x01(\bH\x00R\vregComplete\x12\x15\n" +
	"\x06msg_id\x18\a \x01(\x04R\x05msgId\x12U\n" +
	"\x0emetadata_pairs\x18\t \x03(\v2..lnrpc.RPCMiddlewareRequest.MetadataPairsEntryR\rmetadataPairs\x1aW\n" +
	"\x12MetadataPairsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12+\n" +
	"\x05value\x18\x02 \x01(\v2\x15.lnrpc.MetadataValuesR\x05value:\x028\x01B\x10\n" +
	"\x0eintercept_type\"(\n" +
	"\x0eMetadataValues\x12\x16\n" +
	"\x06values\x18\x01 \x03(\tR\x06values\"4\n" +
	"\n" +
	"StreamAuth\x12&\n" +
	"\x0fmethod_full_uri\x18\x01 \x01(\tR\rmethodFullUri\"\xab\x01\n" +
	"\n" +
	"RPCMessage\x12&\n" +
	"\x0fmethod_full_uri\x18\x01 \x01(\tR\rmethodFullUri\x12\x1d\n" +
	"\n" +
	"stream_rpc\x18\x02 \x01(\bR\tstreamRpc\x12\x1b\n" +
	"\ttype_name\x18\x03 \x01(\tR\btypeName\x12\x1e\n" +
	"\n" +
	"serialized\x18\x04 \x01(\fR\n" +
	"serialized\x12\x19\n" +
	"\bis_error\x18\x05 \x01(\bR\aisError\"\xc0\x01\n" +
	"\x15RPCMiddlewareResponse\x12\x1c\n" +
	"\n" +
	"ref_msg_id\x18\x01 \x01(\x04R\brefMsgId\x12;\n" +
	"\bregister\x18\x02 \x01(\v2\x1d.lnrpc.MiddlewareRegistrationH\x00R\bregister\x126\n" +
	"\bfeedback\x18\x03 \x01(\v2\x18.lnrpc.InterceptFeedbackH\x00R\bfeedbackB\x14\n" +
	"\x12middleware_message\"\xa6\x01\n" +
	"\x16MiddlewareRegistration\x12'\n" +
	"\x0fmiddleware_name\x18\x01 \x01(\tR\x0emiddlewareName\x12=\n" +
	"\x1bcustom_macaroon_caveat_name\x18\x02 \x01(\tR\x18customMacaroonCaveatName\x12$\n" +
	"\x0eread_only_mode\x18\x03 \x01(\bR\freadOnlyMode\"\x8b\x01\n" +
	"\x11InterceptFeedback\x12\x14\n" +
	"\x05error\x18\x01 \x01(\tR\x05error\x12)\n" +
	"\x10replace_response\x18\x02 \x01(\bR\x0freplaceResponse\x125\n" +
	"\x16replacement_serialized\x18\x03 \x01(\fR\x15replacementSerialized*\xcb\x02\n" +
	"\x10OutputScriptType\x12\x1b\n" +
	"\x17SCRIPT_TYPE_PUBKEY_HASH\x10\x00\x12\x1b\n" +
	"\x17SCRIPT_TYPE_SCRIPT_HASH\x10\x01\x12&\n" +
	"\"SCRIPT_TYPE_WITNESS_V0_PUBKEY_HASH\x10\x02\x12&\n" +
	"\"SCRIPT_TYPE_WITNESS_V0_SCRIPT_HASH\x10\x03\x12\x16\n" +
	"\x12SCRIPT_TYPE_PUBKEY\x10\x04\x12\x18\n" +
	"\x14SCRIPT_TYPE_MULTISIG\x10\x05\x12\x18\n" +
	"\x14SCRIPT_TYPE_NULLDATA\x10\x06\x12\x1c\n" +
	"\x18SCRIPT_TYPE_NON_STANDARD\x10\a\x12\x1f\n" +
	"\x1bSCRIPT_TYPE_WITNESS_UNKNOWN\x10\b\x12\"\n" +
	"\x1eSCRIPT_TYPE_WITNESS_V1_TAPROOT\x10\t*b\n" +
	"\x15CoinSelectionStrategy\x12\x1e\n" +
	"\x1aSTRATEGY_USE_GLOBAL_CONFIG\x10\x00\x12\x14\n" +
	"\x10STRATEGY_LARGEST\x10\x01\x12\x13\n" +
	"\x0fSTRATEGY_RANDOM\x10\x02*\xac\x01\n" +
	"\vAddressType\x12\x17\n" +
	"\x13WITNESS_PUBKEY_HASH\x10\x00\x12\x16\n" +
	"\x12NESTED_PUBKEY_HASH\x10\x01\x12\x1e\n" +
	"\x1aUNUSED_WITNESS_PUBKEY_HASH\x10\x02\x12\x1d\n" +
	"\x19UNUSED_NESTED_PUBKEY_HASH\x10\x03\x12\x12\n" +
	"\x0eTAPROOT_PUBKEY\x10\x04\x12\x19\n" +
	"\x15UNUSED_TAPROOT_PUBKEY\x10\x05*\xb6\x01\n" +
	"\x0eCommitmentType\x12\x1b\n" +
	"\x17UNKNOWN_COMMITMENT_TYPE\x10\x00\x12\n" +
	"\n" +
	"\x06LEGACY\x10\x01\x12\x15\n" +
	"\x11STATIC_REMOTE_KEY\x10\x02\x12\v\n" +
	"\aANCHORS\x10\x03\x12\x19\n" +
	"\x15SCRIPT_ENFORCED_LEASE\x10\x04\x12\x12\n" +
	"\x0eSIMPLE_TAPROOT\x10\x05\x12\x1a\n" +
	"\x16SIMPLE_TAPROOT_OVERLAY\x10\x06\x12\f\n" +
	"\bZERO_FEE\x10\a*a\n" +
	"\tInitiator\x12\x15\n" +
	"\x11INITIATOR_UNKNOWN\x10\x00\x12\x13\n" +
	"\x0fINITIATOR_LOCAL\x10\x01\x12\x14\n" +
	"\x10INITIATOR_REMOTE\x10\x02\x12\x12\n" +
	"\x0eINITIATOR_BOTH\x10\x03*`\n" +
	"\x0eResolutionType\x12\x10\n" +
	"\fTYPE_UNKNOWN\x10\x00\x12\n" +
	"\n" +
	"\x06ANCHOR\x10\x01\x12\x11\n" +
	"\rINCOMING_HTLC\x10\x02\x12\x11\n" +
	"\rOUTGOING_HTLC\x10\x03\x12\n" +
	"\n" +
	"\x06COMMIT\x10\x04*q\n" +
	"\x11ResolutionOutcome\x12\x13\n" +
	"\x0fOUTCOME_UNKNOWN\x10\x00\x12\v\n" +
	"\aCLAIMED\x10\x01\x12\r\n" +
	"\tUNCLAIMED\x10\x02\x12\r\n" +
	"\tABANDONED\x10\x03\x12\x0f\n" +
	"\vFIRST_STAGE\x10\x04\x12\v\n" +
	"\aTIMEOUT\x10\x05*9\n" +
	"\x0eNodeMetricType\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\x1a\n" +
	"\x16BETWEENNESS_CENTRALITY\x10\x01*;\n" +
	"\x10InvoiceHTLCState\x12\f\n" +
	"\bACCEPTED\x10\x00\x12\v\n" +
	"\aSETTLED\x10\x01\x12\f\n" +
	"\bCANCELED\x10\x02*\xf6\x01\n" +
	"\x14PaymentFailureReason\x12\x17\n" +
	"\x13FAILURE_REASON_NONE\x10\x00\x12\x1a\n" +
	"\x16FAILURE_REASON_TIMEOUT\x10\x01\x12\x1b\n" +
	"\x17FAILURE_REASON_NO_ROUTE\x10\x02\x12\x18\n" +
	"\x14FAILURE_REASON_ERROR\x10\x03\x12,\n" +
	"(FAILURE_REASON_INCORRECT_PAYMENT_DETAILS\x10\x04\x12'\n" +
	"#FAILURE_REASON_INSUFFICIENT_BALANCE\x10\x05\x12\x1b\n" +
	"\x17FAILURE_REASON_CANCELED\x10\x06*\x89\x05\n" +
	"\n" +
	"FeatureBit\x12\x18\n" +
	"\x14DATALOSS_PROTECT_REQ\x10\x00\x12\x18\n" +
	"\x14DATALOSS_PROTECT_OPT\x10\x01\x12\x17\n" +
	"\x13INITIAL_ROUING_SYNC\x10\x03\x12\x1f\n" +
	"\x1bUPFRONT_SHUTDOWN_SCRIPT_REQ\x10\x04\x12\x1f\n" +
	"\x1bUPFRONT_SHUTDOWN_SCRIPT_OPT\x10\x05\x12\x16\n" +
	"\x12GOSSIP_QUERIES_REQ\x10\x06\x12\x16\n" +
	"\x12GOSSIP_QUERIES_OPT\x10\a\x12\x11\n" +
	"\rTLV_ONION_REQ\x10\b\x12\x11\n" +
	"\rTLV_ONION_OPT\x10\t\x12\x1a\n" +
	"\x16EXT_GOSSIP_QUERIES_REQ\x10\n" +
	"\x12\x1a\n" +
	"\x16EXT_GOSSIP_QUERIES_OPT\x10\v\x12\x19\n" +
	"\x15STATIC_REMOTE_KEY_REQ\x10\f\x12\x19\n" +
	"\x15STATIC_REMOTE_KEY_OPT\x10\r\x12\x14\n" +
	"\x10PAYMENT_ADDR_REQ\x10\x0e\x12\x14\n" +
	"\x10PAYMENT_ADDR_OPT\x10\x0f\x12\v\n" +
	"\aMPP_REQ\x10\x10\x12\v\n" +
	"\aMPP_OPT\x10\x11\x12\x16\n" +
	"\x12WUMBO_CHANNELS_REQ\x10\x12\x12\x16\n" +
	"\x12WUMBO_CHANNELS_OPT\x10\x13\x12\x0f\n" +
	"\vANCHORS_REQ\x10\x14\x12\x0f\n" +
	"\vANCHORS_OPT\x10\x15\x12\x1d\n" +
	"\x19ANCHORS_ZERO_FEE_HTLC_REQ\x10\x16\x12\x1d\n" +
	"\x19ANCHORS_ZERO_FEE_HTLC_OPT\x10\x17\x12\x1b\n" +
	"\x17ROUTE_BLINDING_REQUIRED\x10\x18\x12\x1b\n" +
	"\x17ROUTE_BLINDING_OPTIONAL\x10\x19\x12\v\n" +
	"\aAMP_REQ\x10\x1e\x12\v\n" +
	"\aAMP_OPT\x10\x1f*\xac\x01\n" +
	"\rUpdateFailure\x12\x1a\n" +
	"\x16UPDATE_FAILURE_UNKNOWN\x10\x00\x12\x1a\n" +
	"\x16UPDATE_FAILURE_PENDING\x10\x01\x12\x1c\n" +
	"\x18UPDATE_FAILURE_NOT_FOUND\x10\x02\x12\x1f\n" +
	"\x1bUPDATE_FAILURE_INTERNAL_ERR\x10\x03\x12$\n" +
	" UPDATE_FAILURE_INVALID_PARAMETER\x10\x042\xc5)\n" +
	"\tLightning\x12J\n" +
	"\rWalletBalance\x12\x1b.lnrpc.WalletBalanceRequest\x1a\x1c.lnrpc.WalletBalanceResponse\x12M\n" +
	"\x0eChannelBalance\x12\x1c.lnrpc.ChannelBalanceRequest\x1a\x1d.lnrpc.ChannelBalanceResponse\x12K\n" +
	"\x0fGetTransactions\x12\x1d.lnrpc.GetTransactionsRequest\x1a\x19.lnrpc.TransactionDetails\x12D\n" +
	"\vEstimateFee\x12\x19.lnrpc.EstimateFeeRequest\x1a\x1a.lnrpc.EstimateFeeResponse\x12>\n" +
	"\tSendCoins\x12\x17.lnrpc.SendCoinsRequest\x1a\x18.lnrpc.SendCoinsResponse\x12D\n" +
	"\vListUnspent\x12\x19.lnrpc.ListUnspentRequest\x1a\x1a.lnrpc.ListUnspentResponse\x12L\n" +
	"\x15SubscribeTransactions\x12\x1d.lnrpc.GetTransactionsRequest\x1a\x12.lnrpc.Transaction0\x01\x12;\n" +
	"\bSendMany\x12\x16.lnrpc.SendManyRequest\x1a\x17.lnrpc.SendManyResponse\x12A\n" +
	"\n" +
	"NewAddress\x12\x18.lnrpc.NewAddressRequest\x1a\x19.lnrpc.NewAddressResponse\x12D\n" +
	"\vSignMessage\x12\x19.lnrpc.SignMessageRequest\x1a\x1a.lnrpc.SignMessageResponse\x12J\n" +
	"\rVerifyMessage\x12\x1b.lnrpc.VerifyMessageRequest\x1a\x1c.lnrpc.VerifyMessageResponse\x12D\n" +
	"\vConnectPeer\x12\x19.lnrpc.ConnectPeerRequest\x1a\x1a.lnrpc.ConnectPeerResponse\x12M\n" +
	"\x0eDisconnectPeer\x12\x1c.lnrpc.DisconnectPeerRequest\x1a\x1d.lnrpc.DisconnectPeerResponse\x12>\n" +
	"\tListPeers\x12\x17.lnrpc.ListPeersRequest\x1a\x18.lnrpc.ListPeersResponse\x12G\n" +
	"\x13SubscribePeerEvents\x12\x1c.lnrpc.PeerEventSubscription\x1a\x10.lnrpc.PeerEvent0\x01\x128\n" +
	"\aGetInfo\x12\x15.lnrpc.GetInfoRequest\x1a\x16.lnrpc.GetInfoResponse\x12G\n" +
	"\fGetDebugInfo\x12\x1a.lnrpc.GetDebugInfoRequest\x1a\x1b.lnrpc.GetDebugInfoResponse\x12P\n" +
	"\x0fGetRecoveryInfo\x12\x1d.lnrpc.GetRecoveryInfoRequest\x1a\x1e.lnrpc.GetRecoveryInfoResponse\x12P\n" +
	"\x0fPendingChannels\x12\x1d.lnrpc.PendingChannelsRequest\x1a\x1e.lnrpc.PendingChannelsResponse\x12G\n" +
	"\fListChannels\x12\x1a.lnrpc.ListChannelsRequest\x1a\x1b.lnrpc.ListChannelsResponse\x12V\n" +
	"\x16SubscribeChannelEvents\x12\x1f.lnrpc.ChannelEventSubscription\x1a\x19.lnrpc.ChannelEventUpdate0\x01\x12M\n" +
	"\x0eClosedChannels\x12\x1c.lnrpc.ClosedChannelsRequest\x1a\x1d.lnrpc.ClosedChannelsResponse\x12A\n" +
	"\x0fOpenChannelSync\x12\x19.lnrpc.OpenChannelRequest\x1a\x13.lnrpc.ChannelPoint\x12C\n" +
	"\vOpenChannel\x12\x19.lnrpc.OpenChannelRequest\x1a\x17.lnrpc.OpenStatusUpdate0\x01\x12S\n" +
	"\x10BatchOpenChannel\x12\x1e.lnrpc.BatchOpenChannelRequest\x1a\x1f.lnrpc.BatchOpenChannelResponse\x12L\n" +
	"\x10FundingStateStep\x12\x1b.lnrpc.FundingTransitionMsg\x1a\x1b.lnrpc.FundingStateStepResp\x12P\n" +
	"\x0fChannelAcceptor\x12\x1c.lnrpc.ChannelAcceptResponse\x1a\x1b.lnrpc.ChannelAcceptRequest(\x010\x01\x12F\n" +
	"\fCloseChannel\x12\x1a.lnrpc.CloseChannelRequest\x1a\x18.lnrpc.CloseStatusUpdate0\x01\x12M\n" +
	"\x0eAbandonChannel\x12\x1c.lnrpc.AbandonChannelRequest\x1a\x1d.lnrpc.AbandonChannelResponse\x12?\n" +
	"\vSendPayment\x12\x12.lnrpc.SendRequest\x1a\x13.lnrpc.SendResponse\"\x03\x88\x02\x01(\x010\x01\x12?\n" +
	"\x0fSendPaymentSync\x12\x12.lnrpc.SendRequest\x1a\x13.lnrpc.SendResponse\"\x03\x88\x02\x01\x12F\n" +
	"\vSendToRoute\x12\x19.lnrpc.SendToRouteRequest\x1a\x13.lnrpc.SendResponse\"\x03\x88\x02\x01(\x010\x01\x12F\n" +
	"\x0fSendToRouteSync\x12\x19.lnrpc.SendToRouteRequest\x1a\x13.lnrpc.SendResponse\"\x03\x88\x02\x01\x127\n" +
	"\n" +
	"AddInvoice\x12\x0e.lnrpc.Invoice\x1a\x19.lnrpc.AddInvoiceResponse\x12E\n" +
	"\fListInvoices\x12\x19.lnrpc.ListInvoiceRequest\x1a\x1a.lnrpc.ListInvoiceResponse\x123\n" +
	"\rLookupInvoice\x12\x12.lnrpc.PaymentHash\x1a\x0e.lnrpc.Invoice\x12A\n" +
	"\x11SubscribeInvoices\x12\x1a.lnrpc.InvoiceSubscription\x1a\x0e.lnrpc.Invoice0\x01\x12T\n" +
	"\x15DeleteCanceledInvoice\x12\x1c.lnrpc.DelCanceledInvoiceReq\x1a\x1d.lnrpc.DelCanceledInvoiceResp\x122\n" +
	"\fDecodePayReq\x12\x13.lnrpc.PayReqString\x1a\r.lnrpc.PayReq\x12G\n" +
	"\fListPayments\x12\x1a.lnrpc.ListPaymentsRequest\x1a\x1b.lnrpc.ListPaymentsResponse\x12J\n" +
	"\rDeletePayment\x12\x1b.lnrpc.DeletePaymentRequest\x1a\x1c.lnrpc.DeletePaymentResponse\x12V\n" +
	"\x11DeleteAllPayments\x12\x1f.lnrpc.DeleteAllPaymentsRequest\x1a .lnrpc.DeleteAllPaymentsResponse\x12@\n" +
	"\rDescribeGraph\x12\x1a.lnrpc.ChannelGraphRequest\x1a\x13.lnrpc.ChannelGraph\x12G\n" +
	"\x0eGetNodeMetrics\x12\x19.lnrpc.NodeMetricsRequest\x1a\x1a.lnrpc.NodeMetricsResponse\x129\n" +
	"\vGetChanInfo\x12\x16.lnrpc.ChanInfoRequest\x1a\x12.lnrpc.ChannelEdge\x126\n" +
	"\vGetNodeInfo\x12\x16.lnrpc.NodeInfoRequest\x1a\x0f.lnrpc.NodeInfo\x12D\n" +
	"\vQueryRoutes\x12\x19.lnrpc.QueryRoutesRequest\x1a\x1a.lnrpc.QueryRoutesResponse\x12?\n" +
	"\x0eGetNetworkInfo\x12\x19.lnrpc.NetworkInfoRequest\x1a\x12.lnrpc.NetworkInfo\x125\n" +
	"\n" +
	"StopDaemon\x12\x12.lnrpc.StopRequest\x1a\x13.lnrpc.StopResponse\x12W\n" +
	"\x15SubscribeChannelGraph\x12 .lnrpc.GraphTopologySubscription\x1a\x1a.lnrpc.GraphTopologyUpdate0\x01\x12A\n" +
	"\n" +
	"DebugLevel\x12\x18.lnrpc.DebugLevelRequest\x1a\x19.lnrpc.DebugLevelResponse\x12>\n" +
	"\tFeeReport\x12\x17.lnrpc.FeeReportRequest\x1a\x18.lnrpc.FeeReportResponse\x12N\n" +
	"\x13UpdateChannelPolicy\x12\x1a.lnrpc.PolicyUpdateRequest\x1a\x1b.lnrpc.PolicyUpdateResponse\x12V\n" +
	"\x11ForwardingHistory\x12\x1f.lnrpc.ForwardingHistoryRequest\x1a .lnrpc.ForwardingHistoryResponse\x12N\n" +
	"\x13ExportChannelBackup\x12!.lnrpc.ExportChannelBackupRequest\x1a\x14.lnrpc.ChannelBackup\x12T\n" +
	"\x17ExportAllChannelBackups\x12\x1e.lnrpc.ChanBackupExportRequest\x1a\x19.lnrpc.ChanBackupSnapshot\x12N\n" +
	"\x10VerifyChanBackup\x12\x19.lnrpc.ChanBackupSnapshot\x1a\x1f.lnrpc.VerifyChanBackupResponse\x12V\n" +
	"\x15RestoreChannelBackups\x12\x1f.lnrpc.RestoreChanBackupRequest\x1a\x1c.lnrpc.RestoreBackupResponse\x12X\n" +
	"\x17SubscribeChannelBackups\x12 .lnrpc.ChannelBackupSubscription\x1a\x19.lnrpc.ChanBackupSnapshot0\x01\x12G\n" +
	"\fBakeMacaroon\x12\x1a.lnrpc.BakeMacaroonRequest\x1a\x1b.lnrpc.BakeMacaroonResponse\x12P\n" +
	"\x0fListMacaroonIDs\x12\x1d.lnrpc.ListMacaroonIDsRequest\x1a\x1e.lnrpc.ListMacaroonIDsResponse\x12S\n" +
	"\x10DeleteMacaroonID\x12\x1e.lnrpc.DeleteMacaroonIDRequest\x1a\x1f.lnrpc.DeleteMacaroonIDResponse\x12P\n" +
	"\x0fListPermissions\x12\x1d.lnrpc.ListPermissionsRequest\x1a\x1e.lnrpc.ListPermissionsResponse\x12S\n" +
	"\x18CheckMacaroonPermissions\x12\x1a.lnrpc.CheckMacPermRequest\x1a\x1b.lnrpc.CheckMacPermResponse\x12V\n" +
	"\x15RegisterRPCMiddleware\x12\x1c.lnrpc.RPCMiddlewareResponse\x1a\x1b.lnrpc.RPCMiddlewareRequest(\x010\x01\x12V\n" +
	"\x11SendCustomMessage\x12\x1f.lnrpc.SendCustomMessageRequest\x1a .lnrpc.SendCustomMessageResponse\x12X\n" +
	"\x17SubscribeCustomMessages\x12%.lnrpc.SubscribeCustomMessagesRequest\x1a\x14.lnrpc.CustomMessage0\x01\x12S\n" +
	"\x10SendOnionMessage\x12\x1e.lnrpc.SendOnionMessageRequest\x1a\x1f.lnrpc.SendOnionMessageResponse\x12U\n" +
	"\x16SubscribeOnionMessages\x12$.lnrpc.SubscribeOnionMessagesRequest\x1a\x13.lnrpc.OnionMessage0\x01\x12D\n" +
	"\vListAliases\x12\x19.lnrpc.ListAliasesRequest\x1a\x1a.lnrpc.ListAliasesResponse\x12_\n" +
	"\x14LookupHtlcResolution\x12\".lnrpc.LookupHtlcResolutionRequest\x1a#.lnrpc.LookupHtlcResolutionResponseB'Z%github.com/lightningnetwork/lnd/lnrpcb\x06proto3"

var (
	file_lightning_proto_rawDescOnce sync.Once
	file_lightning_proto_rawDescData []byte
)

func file_lightning_proto_rawDescGZIP() []byte {
	file_lightning_proto_rawDescOnce.Do(func() {
		file_lightning_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_lightning_proto_rawDesc), len(file_lightning_proto_rawDesc)))
	})
	return file_lightning_proto_rawDescData
}

var file_lightning_proto_enumTypes = make([]protoimpl.EnumInfo, 21)
var file_lightning_proto_msgTypes = make([]protoimpl.MessageInfo, 236)
var file_lightning_proto_goTypes = []any{
	(OutputScriptType)(0),                // 0: lnrpc.OutputScriptType
	(CoinSelectionStrategy)(0),           // 1: lnrpc.CoinSelectionStrategy
	(AddressType)(0),                     // 2: lnrpc.AddressType
	(CommitmentType)(0),                  // 3: lnrpc.CommitmentType
	(Initiator)(0),                       // 4: lnrpc.Initiator
	(ResolutionType)(0),                  // 5: lnrpc.ResolutionType
	(ResolutionOutcome)(0),               // 6: lnrpc.ResolutionOutcome
	(NodeMetricType)(0),                  // 7: lnrpc.NodeMetricType
	(InvoiceHTLCState)(0),                // 8: lnrpc.InvoiceHTLCState
	(PaymentFailureReason)(0),            // 9: lnrpc.PaymentFailureReason
	(FeatureBit)(0),                      // 10: lnrpc.FeatureBit
	(UpdateFailure)(0),                   // 11: lnrpc.UpdateFailure
	(ChannelCloseSummary_ClosureType)(0), // 12: lnrpc.ChannelCloseSummary.ClosureType
	(Peer_SyncType)(0),                   // 13: lnrpc.Peer.SyncType
	(PeerEvent_EventType)(0),             // 14: lnrpc.PeerEvent.EventType
	(PendingChannelsResponse_ForceClosedChannel_AnchorState)(0), // 15: lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState
	(ChannelEventUpdate_UpdateType)(0),                          // 16: lnrpc.ChannelEventUpdate.UpdateType
	(Invoice_InvoiceState)(0),                                   // 17: lnrpc.Invoice.InvoiceState
	(Payment_PaymentStatus)(0),                                  // 18: lnrpc.Payment.PaymentStatus
	(HTLCAttempt_HTLCStatus)(0),                                 // 19: lnrpc.HTLCAttempt.HTLCStatus
	(Failure_FailureCode)(0),                                    // 20: lnrpc.Failure.FailureCode
	(*LookupHtlcResolutionRequest)(nil),                         // 21: lnrpc.LookupHtlcResolutionRequest
	(*LookupHtlcResolutionResponse)(nil),                        // 22: lnrpc.LookupHtlcResolutionResponse
	(*SubscribeCustomMessagesRequest)(nil),                      // 23: lnrpc.SubscribeCustomMessagesRequest
	(*CustomMessage)(nil),                                       // 24: lnrpc.CustomMessage
	(*SendCustomMessageRequest)(nil),                            // 25: lnrpc.SendCustomMessageRequest
	(*SendCustomMessageResponse)(nil),                           // 26: lnrpc.SendCustomMessageResponse
	(*SubscribeOnionMessagesRequest)(nil),                       // 27: lnrpc.SubscribeOnionMessagesRequest
	(*OnionMessage)(nil),                                        // 28: lnrpc.OnionMessage
	(*SendOnionMessageRequest)(nil),                             // 29: lnrpc.SendOnionMessageRequest
	(*SendOnionMessageResponse)(nil),                            // 30: lnrpc.SendOnionMessageResponse
	(*Utxo)(nil),                                                // 31: lnrpc.Utxo
	(*OutputDetail)(nil),                                        // 32: lnrpc.OutputDetail
	(*Transaction)(nil),                                         // 33: lnrpc.Transaction
	(*GetTransactionsRequest)(nil),                              // 34: lnrpc.GetTransactionsRequest
	(*TransactionDetails)(nil),                                  // 35: lnrpc.TransactionDetails
	(*FeeLimit)(nil),                                            // 36: lnrpc.FeeLimit
	(*SendRequest)(nil),                                         // 37: lnrpc.SendRequest
	(*SendResponse)(nil),                                        // 38: lnrpc.SendResponse
	(*SendToRouteRequest)(nil),                                  // 39: lnrpc.SendToRouteRequest
	(*ChannelAcceptRequest)(nil),                                // 40: lnrpc.ChannelAcceptRequest
	(*ChannelAcceptResponse)(nil),                               // 41: lnrpc.ChannelAcceptResponse
	(*ChannelPoint)(nil),                                        // 42: lnrpc.ChannelPoint
	(*OutPoint)(nil),                                            // 43: lnrpc.OutPoint
	(*PreviousOutPoint)(nil),                                    // 44: lnrpc.PreviousOutPoint
	(*LightningAddress)(nil),                                    // 45: lnrpc.LightningAddress
	(*EstimateFeeRequest)(nil),                                  // 46: lnrpc.EstimateFeeRequest
	(*EstimateFeeResponse)(nil),                                 // 47: lnrpc.EstimateFeeResponse
	(*SendManyRequest)(nil),                                     // 48: lnrpc.SendManyRequest
	(*SendManyResponse)(nil),                                    // 49: lnrpc.SendManyResponse
	(*SendCoinsRequest)(nil),                                    // 50: lnrpc.SendCoinsRequest
	(*SendCoinsResponse)(nil),                                   // 51: lnrpc.SendCoinsResponse
	(*ListUnspentRequest)(nil),                                  // 52: lnrpc.ListUnspentRequest
	(*ListUnspentResponse)(nil),                                 // 53: lnrpc.ListUnspentResponse
	(*NewAddressRequest)(nil),                                   // 54: lnrpc.NewAddressRequest
	(*NewAddressResponse)(nil),                                  // 55: lnrpc.NewAddressResponse
	(*SignMessageRequest)(nil),                                  // 56: lnrpc.SignMessageRequest
	(*SignMessageResponse)(nil),                                 // 57: lnrpc.SignMessageResponse
	(*VerifyMessageRequest)(nil),                                // 58: lnrpc.VerifyMessageRequest
	(*VerifyMessageResponse)(nil),                               // 59: lnrpc.VerifyMessageResponse
	(*ConnectPeerRequest)(nil),                                  // 60: lnrpc.ConnectPeerRequest
	(*ConnectPeerResponse)(nil),                                 // 61: lnrpc.ConnectPeerResponse
	(*DisconnectPeerRequest)(nil),                               // 62: lnrpc.DisconnectPeerRequest
	(*DisconnectPeerResponse)(nil),                              // 63: lnrpc.DisconnectPeerResponse
	(*HTLC)(nil),                                                // 64: lnrpc.HTLC
	(*ChannelConstraints)(nil),                                  // 65: lnrpc.ChannelConstraints
	(*Channel)(nil),                                             // 66: lnrpc.Channel
	(*ListChannelsRequest)(nil),                                 // 67: lnrpc.ListChannelsRequest
	(*ListChannelsResponse)(nil),                                // 68: lnrpc.ListChannelsResponse
	(*AliasMap)(nil),                                            // 69: lnrpc.AliasMap
	(*ListAliasesRequest)(nil),                                  // 70: lnrpc.ListAliasesRequest
	(*ListAliasesResponse)(nil),                                 // 71: lnrpc.ListAliasesResponse
	(*ChannelCloseSummary)(nil),                                 // 72: lnrpc.ChannelCloseSummary
	(*Resolution)(nil),                                          // 73: lnrpc.Resolution
	(*ClosedChannelsRequest)(nil),                               // 74: lnrpc.ClosedChannelsRequest
	(*ClosedChannelsResponse)(nil),                              // 75: lnrpc.ClosedChannelsResponse
	(*Peer)(nil),                                                // 76: lnrpc.Peer
	(*TimestampedError)(nil),                                    // 77: lnrpc.TimestampedError
	(*ListPeersRequest)(nil),                                    // 78: lnrpc.ListPeersRequest
	(*ListPeersResponse)(nil),                                   // 79: lnrpc.ListPeersResponse
	(*PeerEventSubscription)(nil),                               // 80: lnrpc.PeerEventSubscription
	(*PeerEvent)(nil),                                           // 81: lnrpc.PeerEvent
	(*GetInfoRequest)(nil),                                      // 82: lnrpc.GetInfoRequest
	(*GetInfoResponse)(nil),                                     // 83: lnrpc.GetInfoResponse
	(*GetDebugInfoRequest)(nil),                                 // 84: lnrpc.GetDebugInfoRequest
	(*GetDebugInfoResponse)(nil),                                // 85: lnrpc.GetDebugInfoResponse
	(*GetRecoveryInfoRequest)(nil),                              // 86: lnrpc.GetRecoveryInfoRequest
	(*GetRecoveryInfoResponse)(nil),                             // 87: lnrpc.GetRecoveryInfoResponse
	(*Chain)(nil),                                               // 88: lnrpc.Chain
	(*ChannelOpenUpdate)(nil),                                   // 89: lnrpc.ChannelOpenUpdate
	(*CloseOutput)(nil),                                         // 90: lnrpc.CloseOutput
	(*ChannelCloseUpdate)(nil),                                  // 91: lnrpc.ChannelCloseUpdate
	(*CloseChannelRequest)(nil),                                 // 92: lnrpc.CloseChannelRequest
	(*CloseStatusUpdate)(nil),                                   // 93: lnrpc.CloseStatusUpdate
	(*PendingUpdate)(nil),                                       // 94: lnrpc.PendingUpdate
	(*InstantUpdate)(nil),                                       // 95: lnrpc.InstantUpdate
	(*ReadyForPsbtFunding)(nil),                                 // 96: lnrpc.ReadyForPsbtFunding
	(*BatchOpenChannelRequest)(nil),                             // 97: lnrpc.BatchOpenChannelRequest
	(*BatchOpenChannel)(nil),                                    // 98: lnrpc.BatchOpenChannel
	(*BatchOpenChannelResponse)(nil),                            // 99: lnrpc.BatchOpenChannelResponse
	(*OpenChannelRequest)(nil),                                  // 100: lnrpc.OpenChannelRequest
	(*OpenStatusUpdate)(nil),                                    // 101: lnrpc.OpenStatusUpdate
	(*KeyLocator)(nil),                                          // 102: lnrpc.KeyLocator
	(*KeyDescriptor)(nil),                                       // 103: lnrpc.KeyDescriptor
	(*ChanPointShim)(nil),                                       // 104: lnrpc.ChanPointShim
	(*PsbtShim)(nil),                                            // 105: lnrpc.PsbtShim
	(*FundingShim)(nil),                                         // 106: lnrpc.FundingShim
	(*FundingShimCancel)(nil),                                   // 107: lnrpc.FundingShimCancel
	(*FundingPsbtVerify)(nil),                                   // 108: lnrpc.FundingPsbtVerify
	(*FundingPsbtFinalize)(nil),                                 // 109: lnrpc.FundingPsbtFinalize
	(*FundingTransitionMsg)(nil),                                // 110: lnrpc.FundingTransitionMsg
	(*FundingStateStepResp)(nil),                                // 111: lnrpc.FundingStateStepResp
	(*PendingHTLC)(nil),                                         // 112: lnrpc.PendingHTLC
	(*PendingChannelsRequest)(nil),                              // 113: lnrpc.PendingChannelsRequest
	(*PendingChannelsResponse)(nil),                             // 114: lnrpc.PendingChannelsResponse
	(*ChannelEventSubscription)(nil),                            // 115: lnrpc.ChannelEventSubscription
	(*ChannelEventUpdate)(nil),                                  // 116: lnrpc.ChannelEventUpdate
	(*WalletAccountBalance)(nil),                                // 117: lnrpc.WalletAccountBalance
	(*WalletBalanceRequest)(nil),                                // 118: lnrpc.WalletBalanceRequest
	(*WalletBalanceResponse)(nil),                               // 119: lnrpc.WalletBalanceResponse
	(*Amount)(nil),                                              // 120: lnrpc.Amount
	(*ChannelBalanceRequest)(nil),                               // 121: lnrpc.ChannelBalanceRequest
	(*ChannelBalanceResponse)(nil),                              // 122: lnrpc.ChannelBalanceResponse
	(*QueryRoutesRequest)(nil),                                  // 123: lnrpc.QueryRoutesRequest
	(*NodePair)(nil),                                            // 124: lnrpc.NodePair
	(*EdgeLocator)(nil),                                         // 125: lnrpc.EdgeLocator
	(*QueryRoutesResponse)(nil),                                 // 126: lnrpc.QueryRoutesResponse
	(*Hop)(nil),                                                 // 127: lnrpc.Hop
	(*MPPRecord)(nil),                                           // 128: lnrpc.MPPRecord
	(*AMPRecord)(nil),                                           // 129: lnrpc.AMPRecord
	(*Route)(nil),                                               // 130: lnrpc.Route
	(*NodeInfoRequest)(nil),                                     // 131: lnrpc.NodeInfoRequest
	(*NodeInfo)(nil),                                            // 132: lnrpc.NodeInfo
	(*LightningNode)(nil),                                       // 133: lnrpc.LightningNode
	(*NodeAddress)(nil),                                         // 134: lnrpc.NodeAddress
	(*RoutingPolicy)(nil),                                       // 135: lnrpc.RoutingPolicy
	(*ChannelAuthProof)(nil),                                    // 136: lnrpc.ChannelAuthProof
	(*ChannelEdge)(nil),                                         // 137: lnrpc.ChannelEdge
	(*ChannelGraphRequest)(nil),                                 // 138: lnrpc.ChannelGraphRequest
	(*ChannelGraph)(nil),                                        // 139: lnrpc.ChannelGraph
	(*NodeMetricsRequest)(nil),                                  // 140: lnrpc.NodeMetricsRequest
	(*NodeMetricsResponse)(nil),                                 // 141: lnrpc.NodeMetricsResponse
	(*FloatMetric)(nil),                                         // 142: lnrpc.FloatMetric
	(*ChanInfoRequest)(nil),                                     // 143: lnrpc.ChanInfoRequest
	(*NetworkInfoRequest)(nil),                                  // 144: lnrpc.NetworkInfoRequest
	(*NetworkInfo)(nil),                                         // 145: lnrpc.NetworkInfo
	(*StopRequest)(nil),                                         // 146: lnrpc.StopRequest
	(*StopResponse)(nil),                                        // 147: lnrpc.StopResponse
	(*GraphTopologySubscription)(nil),                           // 148: lnrpc.GraphTopologySubscription
	(*GraphTopologyUpdate)(nil),                                 // 149: lnrpc.GraphTopologyUpdate
	(*NodeUpdate)(nil),                                          // 150: lnrpc.NodeUpdate
	(*ChannelEdgeUpdate)(nil),                                   // 151: lnrpc.ChannelEdgeUpdate
	(*ClosedChannelUpdate)(nil),                                 // 152: lnrpc.ClosedChannelUpdate
	(*HopHint)(nil),                                             // 153: lnrpc.HopHint
	(*SetID)(nil),                                               // 154: lnrpc.SetID
	(*RouteHint)(nil),                                           // 155: lnrpc.RouteHint
	(*BlindedPaymentPath)(nil),                                  // 156: lnrpc.BlindedPaymentPath
	(*BlindedPath)(nil),                                         // 157: lnrpc.BlindedPath
	(*BlindedHop)(nil),                                          // 158: lnrpc.BlindedHop
	(*AMPInvoiceState)(nil),                                     // 159: lnrpc.AMPInvoiceState
	(*Invoice)(nil),                                             // 160: lnrpc.Invoice
	(*BlindedPathConfig)(nil),                                   // 161: lnrpc.BlindedPathConfig
	(*InvoiceHTLC)(nil),                                         // 162: lnrpc.InvoiceHTLC
	(*AMP)(nil),                                                 // 163: lnrpc.AMP
	(*AddInvoiceResponse)(nil),                                  // 164: lnrpc.AddInvoiceResponse
	(*PaymentHash)(nil),                                         // 165: lnrpc.PaymentHash
	(*ListInvoiceRequest)(nil),                                  // 166: lnrpc.ListInvoiceRequest
	(*ListInvoiceResponse)(nil),                                 // 167: lnrpc.ListInvoiceResponse
	(*InvoiceSubscription)(nil),                                 // 168: lnrpc.InvoiceSubscription
	(*DelCanceledInvoiceReq)(nil),                               // 169: lnrpc.DelCanceledInvoiceReq
	(*DelCanceledInvoiceResp)(nil),                              // 170: lnrpc.DelCanceledInvoiceResp
	(*Payment)(nil),                                             // 171: lnrpc.Payment
	(*HTLCAttempt)(nil),                                         // 172: lnrpc.HTLCAttempt
	(*ListPaymentsRequest)(nil),                                 // 173: lnrpc.ListPaymentsRequest
	(*ListPaymentsResponse)(nil),                                // 174: lnrpc.ListPaymentsResponse
	(*DeletePaymentRequest)(nil),                                // 175: lnrpc.DeletePaymentRequest
	(*DeleteAllPaymentsRequest)(nil),                            // 176: lnrpc.DeleteAllPaymentsRequest
	(*DeletePaymentResponse)(nil),                               // 177: lnrpc.DeletePaymentResponse
	(*DeleteAllPaymentsResponse)(nil),                           // 178: lnrpc.DeleteAllPaymentsResponse
	(*AbandonChannelRequest)(nil),                               // 179: lnrpc.AbandonChannelRequest
	(*AbandonChannelResponse)(nil),                              // 180: lnrpc.AbandonChannelResponse
	(*DebugLevelRequest)(nil),                                   // 181: lnrpc.DebugLevelRequest
	(*DebugLevelResponse)(nil),                                  // 182: lnrpc.DebugLevelResponse
	(*PayReqString)(nil),                                        // 183: lnrpc.PayReqString
	(*PayReq)(nil),                                              // 184: lnrpc.PayReq
	(*Feature)(nil),                                             // 185: lnrpc.Feature
	(*FeeReportRequest)(nil),                                    // 186: lnrpc.FeeReportRequest
	(*ChannelFeeReport)(nil),                                    // 187: lnrpc.ChannelFeeReport
	(*FeeReportResponse)(nil),                                   // 188: lnrpc.FeeReportResponse
	(*InboundFee)(nil),                                          // 189: lnrpc.InboundFee
	(*PolicyUpdateRequest)(nil),                                 // 190: lnrpc.PolicyUpdateRequest
	(*FailedUpdate)(nil),                                        // 191: lnrpc.FailedUpdate
	(*PolicyUpdateResponse)(nil),                                // 192: lnrpc.PolicyUpdateResponse
	(*ForwardingHistoryRequest)(nil),                            // 193: lnrpc.ForwardingHistoryRequest
	(*ForwardingEvent)(nil),                                     // 194: lnrpc.ForwardingEvent
	(*ForwardingHistoryResponse)(nil),                           // 195: lnrpc.ForwardingHistoryResponse
	(*ExportChannelBackupRequest)(nil),                          // 196: lnrpc.ExportChannelBackupRequest
	(*ChannelBackup)(nil),                                       // 197: lnrpc.ChannelBackup
	(*MultiChanBackup)(nil),                                     // 198: lnrpc.MultiChanBackup
	(*ChanBackupExportRequest)(nil),                             // 199: lnrpc.ChanBackupExportRequest
	(*ChanBackupSnapshot)(nil),                                  // 200: lnrpc.ChanBackupSnapshot
	(*ChannelBackups)(nil),                                      // 201: lnrpc.ChannelBackups
	(*RestoreChanBackupRequest)(nil),                            // 202: lnrpc.RestoreChanBackupRequest
	(*RestoreBackupResponse)(nil),                               // 203: lnrpc.RestoreBackupResponse
	(*ChannelBackupSubscription)(nil),                           // 204: lnrpc.ChannelBackupSubscription
	(*VerifyChanBackupResponse)(nil),                            // 205: lnrpc.VerifyChanBackupResponse
	(*MacaroonPermission)(nil),                                  // 206: lnrpc.MacaroonPermission
	(*BakeMacaroonRequest)(nil),                                 // 207: lnrpc.BakeMacaroonRequest
	(*BakeMacaroonResponse)(nil),                                // 208: lnrpc.BakeMacaroonResponse
	(*ListMacaroonIDsRequest)(nil),                              // 209: lnrpc.ListMacaroonIDsRequest
	(*ListMacaroonIDsResponse)(nil),                             // 210: lnrpc.ListMacaroonIDsResponse
	(*DeleteMacaroonIDRequest)(nil),                             // 211: lnrpc.DeleteMacaroonIDRequest
	(*DeleteMacaroonIDResponse)(nil),                            // 212: lnrpc.DeleteMacaroonIDResponse
	(*MacaroonPermissionList)(nil),                              // 213: lnrpc.MacaroonPermissionList
	(*ListPermissionsRequest)(nil),                              // 214: lnrpc.ListPermissionsRequest
	(*ListPermissionsResponse)(nil),                             // 215: lnrpc.ListPermissionsResponse
	(*Failure)(nil),                                             // 216: lnrpc.Failure
	(*ChannelUpdate)(nil),                                       // 217: lnrpc.ChannelUpdate
	(*MacaroonId)(nil),                                          // 218: lnrpc.MacaroonId
	(*Op)(nil),                                                  // 219: lnrpc.Op
	(*CheckMacPermRequest)(nil),                                 // 220: lnrpc.CheckMacPermRequest
	(*CheckMacPermResponse)(nil),                                // 221: lnrpc.CheckMacPermResponse
	(*RPCMiddlewareRequest)(nil),                                // 222: lnrpc.RPCMiddlewareRequest
	(*MetadataValues)(nil),                                      // 223: lnrpc.MetadataValues
	(*StreamAuth)(nil),                                          // 224: lnrpc.StreamAuth
	(*RPCMessage)(nil),                                          // 225: lnrpc.RPCMessage
	(*RPCMiddlewareResponse)(nil),                               // 226: lnrpc.RPCMiddlewareResponse
	(*MiddlewareRegistration)(nil),                              // 227: lnrpc.MiddlewareRegistration
	(*InterceptFeedback)(nil),                                   // 228: lnrpc.InterceptFeedback
	nil,                                                         // 229: lnrpc.SendRequest.DestCustomRecordsEntry
	nil,                                                         // 230: lnrpc.EstimateFeeRequest.AddrToAmountEntry
	nil,                                                         // 231: lnrpc.SendManyRequest.AddrToAmountEntry
	nil,                                                         // 232: lnrpc.Peer.FeaturesEntry
	nil,                                                         // 233: lnrpc.GetInfoResponse.FeaturesEntry
	nil,                                                         // 234: lnrpc.GetDebugInfoResponse.ConfigEntry
	(*PendingChannelsResponse_PendingChannel)(nil),              // 235: lnrpc.PendingChannelsResponse.PendingChannel
	(*PendingChannelsResponse_PendingOpenChannel)(nil),          // 236: lnrpc.PendingChannelsResponse.PendingOpenChannel
	(*PendingChannelsResponse_WaitingCloseChannel)(nil),         // 237: lnrpc.PendingChannelsResponse.WaitingCloseChannel
	(*PendingChannelsResponse_Commitments)(nil),                 // 238: lnrpc.PendingChannelsResponse.Commitments
	(*PendingChannelsResponse_ClosedChannel)(nil),               // 239: lnrpc.PendingChannelsResponse.ClosedChannel
	(*PendingChannelsResponse_ForceClosedChannel)(nil),          // 240: lnrpc.PendingChannelsResponse.ForceClosedChannel
	nil, // 241: lnrpc.WalletBalanceResponse.AccountBalanceEntry
	nil, // 242: lnrpc.QueryRoutesRequest.DestCustomRecordsEntry
	nil, // 243: lnrpc.Hop.CustomRecordsEntry
	nil, // 244: lnrpc.LightningNode.FeaturesEntry
	nil, // 245: lnrpc.LightningNode.CustomRecordsEntry
	nil, // 246: lnrpc.RoutingPolicy.CustomRecordsEntry
	nil, // 247: lnrpc.ChannelEdge.CustomRecordsEntry
	nil, // 248: lnrpc.NodeMetricsResponse.BetweennessCentralityEntry
	nil, // 249: lnrpc.NodeUpdate.FeaturesEntry
	nil, // 250: lnrpc.Invoice.FeaturesEntry
	nil, // 251: lnrpc.Invoice.AmpInvoiceStateEntry
	nil, // 252: lnrpc.InvoiceHTLC.CustomRecordsEntry
	nil, // 253: lnrpc.Payment.FirstHopCustomRecordsEntry
	nil, // 254: lnrpc.PayReq.FeaturesEntry
	nil, // 255: lnrpc.ListPermissionsResponse.MethodPermissionsEntry
	nil, // 256: lnrpc.RPCMiddlewareRequest.MetadataPairsEntry
}
var file_lightning_proto_depIdxs = []int32{
	2,   // 0: lnrpc.Utxo.address_type:type_name -> lnrpc.AddressType
	43,  // 1: lnrpc.Utxo.outpoint:type_name -> lnrpc.OutPoint
	0,   // 2: lnrpc.OutputDetail.output_type:type_name -> lnrpc.OutputScriptType
	32,  // 3: lnrpc.Transaction.output_details:type_name -> lnrpc.OutputDetail
	44,  // 4: lnrpc.Transaction.previous_outpoints:type_name -> lnrpc.PreviousOutPoint
	33,  // 5: lnrpc.TransactionDetails.transactions:type_name -> lnrpc.Transaction
	36,  // 6: lnrpc.SendRequest.fee_limit:type_name -> lnrpc.FeeLimit
	229, // 7: lnrpc.SendRequest.dest_custom_records:type_name -> lnrpc.SendRequest.DestCustomRecordsEntry
	10,  // 8: lnrpc.SendRequest.dest_features:type_name -> lnrpc.FeatureBit
	130, // 9: lnrpc.SendResponse.payment_route:type_name -> lnrpc.Route
	130, // 10: lnrpc.SendToRouteRequest.route:type_name -> lnrpc.Route
	3,   // 11: lnrpc.ChannelAcceptRequest.commitment_type:type_name -> lnrpc.CommitmentType
	230, // 12: lnrpc.EstimateFeeRequest.AddrToAmount:type_name -> lnrpc.EstimateFeeRequest.AddrToAmountEntry
	1,   // 13: lnrpc.EstimateFeeRequest.coin_selection_strategy:type_name -> lnrpc.CoinSelectionStrategy
	231, // 14: lnrpc.SendManyRequest.AddrToAmount:type_name -> lnrpc.SendManyRequest.AddrToAmountEntry
	1,   // 15: lnrpc.SendManyRequest.coin_selection_strategy:type_name -> lnrpc.CoinSelectionStrategy
	1,   // 16: lnrpc.SendCoinsRequest.coin_selection_strategy:type_name -> lnrpc.CoinSelectionStrategy
	43,  // 17: lnrpc.SendCoinsRequest.outpoints:type_name -> lnrpc.OutPoint
	31,  // 18: lnrpc.ListUnspentResponse.utxos:type_name -> lnrpc.Utxo
	2,   // 19: lnrpc.NewAddressRequest.type:type_name -> lnrpc.AddressType
	45,  // 20: lnrpc.ConnectPeerRequest.addr:type_name -> lnrpc.LightningAddress
	64,  // 21: lnrpc.Channel.pending_htlcs:type_name -> lnrpc.HTLC
	3,   // 22: lnrpc.Channel.commitment_type:type_name -> lnrpc.CommitmentType
	65,  // 23: lnrpc.Channel.local_constraints:type_name -> lnrpc.ChannelConstraints
	65,  // 24: lnrpc.Channel.remote_constraints:type_name -> lnrpc.ChannelConstraints
	66,  // 25: lnrpc.ListChannelsResponse.channels:type_name -> lnrpc.Channel
	69,  // 26: lnrpc.ListAliasesResponse.alias_maps:type_name -> lnrpc.AliasMap
	12,  // 27: lnrpc.ChannelCloseSummary.close_type:type_name -> lnrpc.ChannelCloseSummary.ClosureType
	4,   // 28: lnrpc.ChannelCloseSummary.open_initiator:type_name -> lnrpc.Initiator
	4,   // 29: lnrpc.ChannelCloseSummary.close_initiator:type_name -> lnrpc.Initiator
	73,  // 30: lnrpc.ChannelCloseSummary.resolutions:type_name -> lnrpc.Resolution
	5,   // 31: lnrpc.Resolution.resolution_type:type_name -> lnrpc.ResolutionType
	6,   // 32: lnrpc.Resolution.outcome:type_name -> lnrpc.ResolutionOutcome
	43,  // 33: lnrpc.Resolution.outpoint:type_name -> lnrpc.OutPoint
	72,  // 34: lnrpc.ClosedChannelsResponse.channels:type_name -> lnrpc.ChannelCloseSummary
	13,  // 35: lnrpc.Peer.sync_type:type_name -> lnrpc.Peer.SyncType
	232, // 36: lnrpc.Peer.features:type_name -> lnrpc.Peer.FeaturesEntry
	77,  // 37: lnrpc.Peer.errors:type_name -> lnrpc.TimestampedError
	76,  // 38: lnrpc.ListPeersResponse.peers:type_name -> lnrpc.Peer
	14,  // 39: lnrpc.PeerEvent.type:type_name -> lnrpc.PeerEvent.EventType
	88,  // 40: lnrpc.GetInfoResponse.chains:type_name -> lnrpc.Chain
	233, // 41: lnrpc.GetInfoResponse.features:type_name -> lnrpc.GetInfoResponse.FeaturesEntry
	234, // 42: lnrpc.GetDebugInfoResponse.config:type_name -> lnrpc.GetDebugInfoResponse.ConfigEntry
	42,  // 43: lnrpc.ChannelOpenUpdate.channel_point:type_name -> lnrpc.ChannelPoint
	90,  // 44: lnrpc.ChannelCloseUpdate.local_close_output:type_name -> lnrpc.CloseOutput
	90,  // 45: lnrpc.ChannelCloseUpdate.remote_close_output:type_name -> lnrpc.CloseOutput
	90,  // 46: lnrpc.ChannelCloseUpdate.additional_outputs:type_name -> lnrpc.CloseOutput
	42,  // 47: lnrpc.CloseChannelRequest.channel_point:type_name -> lnrpc.ChannelPoint
	94,  // 48: lnrpc.CloseStatusUpdate.close_pending:type_name -> lnrpc.PendingUpdate
	91,  // 49: lnrpc.CloseStatusUpdate.chan_close:type_name -> lnrpc.ChannelCloseUpdate
	95,  // 50: lnrpc.CloseStatusUpdate.close_instant:type_name -> lnrpc.InstantUpdate
	98,  // 51: lnrpc.BatchOpenChannelRequest.channels:type_name -> lnrpc.BatchOpenChannel
	1,   // 52: lnrpc.BatchOpenChannelRequest.coin_selection_strategy:type_name -> lnrpc.CoinSelectionStrategy
	3,   // 53: lnrpc.BatchOpenChannel.commitment_type:type_name -> lnrpc.CommitmentType
	94,  // 54: lnrpc.BatchOpenChannelResponse.pending_channels:type_name -> lnrpc.PendingUpdate
	106, // 55: lnrpc.OpenChannelRequest.funding_shim:type_name -> lnrpc.FundingShim
	3,   // 56: lnrpc.OpenChannelRequest.commitment_type:type_name -> lnrpc.CommitmentType
	43,  // 57: lnrpc.OpenChannelRequest.outpoints:type_name -> lnrpc.OutPoint
	94,  // 58: lnrpc.OpenStatusUpdate.chan_pending:type_name -> lnrpc.PendingUpdate
	89,  // 59: lnrpc.OpenStatusUpdate.chan_open:type_name -> lnrpc.ChannelOpenUpdate
	96,  // 60: lnrpc.OpenStatusUpdate.psbt_fund:type_name -> lnrpc.ReadyForPsbtFunding
	102, // 61: lnrpc.KeyDescriptor.key_loc:type_name -> lnrpc.KeyLocator
	42,  // 62: lnrpc.ChanPointShim.chan_point:type_name -> lnrpc.ChannelPoint
	103, // 63: lnrpc.ChanPointShim.local_key:type_name -> lnrpc.KeyDescriptor
	104, // 64: lnrpc.FundingShim.chan_point_shim:type_name -> lnrpc.ChanPointShim
	105, // 65: lnrpc.FundingShim.psbt_shim:type_name -> lnrpc.PsbtShim
	106, // 66: lnrpc.FundingTransitionMsg.shim_register:type_name -> lnrpc.FundingShim
	107, // 67: lnrpc.FundingTransitionMsg.shim_cancel:type_name -> lnrpc.FundingShimCancel
	108, // 68: lnrpc.FundingTransitionMsg.psbt_verify:type_name -> lnrpc.FundingPsbtVerify
	109, // 69: lnrpc.FundingTransitionMsg.psbt_finalize:type_name -> lnrpc.FundingPsbtFinalize
	236, // 70: lnrpc.PendingChannelsResponse.pending_open_channels:type_name -> lnrpc.PendingChannelsResponse.PendingOpenChannel
	239, // 71: lnrpc.PendingChannelsResponse.pending_closing_channels:type_name -> lnrpc.PendingChannelsResponse.ClosedChannel
	240, // 72: lnrpc.PendingChannelsResponse.pending_force_closing_channels:type_name -> lnrpc.PendingChannelsResponse.ForceClosedChannel
	237, // 73: lnrpc.PendingChannelsResponse.waiting_close_channels:type_name -> lnrpc.PendingChannelsResponse.WaitingCloseChannel
	66,  // 74: lnrpc.ChannelEventUpdate.open_channel:type_name -> lnrpc.Channel
	72,  // 75: lnrpc.ChannelEventUpdate.closed_channel:type_name -> lnrpc.ChannelCloseSummary
	42,  // 76: lnrpc.ChannelEventUpdate.active_channel:type_name -> lnrpc.ChannelPoint
	42,  // 77: lnrpc.ChannelEventUpdate.inactive_channel:type_name -> lnrpc.ChannelPoint
	94,  // 78: lnrpc.ChannelEventUpdate.pending_open_channel:type_name -> lnrpc.PendingUpdate
	42,  // 79: lnrpc.ChannelEventUpdate.fully_resolved_channel:type_name -> lnrpc.ChannelPoint
	42,  // 80: lnrpc.ChannelEventUpdate.channel_funding_timeout:type_name -> lnrpc.ChannelPoint
	16,  // 81: lnrpc.ChannelEventUpdate.type:type_name -> lnrpc.ChannelEventUpdate.UpdateType
	241, // 82: lnrpc.WalletBalanceResponse.account_balance:type_name -> lnrpc.WalletBalanceResponse.AccountBalanceEntry
	120, // 83: lnrpc.ChannelBalanceResponse.local_balance:type_name -> lnrpc.Amount
	120, // 84: lnrpc.ChannelBalanceResponse.remote_balance:type_name -> lnrpc.Amount
	120, // 85: lnrpc.ChannelBalanceResponse.unsettled_local_balance:type_name -> lnrpc.Amount
	120, // 86: lnrpc.ChannelBalanceResponse.unsettled_remote_balance:type_name -> lnrpc.Amount
	120, // 87: lnrpc.ChannelBalanceResponse.pending_open_local_balance:type_name -> lnrpc.Amount
	120, // 88: lnrpc.ChannelBalanceResponse.pending_open_remote_balance:type_name -> lnrpc.Amount
	36,  // 89: lnrpc.QueryRoutesRequest.fee_limit:type_name -> lnrpc.FeeLimit
	125, // 90: lnrpc.QueryRoutesRequest.ignored_edges:type_name -> lnrpc.EdgeLocator
	124, // 91: lnrpc.QueryRoutesRequest.ignored_pairs:type_name -> lnrpc.NodePair
	242, // 92: lnrpc.QueryRoutesRequest.dest_custom_records:type_name -> lnrpc.QueryRoutesRequest.DestCustomRecordsEntry
	155, // 93: lnrpc.QueryRoutesRequest.route_hints:type_name -> lnrpc.RouteHint
	156, // 94: lnrpc.QueryRoutesRequest.blinded_payment_paths:type_name -> lnrpc.BlindedPaymentPath
	10,  // 95: lnrpc.QueryRoutesRequest.dest_features:type_name -> lnrpc.FeatureBit
	130, // 96: lnrpc.QueryRoutesResponse.routes:type_name -> lnrpc.Route
	128, // 97: lnrpc.Hop.mpp_record:type_name -> lnrpc.MPPRecord
	129, // 98: lnrpc.Hop.amp_record:type_name -> lnrpc.AMPRecord
	243, // 99: lnrpc.Hop.custom_records:type_name -> lnrpc.Hop.CustomRecordsEntry
	127, // 100: lnrpc.Route.hops:type_name -> lnrpc.Hop
	133, // 101: lnrpc.NodeInfo.node:type_name -> lnrpc.LightningNode
	137, // 102: lnrpc.NodeInfo.channels:type_name -> lnrpc.ChannelEdge
	134, // 103: lnrpc.LightningNode.addresses:type_name -> lnrpc.NodeAddress
	244, // 104: lnrpc.LightningNode.features:type_name -> lnrpc.LightningNode.FeaturesEntry
	245, // 105: lnrpc.LightningNode.custom_records:type_name -> lnrpc.LightningNode.CustomRecordsEntry
	246, // 106: lnrpc.RoutingPolicy.custom_records:type_name -> lnrpc.RoutingPolicy.CustomRecordsEntry
	135, // 107: lnrpc.ChannelEdge.node1_policy:type_name -> lnrpc.RoutingPolicy
	135, // 108: lnrpc.ChannelEdge.node2_policy:type_name -> lnrpc.RoutingPolicy
	247, // 109: lnrpc.ChannelEdge.custom_records:type_name -> lnrpc.ChannelEdge.CustomRecordsEntry
	136, // 110: lnrpc.ChannelEdge.auth_proof:type_name -> lnrpc.ChannelAuthProof
	133, // 111: lnrpc.ChannelGraph.nodes:type_name -> lnrpc.LightningNode
	137, // 112: lnrpc.ChannelGraph.edges:type_name -> lnrpc.ChannelEdge
	7,   // 113: lnrpc.NodeMetricsRequest.types:type_name -> lnrpc.NodeMetricType
	248, // 114: lnrpc.NodeMetricsResponse.betweenness_centrality:type_name -> lnrpc.NodeMetricsResponse.BetweennessCentralityEntry
	150, // 115: lnrpc.GraphTopologyUpdate.node_updates:type_name -> lnrpc.NodeUpdate
	151, // 116: lnrpc.GraphTopologyUpdate.channel_updates:type_name -> lnrpc.ChannelEdgeUpdate
	152, // 117: lnrpc.GraphTopologyUpdate.closed_chans:type_name -> lnrpc.ClosedChannelUpdate
	134, // 118: lnrpc.NodeUpdate.node_addresses:type_name -> lnrpc.NodeAddress
	249, // 119: lnrpc.NodeUpdate.features:type_name -> lnrpc.NodeUpdate.FeaturesEntry
	42,  // 120: lnrpc.ChannelEdgeUpdate.chan_point:type_name -> lnrpc.ChannelPoint
	135, // 121: lnrpc.ChannelEdgeUpdate.routing_policy:type_name -> lnrpc.RoutingPolicy
	42,  // 122: lnrpc.ClosedChannelUpdate.chan_point:type_name -> lnrpc.ChannelPoint
	153, // 123: lnrpc.RouteHint.hop_hints:type_name -> lnrpc.HopHint
	157, // 124: lnrpc.BlindedPaymentPath.blinded_path:type_name -> lnrpc.BlindedPath
	10,  // 125: lnrpc.BlindedPaymentPath.features:type_name -> lnrpc.FeatureBit
	158, // 126: lnrpc.BlindedPath.blinded_hops:type_name -> lnrpc.BlindedHop
	8,   // 127: lnrpc.AMPInvoiceState.state:type_name -> lnrpc.InvoiceHTLCState
	155, // 128: lnrpc.Invoice.route_hints:type_name -> lnrpc.RouteHint
	17,  // 129: lnrpc.Invoice.state:type_name -> lnrpc.Invoice.InvoiceState
	162, // 130: lnrpc.Invoice.htlcs:type_name -> lnrpc.InvoiceHTLC
	250, // 131: lnrpc.Invoice.features:type_name -> lnrpc.Invoice.FeaturesEntry
	251, // 132: lnrpc.Invoice.amp_invoice_state:type_name -> lnrpc.Invoice.AmpInvoiceStateEntry
	161, // 133: lnrpc.Invoice.blinded_path_config:type_name -> lnrpc.BlindedPathConfig
	8,   // 134: lnrpc.InvoiceHTLC.state:type_name -> lnrpc.InvoiceHTLCState
	252, // 135: lnrpc.InvoiceHTLC.custom_records:type_name -> lnrpc.InvoiceHTLC.CustomRecordsEntry
	163, // 136: lnrpc.InvoiceHTLC.amp:type_name -> lnrpc.AMP
	160, // 137: lnrpc.ListInvoiceResponse.invoices:type_name -> lnrpc.Invoice
	18,  // 138: lnrpc.Payment.status:type_name -> lnrpc.Payment.PaymentStatus
	172, // 139: lnrpc.Payment.htlcs:type_name -> lnrpc.HTLCAttempt
	9,   // 140: lnrpc.Payment.failure_reason:type_name -> lnrpc.PaymentFailureReason
	253, // 141: lnrpc.Payment.first_hop_custom_records:type_name -> lnrpc.Payment.FirstHopCustomRecordsEntry
	19,  // 142: lnrpc.HTLCAttempt.status:type_name -> lnrpc.HTLCAttempt.HTLCStatus
	130, // 143: lnrpc.HTLCAttempt.route:type_name -> lnrpc.Route
	216, // 144: lnrpc.HTLCAttempt.failure:type_name -> lnrpc.Failure
	171, // 145: lnrpc.ListPaymentsResponse.payments:type_name -> lnrpc.Payment
	42,  // 146: lnrpc.AbandonChannelRequest.channel_point:type_name -> lnrpc.ChannelPoint
	155, // 147: lnrpc.PayReq.route_hints:type_name -> lnrpc.RouteHint
	254, // 148: lnrpc.PayReq.features:type_name -> lnrpc.PayReq.FeaturesEntry
	156, // 149: lnrpc.PayReq.blinded_paths:type_name -> lnrpc.BlindedPaymentPath
	187, // 150: lnrpc.FeeReportResponse.channel_fees:type_name -> lnrpc.ChannelFeeReport
	42,  // 151: lnrpc.PolicyUpdateRequest.chan_point:type_name -> lnrpc.ChannelPoint
	189, // 152: lnrpc.PolicyUpdateRequest.inbound_fee:type_name -> lnrpc.InboundFee
	43,  // 153: lnrpc.FailedUpdate.outpoint:type_name -> lnrpc.OutPoint
	11,  // 154: lnrpc.FailedUpdate.reason:type_name -> lnrpc.UpdateFailure
	191, // 155: lnrpc.PolicyUpdateResponse.failed_updates:type_name -> lnrpc.FailedUpdate
	194, // 156: lnrpc.ForwardingHistoryResponse.forwarding_events:type_name -> lnrpc.ForwardingEvent
	42,  // 157: lnrpc.ExportChannelBackupRequest.chan_point:type_name -> lnrpc.ChannelPoint
	42,  // 158: lnrpc.ChannelBackup.chan_point:type_name -> lnrpc.ChannelPoint
	42,  // 159: lnrpc.MultiChanBackup.chan_points:type_name -> lnrpc.ChannelPoint
	201, // 160: lnrpc.ChanBackupSnapshot.single_chan_backups:type_name -> lnrpc.ChannelBackups
	198, // 161: lnrpc.ChanBackupSnapshot.multi_chan_backup:type_name -> lnrpc.MultiChanBackup
	197, // 162: lnrpc.ChannelBackups.chan_backups:type_name -> lnrpc.ChannelBackup
	201, // 163: lnrpc.RestoreChanBackupRequest.chan_backups:type_name -> lnrpc.ChannelBackups
	206, // 164: lnrpc.BakeMacaroonRequest.permissions:type_name -> lnrpc.MacaroonPermission
	206, // 165: lnrpc.MacaroonPermissionList.permissions:type_name -> lnrpc.MacaroonPermission
	255, // 166: lnrpc.ListPermissionsResponse.method_permissions:type_name -> lnrpc.ListPermissionsResponse.MethodPermissionsEntry
	20,  // 167: lnrpc.Failure.code:type_name -> lnrpc.Failure.FailureCode
	217, // 168: lnrpc.Failure.channel_update:type_name -> lnrpc.ChannelUpdate
	219, // 169: lnrpc.MacaroonId.ops:type_name -> lnrpc.Op
	206, // 170: lnrpc.CheckMacPermRequest.permissions:type_name -> lnrpc.MacaroonPermission
	224, // 171: lnrpc.RPCMiddlewareRequest.stream_auth:type_name -> lnrpc.StreamAuth
	225, // 172: lnrpc.RPCMiddlewareRequest.request:type_name -> lnrpc.RPCMessage
	225, // 173: lnrpc.RPCMiddlewareRequest.response:type_name -> lnrpc.RPCMessage
	256, // 174: lnrpc.RPCMiddlewareRequest.metadata_pairs:type_name -> lnrpc.RPCMiddlewareRequest.MetadataPairsEntry
	227, // 175: lnrpc.RPCMiddlewareResponse.register:type_name -> lnrpc.MiddlewareRegistration
	228, // 176: lnrpc.RPCMiddlewareResponse.feedback:type_name -> lnrpc.InterceptFeedback
	185, // 177: lnrpc.Peer.FeaturesEntry.value:type_name -> lnrpc.Feature
	185, // 178: lnrpc.GetInfoResponse.FeaturesEntry.value:type_name -> lnrpc.Feature
	4,   // 179: lnrpc.PendingChannelsResponse.PendingChannel.initiator:type_name -> lnrpc.Initiator
	3,   // 180: lnrpc.PendingChannelsResponse.PendingChannel.commitment_type:type_name -> lnrpc.CommitmentType
	235, // 181: lnrpc.PendingChannelsResponse.PendingOpenChannel.channel:type_name -> lnrpc.PendingChannelsResponse.PendingChannel
	235, // 182: lnrpc.PendingChannelsResponse.WaitingCloseChannel.channel:type_name -> lnrpc.PendingChannelsResponse.PendingChannel
	238, // 183: lnrpc.PendingChannelsResponse.WaitingCloseChannel.commitments:type_name -> lnrpc.PendingChannelsResponse.Commitments
	235, // 184: lnrpc.PendingChannelsResponse.ClosedChannel.channel:type_name -> lnrpc.PendingChannelsResponse.PendingChannel
	235, // 185: lnrpc.PendingChannelsResponse.ForceClosedChannel.channel:type_name -> lnrpc.PendingChannelsResponse.PendingChannel
	112, // 186: lnrpc.PendingChannelsResponse.ForceClosedChannel.pending_htlcs:type_name -> lnrpc.PendingHTLC
	15,  // 187: lnrpc.PendingChannelsResponse.ForceClosedChannel.anchor:type_name -> lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState
	117, // 188: lnrpc.WalletBalanceResponse.AccountBalanceEntry.value:type_name -> lnrpc.WalletAccountBalance
	185, // 189: lnrpc.LightningNode.FeaturesEntry.value:type_name -> lnrpc.Feature
	142, // 190: lnrpc.NodeMetricsResponse.BetweennessCentralityEntry.value:type_name -> lnrpc.FloatMetric
	185, // 191: lnrpc.NodeUpdate.FeaturesEntry.value:type_name -> lnrpc.Feature
	185, // 192: lnrpc.Invoice.FeaturesEntry.value:type_name -> lnrpc.Feature
	159, // 193: lnrpc.Invoice.AmpInvoiceStateEntry.value:type_name -> lnrpc.AMPInvoiceState
	185, // 194: lnrpc.PayReq.FeaturesEntry.value:type_name -> lnrpc.Feature
	213, // 195: lnrpc.ListPermissionsResponse.MethodPermissionsEntry.value:type_name -> lnrpc.MacaroonPermissionList
	223, // 196: lnrpc.RPCMiddlewareRequest.MetadataPairsEntry.value:type_name -> lnrpc.MetadataValues
	118, // 197: lnrpc.Lightning.WalletBalance:input_type -> lnrpc.WalletBalanceRequest
	121, // 198: lnrpc.Lightning.ChannelBalance:input_type -> lnrpc.ChannelBalanceRequest
	34,  // 199: lnrpc.Lightning.GetTransactions:input_type -> lnrpc.GetTransactionsRequest
	46,  // 200: lnrpc.Lightning.EstimateFee:input_type -> lnrpc.EstimateFeeRequest
	50,  // 201: lnrpc.Lightning.SendCoins:input_type -> lnrpc.SendCoinsRequest
	52,  // 202: lnrpc.Lightning.ListUnspent:input_type -> lnrpc.ListUnspentRequest
	34,  // 203: lnrpc.Lightning.SubscribeTransactions:input_type -> lnrpc.GetTransactionsRequest
	48,  // 204: lnrpc.Lightning.SendMany:input_type -> lnrpc.SendManyRequest
	54,  // 205: lnrpc.Lightning.NewAddress:input_type -> lnrpc.NewAddressRequest
	56,  // 206: lnrpc.Lightning.SignMessage:input_type -> lnrpc.SignMessageRequest
	58,  // 207: lnrpc.Lightning.VerifyMessage:input_type -> lnrpc.VerifyMessageRequest
	60,  // 208: lnrpc.Lightning.ConnectPeer:input_type -> lnrpc.ConnectPeerRequest
	62,  // 209: lnrpc.Lightning.DisconnectPeer:input_type -> lnrpc.DisconnectPeerRequest
	78,  // 210: lnrpc.Lightning.ListPeers:input_type -> lnrpc.ListPeersRequest
	80,  // 211: lnrpc.Lightning.SubscribePeerEvents:input_type -> lnrpc.PeerEventSubscription
	82,  // 212: lnrpc.Lightning.GetInfo:input_type -> lnrpc.GetInfoRequest
	84,  // 213: lnrpc.Lightning.GetDebugInfo:input_type -> lnrpc.GetDebugInfoRequest
	86,  // 214: lnrpc.Lightning.GetRecoveryInfo:input_type -> lnrpc.GetRecoveryInfoRequest
	113, // 215: lnrpc.Lightning.PendingChannels:input_type -> lnrpc.PendingChannelsRequest
	67,  // 216: lnrpc.Lightning.ListChannels:input_type -> lnrpc.ListChannelsRequest
	115, // 217: lnrpc.Lightning.SubscribeChannelEvents:input_type -> lnrpc.ChannelEventSubscription
	74,  // 218: lnrpc.Lightning.ClosedChannels:input_type -> lnrpc.ClosedChannelsRequest
	100, // 219: lnrpc.Lightning.OpenChannelSync:input_type -> lnrpc.OpenChannelRequest
	100, // 220: lnrpc.Lightning.OpenChannel:input_type -> lnrpc.OpenChannelRequest
	97,  // 221: lnrpc.Lightning.BatchOpenChannel:input_type -> lnrpc.BatchOpenChannelRequest
	110, // 222: lnrpc.Lightning.FundingStateStep:input_type -> lnrpc.FundingTransitionMsg
	41,  // 223: lnrpc.Lightning.ChannelAcceptor:input_type -> lnrpc.ChannelAcceptResponse
	92,  // 224: lnrpc.Lightning.CloseChannel:input_type -> lnrpc.CloseChannelRequest
	179, // 225: lnrpc.Lightning.AbandonChannel:input_type -> lnrpc.AbandonChannelRequest
	37,  // 226: lnrpc.Lightning.SendPayment:input_type -> lnrpc.SendRequest
	37,  // 227: lnrpc.Lightning.SendPaymentSync:input_type -> lnrpc.SendRequest
	39,  // 228: lnrpc.Lightning.SendToRoute:input_type -> lnrpc.SendToRouteRequest
	39,  // 229: lnrpc.Lightning.SendToRouteSync:input_type -> lnrpc.SendToRouteRequest
	160, // 230: lnrpc.Lightning.AddInvoice:input_type -> lnrpc.Invoice
	166, // 231: lnrpc.Lightning.ListInvoices:input_type -> lnrpc.ListInvoiceRequest
	165, // 232: lnrpc.Lightning.LookupInvoice:input_type -> lnrpc.PaymentHash
	168, // 233: lnrpc.Lightning.SubscribeInvoices:input_type -> lnrpc.InvoiceSubscription
	169, // 234: lnrpc.Lightning.DeleteCanceledInvoice:input_type -> lnrpc.DelCanceledInvoiceReq
	183, // 235: lnrpc.Lightning.DecodePayReq:input_type -> lnrpc.PayReqString
	173, // 236: lnrpc.Lightning.ListPayments:input_type -> lnrpc.ListPaymentsRequest
	175, // 237: lnrpc.Lightning.DeletePayment:input_type -> lnrpc.DeletePaymentRequest
	176, // 238: lnrpc.Lightning.DeleteAllPayments:input_type -> lnrpc.DeleteAllPaymentsRequest
	138, // 239: lnrpc.Lightning.DescribeGraph:input_type -> lnrpc.ChannelGraphRequest
	140, // 240: lnrpc.Lightning.GetNodeMetrics:input_type -> lnrpc.NodeMetricsRequest
	143, // 241: lnrpc.Lightning.GetChanInfo:input_type -> lnrpc.ChanInfoRequest
	131, // 242: lnrpc.Lightning.GetNodeInfo:input_type -> lnrpc.NodeInfoRequest
	123, // 243: lnrpc.Lightning.QueryRoutes:input_type -> lnrpc.QueryRoutesRequest
	144, // 244: lnrpc.Lightning.GetNetworkInfo:input_type -> lnrpc.NetworkInfoRequest
	146, // 245: lnrpc.Lightning.StopDaemon:input_type -> lnrpc.StopRequest
	148, // 246: lnrpc.Lightning.SubscribeChannelGraph:input_type -> lnrpc.GraphTopologySubscription
	181, // 247: lnrpc.Lightning.DebugLevel:input_type -> lnrpc.DebugLevelRequest
	186, // 248: lnrpc.Lightning.FeeReport:input_type -> lnrpc.FeeReportRequest
	190, // 249: lnrpc.Lightning.UpdateChannelPolicy:input_type -> lnrpc.PolicyUpdateRequest
	193, // 250: lnrpc.Lightning.ForwardingHistory:input_type -> lnrpc.ForwardingHistoryRequest
	196, // 251: lnrpc.Lightning.ExportChannelBackup:input_type -> lnrpc.ExportChannelBackupRequest
	199, // 252: lnrpc.Lightning.ExportAllChannelBackups:input_type -> lnrpc.ChanBackupExportRequest
	200, // 253: lnrpc.Lightning.VerifyChanBackup:input_type -> lnrpc.ChanBackupSnapshot
	202, // 254: lnrpc.Lightning.RestoreChannelBackups:input_type -> lnrpc.RestoreChanBackupRequest
	204, // 255: lnrpc.Lightning.SubscribeChannelBackups:input_type -> lnrpc.ChannelBackupSubscription
	207, // 256: lnrpc.Lightning.BakeMacaroon:input_type -> lnrpc.BakeMacaroonRequest
	209, // 257: lnrpc.Lightning.ListMacaroonIDs:input_type -> lnrpc.ListMacaroonIDsRequest
	211, // 258: lnrpc.Lightning.DeleteMacaroonID:input_type -> lnrpc.DeleteMacaroonIDRequest
	214, // 259: lnrpc.Lightning.ListPermissions:input_type -> lnrpc.ListPermissionsRequest
	220, // 260: lnrpc.Lightning.CheckMacaroonPermissions:input_type -> lnrpc.CheckMacPermRequest
	226, // 261: lnrpc.Lightning.RegisterRPCMiddleware:input_type -> lnrpc.RPCMiddlewareResponse
	25,  // 262: lnrpc.Lightning.SendCustomMessage:input_type -> lnrpc.SendCustomMessageRequest
	23,  // 263: lnrpc.Lightning.SubscribeCustomMessages:input_type -> lnrpc.SubscribeCustomMessagesRequest
	29,  // 264: lnrpc.Lightning.SendOnionMessage:input_type -> lnrpc.SendOnionMessageRequest
	27,  // 265: lnrpc.Lightning.SubscribeOnionMessages:input_type -> lnrpc.SubscribeOnionMessagesRequest
	70,  // 266: lnrpc.Lightning.ListAliases:input_type -> lnrpc.ListAliasesRequest
	21,  // 267: lnrpc.Lightning.LookupHtlcResolution:input_type -> lnrpc.LookupHtlcResolutionRequest
	119, // 268: lnrpc.Lightning.WalletBalance:output_type -> lnrpc.WalletBalanceResponse
	122, // 269: lnrpc.Lightning.ChannelBalance:output_type -> lnrpc.ChannelBalanceResponse
	35,  // 270: lnrpc.Lightning.GetTransactions:output_type -> lnrpc.TransactionDetails
	47,  // 271: lnrpc.Lightning.EstimateFee:output_type -> lnrpc.EstimateFeeResponse
	51,  // 272: lnrpc.Lightning.SendCoins:output_type -> lnrpc.SendCoinsResponse
	53,  // 273: lnrpc.Lightning.ListUnspent:output_type -> lnrpc.ListUnspentResponse
	33,  // 274: lnrpc.Lightning.SubscribeTransactions:output_type -> lnrpc.Transaction
	49,  // 275: lnrpc.Lightning.SendMany:output_type -> lnrpc.SendManyResponse
	55,  // 276: lnrpc.Lightning.NewAddress:output_type -> lnrpc.NewAddressResponse
	57,  // 277: lnrpc.Lightning.SignMessage:output_type -> lnrpc.SignMessageResponse
	59,  // 278: lnrpc.Lightning.VerifyMessage:output_type -> lnrpc.VerifyMessageResponse
	61,  // 279: lnrpc.Lightning.ConnectPeer:output_type -> lnrpc.ConnectPeerResponse
	63,  // 280: lnrpc.Lightning.DisconnectPeer:output_type -> lnrpc.DisconnectPeerResponse
	79,  // 281: lnrpc.Lightning.ListPeers:output_type -> lnrpc.ListPeersResponse
	81,  // 282: lnrpc.Lightning.SubscribePeerEvents:output_type -> lnrpc.PeerEvent
	83,  // 283: lnrpc.Lightning.GetInfo:output_type -> lnrpc.GetInfoResponse
	85,  // 284: lnrpc.Lightning.GetDebugInfo:output_type -> lnrpc.GetDebugInfoResponse
	87,  // 285: lnrpc.Lightning.GetRecoveryInfo:output_type -> lnrpc.GetRecoveryInfoResponse
	114, // 286: lnrpc.Lightning.PendingChannels:output_type -> lnrpc.PendingChannelsResponse
	68,  // 287: lnrpc.Lightning.ListChannels:output_type -> lnrpc.ListChannelsResponse
	116, // 288: lnrpc.Lightning.SubscribeChannelEvents:output_type -> lnrpc.ChannelEventUpdate
	75,  // 289: lnrpc.Lightning.ClosedChannels:output_type -> lnrpc.ClosedChannelsResponse
	42,  // 290: lnrpc.Lightning.OpenChannelSync:output_type -> lnrpc.ChannelPoint
	101, // 291: lnrpc.Lightning.OpenChannel:output_type -> lnrpc.OpenStatusUpdate
	99,  // 292: lnrpc.Lightning.BatchOpenChannel:output_type -> lnrpc.BatchOpenChannelResponse
	111, // 293: lnrpc.Lightning.FundingStateStep:output_type -> lnrpc.FundingStateStepResp
	40,  // 294: lnrpc.Lightning.ChannelAcceptor:output_type -> lnrpc.ChannelAcceptRequest
	93,  // 295: lnrpc.Lightning.CloseChannel:output_type -> lnrpc.CloseStatusUpdate
	180, // 296: lnrpc.Lightning.AbandonChannel:output_type -> lnrpc.AbandonChannelResponse
	38,  // 297: lnrpc.Lightning.SendPayment:output_type -> lnrpc.SendResponse
	38,  // 298: lnrpc.Lightning.SendPaymentSync:output_type -> lnrpc.SendResponse
	38,  // 299: lnrpc.Lightning.SendToRoute:output_type -> lnrpc.SendResponse
	38,  // 300: lnrpc.Lightning.SendToRouteSync:output_type -> lnrpc.SendResponse
	164, // 301: lnrpc.Lightning.AddInvoice:output_type -> lnrpc.AddInvoiceResponse
	167, // 302: lnrpc.Lightning.ListInvoices:output_type -> lnrpc.ListInvoiceResponse
	160, // 303: lnrpc.Lightning.LookupInvoice:output_type -> lnrpc.Invoice
	160, // 304: lnrpc.Lightning.SubscribeInvoices:output_type -> lnrpc.Invoice
	170, // 305: lnrpc.Lightning.DeleteCanceledInvoice:output_type -> lnrpc.DelCanceledInvoiceResp
	184, // 306: lnrpc.Lightning.DecodePayReq:output_type -> lnrpc.PayReq
	174, // 307: lnrpc.Lightning.ListPayments:output_type -> lnrpc.ListPaymentsResponse
	177, // 308: lnrpc.Lightning.DeletePayment:output_type -> lnrpc.DeletePaymentResponse
	178, // 309: lnrpc.Lightning.DeleteAllPayments:output_type -> lnrpc.DeleteAllPaymentsResponse
	139, // 310: lnrpc.Lightning.DescribeGraph:output_type -> lnrpc.ChannelGraph
	141, // 311: lnrpc.Lightning.GetNodeMetrics:output_type -> lnrpc.NodeMetricsResponse
	137, // 312: lnrpc.Lightning.GetChanInfo:output_type -> lnrpc.ChannelEdge
	132, // 313: lnrpc.Lightning.GetNodeInfo:output_type -> lnrpc.NodeInfo
	126, // 314: lnrpc.Lightning.QueryRoutes:output_type -> lnrpc.QueryRoutesResponse
	145, // 315: lnrpc.Lightning.GetNetworkInfo:output_type -> lnrpc.NetworkInfo
	147, // 316: lnrpc.Lightning.StopDaemon:output_type -> lnrpc.StopResponse
	149, // 317: lnrpc.Lightning.SubscribeChannelGraph:output_type -> lnrpc.GraphTopologyUpdate
	182, // 318: lnrpc.Lightning.DebugLevel:output_type -> lnrpc.DebugLevelResponse
	188, // 319: lnrpc.Lightning.FeeReport:output_type -> lnrpc.FeeReportResponse
	192, // 320: lnrpc.Lightning.UpdateChannelPolicy:output_type -> lnrpc.PolicyUpdateResponse
	195, // 321: lnrpc.Lightning.ForwardingHistory:output_type -> lnrpc.ForwardingHistoryResponse
	197, // 322: lnrpc.Lightning.ExportChannelBackup:output_type -> lnrpc.ChannelBackup
	200, // 323: lnrpc.Lightning.ExportAllChannelBackups:output_type -> lnrpc.ChanBackupSnapshot
	205, // 324: lnrpc.Lightning.VerifyChanBackup:output_type -> lnrpc.VerifyChanBackupResponse
	203, // 325: lnrpc.Lightning.RestoreChannelBackups:output_type -> lnrpc.RestoreBackupResponse
	200, // 326: lnrpc.Lightning.SubscribeChannelBackups:output_type -> lnrpc.ChanBackupSnapshot
	208, // 327: lnrpc.Lightning.BakeMacaroon:output_type -> lnrpc.BakeMacaroonResponse
	210, // 328: lnrpc.Lightning.ListMacaroonIDs:output_type -> lnrpc.ListMacaroonIDsResponse
	212, // 329: lnrpc.Lightning.DeleteMacaroonID:output_type -> lnrpc.DeleteMacaroonIDResponse
	215, // 330: lnrpc.Lightning.ListPermissions:output_type -> lnrpc.ListPermissionsResponse
	221, // 331: lnrpc.Lightning.CheckMacaroonPermissions:output_type -> lnrpc.CheckMacPermResponse
	222, // 332: lnrpc.Lightning.RegisterRPCMiddleware:output_type -> lnrpc.RPCMiddlewareRequest
	26,  // 333: lnrpc.Lightning.SendCustomMessage:output_type -> lnrpc.SendCustomMessageResponse
	24,  // 334: lnrpc.Lightning.SubscribeCustomMessages:output_type -> lnrpc.CustomMessage
	30,  // 335: lnrpc.Lightning.SendOnionMessage:output_type -> lnrpc.SendOnionMessageResponse
	28,  // 336: lnrpc.Lightning.SubscribeOnionMessages:output_type -> lnrpc.OnionMessage
	71,  // 337: lnrpc.Lightning.ListAliases:output_type -> lnrpc.ListAliasesResponse
	22,  // 338: lnrpc.Lightning.LookupHtlcResolution:output_type -> lnrpc.LookupHtlcResolutionResponse
	268, // [268:339] is the sub-list for method output_type
	197, // [197:268] is the sub-list for method input_type
	197, // [197:197] is the sub-list for extension type_name
	197, // [197:197] is the sub-list for extension extendee
	0,   // [0:197] is the sub-list for field type_name
}

func init() { file_lightning_proto_init() }
func file_lightning_proto_init() {
	if File_lightning_proto != nil {
		return
	}
	file_lightning_proto_msgTypes[15].OneofWrappers = []any{
		(*FeeLimit_Fixed)(nil),
		(*FeeLimit_FixedMsat)(nil),
		(*FeeLimit_Percent)(nil),
	}
	file_lightning_proto_msgTypes[21].OneofWrappers = []any{
		(*ChannelPoint_FundingTxidBytes)(nil),
		(*ChannelPoint_FundingTxidStr)(nil),
	}
	file_lightning_proto_msgTypes[72].OneofWrappers = []any{
		(*CloseStatusUpdate_ClosePending)(nil),
		(*CloseStatusUpdate_ChanClose)(nil),
		(*CloseStatusUpdate_CloseInstant)(nil),
	}
	file_lightning_proto_msgTypes[80].OneofWrappers = []any{
		(*OpenStatusUpdate_ChanPending)(nil),
		(*OpenStatusUpdate_ChanOpen)(nil),
		(*OpenStatusUpdate_PsbtFund)(nil),
	}
	file_lightning_proto_msgTypes[85].OneofWrappers = []any{
		(*FundingShim_ChanPointShim)(nil),
		(*FundingShim_PsbtShim)(nil),
	}
	file_lightning_proto_msgTypes[89].OneofWrappers = []any{
		(*FundingTransitionMsg_ShimRegister)(nil),
		(*FundingTransitionMsg_ShimCancel)(nil),
		(*FundingTransitionMsg_PsbtVerify)(nil),
		(*FundingTransitionMsg_PsbtFinalize)(nil),
	}
	file_lightning_proto_msgTypes[95].OneofWrappers = []any{
		(*ChannelEventUpdate_OpenChannel)(nil),
		(*ChannelEventUpdate_ClosedChannel)(nil),
		(*ChannelEventUpdate_ActiveChannel)(nil),
		(*ChannelEventUpdate_InactiveChannel)(nil),
		(*ChannelEventUpdate_PendingOpenChannel)(nil),
		(*ChannelEventUpdate_FullyResolvedChannel)(nil),
		(*ChannelEventUpdate_ChannelFundingTimeout)(nil),
	}
	file_lightning_proto_msgTypes[140].OneofWrappers = []any{}
	file_lightning_proto_msgTypes[169].OneofWrappers = []any{
		(*PolicyUpdateRequest_Global)(nil),
		(*PolicyUpdateRequest_ChanPoint)(nil),
	}
	file_lightning_proto_msgTypes[173].OneofWrappers = []any{}
	file_lightning_proto_msgTypes[181].OneofWrappers = []any{
		(*RestoreChanBackupRequest_ChanBackups)(nil),
		(*RestoreChanBackupRequest_MultiChanBackup)(nil),
	}
	file_lightning_proto_msgTypes[201].OneofWrappers = []any{
		(*RPCMiddlewareRequest_StreamAuth)(nil),
		(*RPCMiddlewareRequest_Request)(nil),
		(*RPCMiddlewareRequest_Response)(nil),
		(*RPCMiddlewareRequest_RegComplete)(nil),
	}
	file_lightning_proto_msgTypes[205].OneofWrappers = []any{
		(*RPCMiddlewareResponse_Register)(nil),
		(*RPCMiddlewareResponse_Feedback)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_lightning_proto_rawDesc), len(file_lightning_proto_rawDesc)),
			NumEnums:      21,
			NumMessages:   236,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_lightning_proto_goTypes,
		DependencyIndexes: file_lightning_proto_depIdxs,
		EnumInfos:         file_lightning_proto_enumTypes,
		MessageInfos:      file_lightning_proto_msgTypes,
	}.Build()
	File_lightning_proto = out.File
	file_lightning_proto_goTypes = nil
	file_lightning_proto_depIdxs = nil
}
