{
  "swagger": "2.0",
  "info": {
    "title": "routerrpc/router.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "Router"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/v2/router/htlcevents": {
      "get": {
        "summary": "SubscribeHtlcEvents creates a uni-directional stream from the server to\nthe client which delivers a stream of htlc events.",
        "operationId": "Router_SubscribeHtlcEvents",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/routerrpcHtlcEvent"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of routerrpcHtlcEvent"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "Router"
        ]
      }
    },
    "/v2/router/htlcinterceptor": {
      "post": {
        "summary": "*\nHtlcInterceptor dispatches a bi-directional streaming RPC in which\nForwarded HTLC requests are sent to the client and the client responds with\na boolean that tells LND if this htlc should be intercepted.\nIn case of interception, the htlc can be either settled, cancelled or\nresumed later by using the ResolveHoldForward endpoint.",
        "operationId": "Router_HtlcInterceptor",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/routerrpcForwardHtlcInterceptRequest"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of routerrpcForwardHtlcInterceptRequest"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "*\nForwardHtlcInterceptResponse enables the caller to resolve a previously hold\nforward. The caller can choose either to:\n- `Resume`: Execute the default behavior (usually forward).\n- `ResumeModified`: Execute the default behavior (usually forward) with HTLC\nfield modifications.\n- `Reject`: Fail the htlc backwards.\n- `Settle`: Settle this htlc with a given preimage. (streaming inputs)",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/routerrpcForwardHtlcInterceptResponse"
            }
          }
        ],
        "tags": [
          "Router"
        ]
      }
    },
    "/v2/router/mc": {
      "get": {
        "summary": "lncli: `querymc`\nQueryMissionControl exposes the internal mission control state to callers.\nIt is a development feature.",
        "operationId": "Router_QueryMissionControl",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/routerrpcQueryMissionControlResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "Router"
        ]
      }
    },
    "/v2/router/mc/probability/{from_node}/{to_node}/{amt_msat}": {
      "get": {
        "summary": "lncli: `queryprob`\nDeprecated. QueryProbability returns the current success probability\nestimate for a given node pair and amount. The call returns a zero success\nprobability if no channel is available or if the amount violates min/max\nHTLC constraints.",
        "operationId": "Router_QueryProbability",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/routerrpcQueryProbabilityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "from_node",
            "description": "The source node pubkey of the pair.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "to_node",
            "description": "The destination node pubkey of the pair.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "amt_msat",
            "description": "The amount for which to calculate a probability.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Router"
        ]
      }
    },
    "/v2/router/mc/reset": {
      "post": {
        "summary": "lncli: `resetmc`\nResetMissionControl clears all mission control state and starts with a clean\nslate.",
        "operationId": "Router_ResetMissionControl",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/routerrpcResetMissionControlResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/routerrpcResetMissionControlRequest"
            }
          }
        ],
        "tags": [
          "Router"
        ]
      }
    },
    "/v2/router/mccfg": {
      "get": {
        "summary": "lncli: `getmccfg`\nGetMissionControlConfig returns mission control's current config.",
        "operationId": "Router_GetMissionControlConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/routerrpcGetMissionControlConfigResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "Router"
        ]
      },
      "post": {
        "summary": "lncli: `setmccfg`\nSetMissionControlConfig will set mission control's config, if the config\nprovided is valid.",
        "operationId": "Router_SetMissionControlConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/routerrpcSetMissionControlConfigResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/routerrpcSetMissionControlConfigRequest"
            }
          }
        ],
        "tags": [
          "Router"
        ]
      }
    },
    "/v2/router/payments": {
      "get": {
        "summary": "TrackPayments returns an update stream for every payment that is not in a\nterminal state. Note that if payments are in-flight while starting a new\nsubscription, the start of the payment stream could produce out-of-order\nand/or duplicate events. In order to get updates for every in-flight\npayment attempt make sure to subscribe to this method before initiating any\npayments.",
        "operationId": "Router_TrackPayments",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/lnrpcPayment"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of lnrpcPayment"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "no_inflight_updates",
            "description": "If set, only the final payment updates are streamed back. Intermediate\nupdates that show which htlcs are still in flight are suppressed.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Router"
        ]
      }
    },
    "/v2/router/route": {
      "post": {
        "summary": "lncli: `buildroute`\nBuildRoute builds a fully specified route based on a list of hop public\nkeys. It retrieves the relevant channel policies from the graph in order to\ncalculate the correct fees and time locks.\nNote that LND will use its default final_cltv_delta if no value is supplied.\nMake sure to add the correct final_cltv_delta depending on the invoice\nrestriction. Moreover the caller has to make sure to provide the\npayment_addr if the route is paying an invoice which signaled it.",
        "operationId": "Router_BuildRoute",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/routerrpcBuildRouteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/routerrpcBuildRouteRequest"
            }
          }
        ],
        "tags": [
          "Router"
        ]
      }
    },
    "/v2/router/route/estimatefee": {
      "post": {
        "summary": "EstimateRouteFee allows callers to obtain a lower bound w.r.t how much it\nmay cost to send an HTLC to the target end destination.",
        "operationId": "Router_EstimateRouteFee",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/routerrpcRouteFeeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/routerrpcRouteFeeRequest"
            }
          }
        ],
        "tags": [
          "Router"
        ]
      }
    },
    "/v2/router/route/send": {
      "post": {
        "summary": "SendToRouteV2 attempts to make a payment via the specified route. This\nmethod differs from SendPayment in that it allows users to specify a full\nroute manually. This can be used for things like rebalancing, and atomic\nswaps.",
        "operationId": "Router_SendToRouteV2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/lnrpcHTLCAttempt"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/routerrpcSendToRouteRequest"
            }
          }
        ],
        "tags": [
          "Router"
        ]
      }
    },
    "/v2/router/send": {
      "post": {
        "summary": "SendPaymentV2 attempts to route a payment described by the passed\nPaymentRequest to the final destination. The call returns a stream of\npayment updates. When using this RPC, make sure to set a fee limit, as the\ndefault routing fee limit is 0 sats. Without a non-zero fee limit only\nroutes without fees will be attempted which often fails with\nFAILURE_REASON_NO_ROUTE.",
        "operationId": "Router_SendPaymentV2",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/lnrpcPayment"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of lnrpcPayment"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/routerrpcSendPaymentRequest"
            }
          }
        ],
        "tags": [
          "Router"
        ]
      }
    },
    "/v2/router/track/{payment_hash}": {
      "get": {
        "summary": "lncli: `trackpayment`\nTrackPaymentV2 returns an update stream for the payment identified by the\npayment hash.",
        "operationId": "Router_TrackPaymentV2",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/lnrpcPayment"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of lnrpcPayment"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "payment_hash",
            "description": "The hash of the payment to look up.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "no_inflight_updates",
            "description": "If set, only the final payment update is streamed back. Intermediate updates\nthat show which htlcs are still in flight are suppressed.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Router"
        ]
      }
    },
    "/v2/router/updatechanstatus": {
      "post": {
        "summary": "lncli: `updatechanstatus`\nUpdateChanStatus attempts to manually set the state of a channel\n(enabled, disabled, or auto). A manual \"disable\" request will cause the\nchannel to stay disabled until a subsequent manual request of either\n\"enable\" or \"auto\".",
        "operationId": "Router_UpdateChanStatus",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/routerrpcUpdateChanStatusResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/routerrpcUpdateChanStatusRequest"
            }
          }
        ],
        "tags": [
          "Router"
        ]
      }
    },
    "/v2/router/x/addaliases": {
      "post": {
        "summary": "XAddLocalChanAliases is an experimental API that creates a set of new\nchannel SCID alias mappings. The final total set of aliases in the manager\nafter the add operation is returned. This is only a locally stored alias,\nand will not be communicated to the channel peer via any message. Therefore,\nrouting over such an alias will only work if the peer also calls this same\nRPC on their end. If an alias already exists, an error is returned",
        "operationId": "Router_XAddLocalChanAliases",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/routerrpcAddAliasesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/routerrpcAddAliasesRequest"
            }
          }
        ],
        "tags": [
          "Router"
        ]
      }
    },
    "/v2/router/x/deletealiases": {
      "post": {
        "summary": "XDeleteLocalChanAliases is an experimental API that deletes a set of alias\nmappings. The final total set of aliases in the manager after the delete\noperation is returned. The deletion will not be communicated to the channel\npeer via any message.",
        "operationId": "Router_XDeleteLocalChanAliases",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/routerrpcDeleteAliasesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/routerrpcDeleteAliasesRequest"
            }
          }
        ],
        "tags": [
          "Router"
        ]
      }
    },
    "/v2/router/x/findbasealias": {
      "post": {
        "summary": "XFindBaseLocalChanAlias is an experimental API that looks up the base scid\nfor a local chan alias that was registered during the current runtime.",
        "operationId": "Router_XFindBaseLocalChanAlias",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/routerrpcFindBaseAliasResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/routerrpcFindBaseAliasRequest"
            }
          }
        ],
        "tags": [
          "Router"
        ]
      }
    },
    "/v2/router/x/importhistory": {
      "post": {
        "summary": "lncli: `importmc`\nXImportMissionControl is an experimental API that imports the state provided\nto the internal mission control's state, using all results which are more\nrecent than our existing values. These values will only be imported\nin-memory, and will not be persisted across restarts.",
        "operationId": "Router_XImportMissionControl",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/routerrpcXImportMissionControlResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/routerrpcXImportMissionControlRequest"
            }
          }
        ],
        "tags": [
          "Router"
        ]
      }
    }
  },
  "definitions": {
    "FailureFailureCode": {
      "type": "string",
      "enum": [
        "RESERVED",
        "INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS",
        "INCORRECT_PAYMENT_AMOUNT",
        "FINAL_INCORRECT_CLTV_EXPIRY",
        "FINAL_INCORRECT_HTLC_AMOUNT",
        "FINAL_EXPIRY_TOO_SOON",
        "INVALID_REALM",
        "EXPIRY_TOO_SOON",
        "INVALID_ONION_VERSION",
        "INVALID_ONION_HMAC",
        "INVALID_ONION_KEY",
        "AMOUNT_BELOW_MINIMUM",
        "FEE_INSUFFICIENT",
        "INCORRECT_CLTV_EXPIRY",
        "CHANNEL_DISABLED",
        "TEMPORARY_CHANNEL_FAILURE",
        "REQUIRED_NODE_FEATURE_MISSING",
        "REQUIRED_CHANNEL_FEATURE_MISSING",
        "UNKNOWN_NEXT_PEER",
        "TEMPORARY_NODE_FAILURE",
        "PERMANENT_NODE_FAILURE",
        "PERMANENT_CHANNEL_FAILURE",
        "EXPIRY_TOO_FAR",
        "MPP_TIMEOUT",
        "INVALID_ONION_PAYLOAD",
        "INVALID_ONION_BLINDING",
        "INTERNAL_FAILURE",
        "UNKNOWN_FAILURE",
        "UNREADABLE_FAILURE"
      ],
      "default": "RESERVED",
      "description": " - RESERVED: The numbers assigned in this enumeration match the failure codes as\ndefined in BOLT #4. Because protobuf 3 requires enums to start with 0,\na RESERVED value is added.\n - INTERNAL_FAILURE: An internal error occurred.\n - UNKNOWN_FAILURE: The error source is known, but the failure itself couldn't be decoded.\n - UNREADABLE_FAILURE: An unreadable failure result is returned if the received failure message\ncannot be decrypted. In that case the error source is unknown."
    },
    "HTLCAttemptHTLCStatus": {
      "type": "string",
      "enum": [
        "IN_FLIGHT",
        "SUCCEEDED",
        "FAILED"
      ],
      "default": "IN_FLIGHT"
    },
    "MissionControlConfigProbabilityModel": {
      "type": "string",
      "enum": [
        "APRIORI",
        "BIMODAL"
      ],
      "default": "APRIORI"
    },
    "lnrpcAMPRecord": {
      "type": "object",
      "properties": {
        "root_share": {
          "type": "string",
          "format": "byte"
        },
        "set_id": {
          "type": "string",
          "format": "byte"
        },
        "child_index": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "lnrpcAliasMap": {
      "type": "object",
      "properties": {
        "base_scid": {
          "type": "string",
          "format": "uint64",
          "description": "For non-zero-conf channels, this is the confirmed SCID. Otherwise, this is\nthe first assigned \"base\" alias."
        },
        "aliases": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "description": "The set of all aliases stored for the base SCID."
        }
      }
    },
    "lnrpcChannelPoint": {
      "type": "object",
      "properties": {
        "funding_txid_bytes": {
          "type": "string",
          "format": "byte",
          "description": "Txid of the funding transaction. When using REST, this field must be\nencoded as base64."
        },
        "funding_txid_str": {
          "type": "string",
          "description": "Hex-encoded string representing the byte-reversed hash of the funding\ntransaction."
        },
        "output_index": {
          "type": "integer",
          "format": "int64",
          "title": "The index of the output of the funding transaction"
        }
      }
    },
    "lnrpcChannelUpdate": {
      "type": "object",
      "properties": {
        "signature": {
          "type": "string",
          "format": "byte",
          "description": "The signature that validates the announced data and proves the ownership\nof node id."
        },
        "chain_hash": {
          "type": "string",
          "format": "byte",
          "description": "The target chain that this channel was opened within. This value\nshould be the genesis hash of the target chain. Along with the short\nchannel ID, this uniquely identifies the channel globally in a\nblockchain."
        },
        "chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "The unique description of the funding transaction."
        },
        "timestamp": {
          "type": "integer",
          "format": "int64",
          "description": "A timestamp that allows ordering in the case of multiple announcements.\nWe should ignore the message if timestamp is not greater than the\nlast-received."
        },
        "message_flags": {
          "type": "integer",
          "format": "int64",
          "description": "The bitfield that describes whether optional fields are present in this\nupdate. Currently, the least-significant bit must be set to 1 if the\noptional field MaxHtlc is present."
        },
        "channel_flags": {
          "type": "integer",
          "format": "int64",
          "description": "The bitfield that describes additional meta-data concerning how the\nupdate is to be interpreted. Currently, the least-significant bit must be\nset to 0 if the creating node corresponds to the first node in the\npreviously sent channel announcement and 1 otherwise. If the second bit\nis set, then the channel is set to be disabled."
        },
        "time_lock_delta": {
          "type": "integer",
          "format": "int64",
          "description": "The minimum number of blocks this node requires to be added to the expiry\nof HTLCs. This is a security parameter determined by the node operator.\nThis value represents the required gap between the time locks of the\nincoming and outgoing HTLC's set to this node."
        },
        "htlc_minimum_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The minimum HTLC value which will be accepted."
        },
        "base_fee": {
          "type": "integer",
          "format": "int64",
          "description": "The base fee that must be used for incoming HTLC's to this particular\nchannel. This value will be tacked onto the required for a payment\nindependent of the size of the payment."
        },
        "fee_rate": {
          "type": "integer",
          "format": "int64",
          "description": "The fee rate that will be charged per millionth of a satoshi."
        },
        "htlc_maximum_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The maximum HTLC value which will be accepted."
        },
        "extra_opaque_data": {
          "type": "string",
          "format": "byte",
          "description": "The set of data that was appended to this message, some of which we may\nnot actually know how to iterate or parse. By holding onto this data, we\nensure that we're able to properly validate the set of signatures that\ncover these new fields, and ensure we're able to make upgrades to the\nnetwork in a forwards compatible manner."
        }
      }
    },
    "lnrpcFailure": {
      "type": "object",
      "properties": {
        "code": {
          "$ref": "#/definitions/FailureFailureCode",
          "title": "Failure code as defined in the Lightning spec"
        },
        "channel_update": {
          "$ref": "#/definitions/lnrpcChannelUpdate",
          "description": "An optional channel update message."
        },
        "htlc_msat": {
          "type": "string",
          "format": "uint64",
          "description": "A failure type-dependent htlc value."
        },
        "onion_sha_256": {
          "type": "string",
          "format": "byte",
          "description": "The sha256 sum of the onion payload."
        },
        "cltv_expiry": {
          "type": "integer",
          "format": "int64",
          "description": "A failure type-dependent cltv expiry value."
        },
        "flags": {
          "type": "integer",
          "format": "int64",
          "description": "A failure type-dependent flags value."
        },
        "failure_source_index": {
          "type": "integer",
          "format": "int64",
          "description": "The position in the path of the intermediate or final node that generated\nthe failure message. Position zero is the sender node."
        },
        "height": {
          "type": "integer",
          "format": "int64",
          "description": "A failure type-dependent block height."
        }
      }
    },
    "lnrpcFeatureBit": {
      "type": "string",
      "enum": [
        "DATALOSS_PROTECT_REQ",
        "DATALOSS_PROTECT_OPT",
        "INITIAL_ROUING_SYNC",
        "UPFRONT_SHUTDOWN_SCRIPT_REQ",
        "UPFRONT_SHUTDOWN_SCRIPT_OPT",
        "GOSSIP_QUERIES_REQ",
        "GOSSIP_QUERIES_OPT",
        "TLV_ONION_REQ",
        "TLV_ONION_OPT",
        "EXT_GOSSIP_QUERIES_REQ",
        "EXT_GOSSIP_QUERIES_OPT",
        "STATIC_REMOTE_KEY_REQ",
        "STATIC_REMOTE_KEY_OPT",
        "PAYMENT_ADDR_REQ",
        "PAYMENT_ADDR_OPT",
        "MPP_REQ",
        "MPP_OPT",
        "WUMBO_CHANNELS_REQ",
        "WUMBO_CHANNELS_OPT",
        "ANCHORS_REQ",
        "ANCHORS_OPT",
        "ANCHORS_ZERO_FEE_HTLC_REQ",
        "ANCHORS_ZERO_FEE_HTLC_OPT",
        "ROUTE_BLINDING_REQUIRED",
        "ROUTE_BLINDING_OPTIONAL",
        "AMP_REQ",
        "AMP_OPT"
      ],
      "default": "DATALOSS_PROTECT_REQ"
    },
    "lnrpcHTLCAttempt": {
      "type": "object",
      "properties": {
        "attempt_id": {
          "type": "string",
          "format": "uint64",
          "description": "The unique ID that is used for this attempt."
        },
        "status": {
          "$ref": "#/definitions/HTLCAttemptHTLCStatus",
          "description": "The status of the HTLC."
        },
        "route": {
          "$ref": "#/definitions/lnrpcRoute",
          "description": "The route taken by this HTLC."
        },
        "attempt_time_ns": {
          "type": "string",
          "format": "int64",
          "description": "The time in UNIX nanoseconds at which this HTLC was sent."
        },
        "resolve_time_ns": {
          "type": "string",
          "format": "int64",
          "description": "The time in UNIX nanoseconds at which this HTLC was settled or failed.\nThis value will not be set if the HTLC is still IN_FLIGHT."
        },
        "failure": {
          "$ref": "#/definitions/lnrpcFailure",
          "description": "Detailed htlc failure info."
        },
        "preimage": {
          "type": "string",
          "format": "byte",
          "description": "The preimage that was used to settle the HTLC."
        }
      }
    },
    "lnrpcHop": {
      "type": "object",
      "properties": {
        "chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "The unique channel ID for the channel. The first 3 bytes are the block\nheight, the next 3 the index within the block, and the last 2 bytes are the\noutput index for the channel."
        },
        "chan_capacity": {
          "type": "string",
          "format": "int64"
        },
        "amt_to_forward": {
          "type": "string",
          "format": "int64"
        },
        "fee": {
          "type": "string",
          "format": "int64"
        },
        "expiry": {
          "type": "integer",
          "format": "int64"
        },
        "amt_to_forward_msat": {
          "type": "string",
          "format": "int64"
        },
        "fee_msat": {
          "type": "string",
          "format": "int64"
        },
        "pub_key": {
          "type": "string",
          "description": "An optional public key of the hop. If the public key is given, the payment\ncan be executed without relying on a copy of the channel graph."
        },
        "tlv_payload": {
          "type": "boolean",
          "description": "If set to true, then this hop will be encoded using the new variable length\nTLV format. Note that if any custom tlv_records below are specified, then\nthis field MUST be set to true for them to be encoded properly."
        },
        "mpp_record": {
          "$ref": "#/definitions/lnrpcMPPRecord",
          "description": "An optional TLV record that signals the use of an MPP payment. If present,\nthe receiver will enforce that the same mpp_record is included in the final\nhop payload of all non-zero payments in the HTLC set. If empty, a regular\nsingle-shot payment is or was attempted."
        },
        "amp_record": {
          "$ref": "#/definitions/lnrpcAMPRecord",
          "description": "An optional TLV record that signals the use of an AMP payment. If present,\nthe receiver will treat all received payments including the same\n(payment_addr, set_id) pair  as being part of one logical payment. The\npayment will be settled by XORing the root_share's together and deriving the\nchild hashes and preimages according to BOLT XX. Must be used in conjunction\nwith mpp_record."
        },
        "custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "An optional set of key-value TLV records. This is useful within the context\nof the SendToRoute call as it allows callers to specify arbitrary K-V pairs\nto drop off at each hop within the onion."
        },
        "metadata": {
          "type": "string",
          "format": "byte",
          "description": "The payment metadata to send along with the payment to the payee."
        },
        "blinding_point": {
          "type": "string",
          "format": "byte",
          "description": "Blinding point is an optional blinding point included for introduction\nnodes in blinded paths. This field is mandatory for hops that represents\nthe introduction point in a blinded path."
        },
        "encrypted_data": {
          "type": "string",
          "format": "byte",
          "description": "Encrypted data is a receiver-produced blob of data that provides hops\nin a blinded route with forwarding data. As this data is encrypted by\nthe recipient, we will not be able to parse it - it is essentially an\narbitrary blob of data from our node's perspective. This field is\nmandatory for all hops in a blinded path, including the introduction\nnode."
        },
        "total_amt_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The total amount that is sent to the recipient (possibly across multiple\nHTLCs), as specified by the sender when making a payment to a blinded path.\nThis value is only set in the final hop payload of a blinded payment. This\nvalue is analogous to the MPPRecord that is used for regular (non-blinded)\nMPP payments."
        }
      }
    },
    "lnrpcHopHint": {
      "type": "object",
      "properties": {
        "node_id": {
          "type": "string",
          "description": "The public key of the node at the start of the channel."
        },
        "chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "The unique identifier of the channel."
        },
        "fee_base_msat": {
          "type": "integer",
          "format": "int64",
          "description": "The base fee of the channel denominated in millisatoshis."
        },
        "fee_proportional_millionths": {
          "type": "integer",
          "format": "int64",
          "description": "The fee rate of the channel for sending one satoshi across it denominated in\nmillionths of a satoshi."
        },
        "cltv_expiry_delta": {
          "type": "integer",
          "format": "int64",
          "description": "The time-lock delta of the channel."
        }
      }
    },
    "lnrpcMPPRecord": {
      "type": "object",
      "properties": {
        "payment_addr": {
          "type": "string",
          "format": "byte",
          "description": "A unique, random identifier used to authenticate the sender as the intended\npayer of a multi-path payment. The payment_addr must be the same for all\nsubpayments, and match the payment_addr provided in the receiver's invoice.\nThe same payment_addr must be used on all subpayments. This is also called\npayment secret in specifications (e.g. BOLT 11)."
        },
        "total_amt_msat": {
          "type": "string",
          "format": "int64",
          "description": "The total amount in milli-satoshis being sent as part of a larger multi-path\npayment. The caller is responsible for ensuring subpayments to the same node\nand payment_hash sum exactly to total_amt_msat. The same\ntotal_amt_msat must be used on all subpayments."
        }
      }
    },
    "lnrpcPayment": {
      "type": "object",
      "properties": {
        "payment_hash": {
          "type": "string",
          "title": "The payment hash"
        },
        "value": {
          "type": "string",
          "format": "int64",
          "description": "Deprecated, use value_sat or value_msat."
        },
        "creation_date": {
          "type": "string",
          "format": "int64",
          "title": "Deprecated, use creation_time_ns"
        },
        "fee": {
          "type": "string",
          "format": "int64",
          "description": "Deprecated, use fee_sat or fee_msat."
        },
        "payment_preimage": {
          "type": "string",
          "title": "The payment preimage"
        },
        "value_sat": {
          "type": "string",
          "format": "int64",
          "title": "The value of the payment in satoshis"
        },
        "value_msat": {
          "type": "string",
          "format": "int64",
          "title": "The value of the payment in milli-satoshis"
        },
        "payment_request": {
          "type": "string",
          "description": "The optional payment request being fulfilled."
        },
        "status": {
          "$ref": "#/definitions/lnrpcPaymentPaymentStatus",
          "description": "The status of the payment."
        },
        "fee_sat": {
          "type": "string",
          "format": "int64",
          "title": "The fee paid for this payment in satoshis"
        },
        "fee_msat": {
          "type": "string",
          "format": "int64",
          "title": "The fee paid for this payment in milli-satoshis"
        },
        "creation_time_ns": {
          "type": "string",
          "format": "int64",
          "description": "The time in UNIX nanoseconds at which the payment was created."
        },
        "htlcs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcHTLCAttempt"
          },
          "description": "The HTLCs made in attempt to settle the payment."
        },
        "payment_index": {
          "type": "string",
          "format": "uint64",
          "description": "The creation index of this payment. Each payment can be uniquely identified\nby this index, which may not strictly increment by 1 for payments made in\nolder versions of lnd."
        },
        "failure_reason": {
          "$ref": "#/definitions/lnrpcPaymentFailureReason"
        },
        "first_hop_custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "The custom TLV records that were sent to the first hop as part of the HTLC\nwire message for this payment."
        }
      }
    },
    "lnrpcPaymentFailureReason": {
      "type": "string",
      "enum": [
        "FAILURE_REASON_NONE",
        "FAILURE_REASON_TIMEOUT",
        "FAILURE_REASON_NO_ROUTE",
        "FAILURE_REASON_ERROR",
        "FAILURE_REASON_INCORRECT_PAYMENT_DETAILS",
        "FAILURE_REASON_INSUFFICIENT_BALANCE",
        "FAILURE_REASON_CANCELED"
      ],
      "default": "FAILURE_REASON_NONE",
      "description": " - FAILURE_REASON_NONE: Payment isn't failed (yet).\n - FAILURE_REASON_TIMEOUT: There are more routes to try, but the payment timeout was exceeded.\n - FAILURE_REASON_NO_ROUTE: All possible routes were tried and failed permanently. Or were no\nroutes to the destination at all.\n - FAILURE_REASON_ERROR: A non-recoverable error has occured.\n - FAILURE_REASON_INCORRECT_PAYMENT_DETAILS: Payment details incorrect (unknown hash, invalid amt or\ninvalid final cltv delta)\n - FAILURE_REASON_INSUFFICIENT_BALANCE: Insufficient local balance.\n - FAILURE_REASON_CANCELED: The payment was canceled."
    },
    "lnrpcPaymentPaymentStatus": {
      "type": "string",
      "enum": [
        "UNKNOWN",
        "IN_FLIGHT",
        "SUCCEEDED",
        "FAILED",
        "INITIATED"
      ],
      "default": "UNKNOWN",
      "description": " - UNKNOWN: Deprecated. This status will never be returned.\n - IN_FLIGHT: Payment has inflight HTLCs.\n - SUCCEEDED: Payment is settled.\n - FAILED: Payment is failed.\n - INITIATED: Payment is created and has not attempted any HTLCs."
    },
    "lnrpcRoute": {
      "type": "object",
      "properties": {
        "total_time_lock": {
          "type": "integer",
          "format": "int64",
          "description": "The cumulative (final) time lock across the entire route. This is the CLTV\nvalue that should be extended to the first hop in the route. All other hops\nwill decrement the time-lock as advertised, leaving enough time for all\nhops to wait for or present the payment preimage to complete the payment."
        },
        "total_fees": {
          "type": "string",
          "format": "int64",
          "description": "The sum of the fees paid at each hop within the final route. In the case\nof a one-hop payment, this value will be zero as we don't need to pay a fee\nto ourselves."
        },
        "total_amt": {
          "type": "string",
          "format": "int64",
          "description": "The total amount of funds required to complete a payment over this route.\nThis value includes the cumulative fees at each hop. As a result, the HTLC\nextended to the first-hop in the route will need to have at least this many\nsatoshis, otherwise the route will fail at an intermediate node due to an\ninsufficient amount of fees."
        },
        "hops": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcHop"
          },
          "description": "Contains details concerning the specific forwarding details at each hop."
        },
        "total_fees_msat": {
          "type": "string",
          "format": "int64",
          "description": "The total fees in millisatoshis."
        },
        "total_amt_msat": {
          "type": "string",
          "format": "int64",
          "description": "The total amount in millisatoshis."
        },
        "first_hop_amount_msat": {
          "type": "string",
          "format": "int64",
          "description": "The actual on-chain amount that was sent out to the first hop. This value is\nonly different from the total_amt_msat field if this is a custom channel\npayment and the value transported in the HTLC is different from the BTC\namount in the HTLC. If this value is zero, then this is an old payment that\ndidn't have this value yet and can be ignored."
        },
        "custom_channel_data": {
          "type": "string",
          "format": "byte",
          "description": "Custom channel data that might be populated in custom channels."
        }
      },
      "description": "A path through the channel graph which runs over one or more channels in\nsuccession. This struct carries all the information required to craft the\nSphinx onion packet, and send the payment along the first hop in the path. A\nroute is only selected as valid if all the channels have sufficient capacity to\ncarry the initial payment amount after fees are accounted for."
    },
    "lnrpcRouteHint": {
      "type": "object",
      "properties": {
        "hop_hints": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcHopHint"
          },
          "description": "A list of hop hints that when chained together can assist in reaching a\nspecific destination."
        }
      }
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "additionalProperties": {}
    },
    "routerrpcAddAliasesRequest": {
      "type": "object",
      "properties": {
        "alias_maps": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcAliasMap"
          }
        }
      }
    },
    "routerrpcAddAliasesResponse": {
      "type": "object",
      "properties": {
        "alias_maps": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcAliasMap"
          }
        }
      }
    },
    "routerrpcAprioriParameters": {
      "type": "object",
      "properties": {
        "half_life_seconds": {
          "type": "string",
          "format": "uint64",
          "description": "The amount of time mission control will take to restore a penalized node\nor channel back to 50% success probability, expressed in seconds. Setting\nthis value to a higher value will penalize failures for longer, making\nmission control less likely to route through nodes and channels that we\nhave previously recorded failures for."
        },
        "hop_probability": {
          "type": "number",
          "format": "double",
          "description": "The probability of success mission control should assign to hop in a route\nwhere it has no other information available. Higher values will make mission\ncontrol more willing to try hops that we have no information about, lower\nvalues will discourage trying these hops."
        },
        "weight": {
          "type": "number",
          "format": "double",
          "description": "The importance that mission control should place on historical results,\nexpressed as a value in [0;1]. Setting this value to 1 will ignore all\nhistorical payments and just use the hop probability to assess the\nprobability of success for each hop. A zero value ignores hop probability\ncompletely and relies entirely on historical results, unless none are\navailable."
        },
        "capacity_fraction": {
          "type": "number",
          "format": "double",
          "description": "The fraction of a channel's capacity that we consider to have liquidity. For\namounts that come close to or exceed the fraction, an additional penalty is\napplied. A value of 1.0 disables the capacity factor. Allowed values are in\n[0.75, 1.0]."
        }
      }
    },
    "routerrpcBimodalParameters": {
      "type": "object",
      "properties": {
        "node_weight": {
          "type": "number",
          "format": "double",
          "description": "NodeWeight defines how strongly other previous forwardings on channels of a\nrouter should be taken into account when computing a channel's probability\nto route. The allowed values are in the range [0, 1], where a value of 0\nmeans that only direct information about a channel is taken into account."
        },
        "scale_msat": {
          "type": "string",
          "format": "uint64",
          "description": "ScaleMsat describes the scale over which channels statistically have some\nliquidity left. The value determines how quickly the bimodal distribution\ndrops off from the edges of a channel. A larger value (compared to typical\nchannel capacities) means that the drop off is slow and that channel\nbalances are distributed more uniformly. A small value leads to the\nassumption of very unbalanced channels."
        },
        "decay_time": {
          "type": "string",
          "format": "uint64",
          "description": "DecayTime describes the information decay of knowledge about previous\nsuccesses and failures in channels. The smaller the decay time, the quicker\nwe forget about past forwardings."
        }
      }
    },
    "routerrpcBuildRouteRequest": {
      "type": "object",
      "properties": {
        "amt_msat": {
          "type": "string",
          "format": "int64",
          "description": "The amount to send expressed in msat. If set to zero, the minimum routable\namount is used."
        },
        "final_cltv_delta": {
          "type": "integer",
          "format": "int32",
          "title": "CLTV delta from the current height that should be used for the timelock\nof the final hop"
        },
        "outgoing_chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "The channel id of the channel that must be taken to the first hop. If zero,\nany channel may be used."
        },
        "hop_pubkeys": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "description": "A list of hops that defines the route. This does not include the source hop\npubkey."
        },
        "payment_addr": {
          "type": "string",
          "format": "byte",
          "description": "An optional payment addr to be included within the last hop of the route.\nThis is also called payment secret in specifications (e.g. BOLT 11)."
        },
        "first_hop_custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "An optional field that can be used to pass an arbitrary set of TLV records\nto the first hop peer of this payment. This can be used to pass application\nspecific data during the payment attempt. Record types are required to be in\nthe custom range \u003e= 65536. When using REST, the values must be encoded as\nbase64."
        }
      }
    },
    "routerrpcBuildRouteResponse": {
      "type": "object",
      "properties": {
        "route": {
          "$ref": "#/definitions/lnrpcRoute",
          "description": "Fully specified route that can be used to execute the payment."
        }
      }
    },
    "routerrpcChanStatusAction": {
      "type": "string",
      "enum": [
        "ENABLE",
        "DISABLE",
        "AUTO"
      ],
      "default": "ENABLE"
    },
    "routerrpcCircuitKey": {
      "type": "object",
      "properties": {
        "chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "/ The id of the channel that the is part of this circuit."
        },
        "htlc_id": {
          "type": "string",
          "format": "uint64",
          "description": "/ The index of the incoming htlc in the incoming channel."
        }
      }
    },
    "routerrpcDeleteAliasesRequest": {
      "type": "object",
      "properties": {
        "alias_maps": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcAliasMap"
          }
        }
      }
    },
    "routerrpcDeleteAliasesResponse": {
      "type": "object",
      "properties": {
        "alias_maps": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcAliasMap"
          }
        }
      }
    },
    "routerrpcFailureDetail": {
      "type": "string",
      "enum": [
        "UNKNOWN",
        "NO_DETAIL",
        "ONION_DECODE",
        "LINK_NOT_ELIGIBLE",
        "ON_CHAIN_TIMEOUT",
        "HTLC_EXCEEDS_MAX",
        "INSUFFICIENT_BALANCE",
        "INCOMPLETE_FORWARD",
        "HTLC_ADD_FAILED",
        "FORWARDS_DISABLED",
        "INVOICE_CANCELED",
        "INVOICE_UNDERPAID",
        "INVOICE_EXPIRY_TOO_SOON",
        "INVOICE_NOT_OPEN",
        "MPP_INVOICE_TIMEOUT",
        "ADDRESS_MISMATCH",
        "SET_TOTAL_MISMATCH",
        "SET_TOTAL_TOO_LOW",
        "SET_OVERPAID",
        "UNKNOWN_INVOICE",
        "INVALID_KEYSEND",
        "MPP_IN_PROGRESS",
        "CIRCULAR_ROUTE"
      ],
      "default": "UNKNOWN"
    },
    "routerrpcFinalHtlcEvent": {
      "type": "object",
      "properties": {
        "settled": {
          "type": "boolean"
        },
        "offchain": {
          "type": "boolean"
        }
      }
    },
    "routerrpcFindBaseAliasRequest": {
      "type": "object",
      "properties": {
        "alias": {
          "type": "string",
          "format": "uint64",
          "description": "The alias we want to look up the base scid for."
        }
      }
    },
    "routerrpcFindBaseAliasResponse": {
      "type": "object",
      "properties": {
        "base": {
          "type": "string",
          "format": "uint64",
          "description": "The base scid that resulted from the base scid look up."
        }
      }
    },
    "routerrpcForwardEvent": {
      "type": "object",
      "properties": {
        "info": {
          "$ref": "#/definitions/routerrpcHtlcInfo",
          "description": "Info contains details about the htlc that was forwarded."
        }
      }
    },
    "routerrpcForwardFailEvent": {
      "type": "object"
    },
    "routerrpcForwardHtlcInterceptRequest": {
      "type": "object",
      "properties": {
        "incoming_circuit_key": {
          "$ref": "#/definitions/routerrpcCircuitKey",
          "description": "The key of this forwarded htlc. It defines the incoming channel id and\nthe index in this channel."
        },
        "incoming_amount_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The incoming htlc amount."
        },
        "incoming_expiry": {
          "type": "integer",
          "format": "int64",
          "description": "The incoming htlc expiry."
        },
        "payment_hash": {
          "type": "string",
          "format": "byte",
          "description": "The htlc payment hash. This value is not guaranteed to be unique per\nrequest."
        },
        "outgoing_requested_chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "The requested outgoing channel id for this forwarded htlc. Because of\nnon-strict forwarding, this isn't necessarily the channel over which the\npacket will be forwarded eventually. A different channel to the same peer\nmay be selected as well."
        },
        "outgoing_amount_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The outgoing htlc amount."
        },
        "outgoing_expiry": {
          "type": "integer",
          "format": "int64",
          "description": "The outgoing htlc expiry."
        },
        "custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "Any custom records that were present in the payload."
        },
        "onion_blob": {
          "type": "string",
          "format": "byte",
          "title": "The onion blob for the next hop"
        },
        "auto_fail_height": {
          "type": "integer",
          "format": "int32",
          "description": "The block height at which this htlc will be auto-failed to prevent the\nchannel from force-closing."
        },
        "in_wire_custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "The custom records of the peer's incoming p2p wire message."
        }
      }
    },
    "routerrpcForwardHtlcInterceptResponse": {
      "type": "object",
      "properties": {
        "incoming_circuit_key": {
          "$ref": "#/definitions/routerrpcCircuitKey",
          "description": "*\nThe key of this forwarded htlc. It defines the incoming channel id and\nthe index in this channel."
        },
        "action": {
          "$ref": "#/definitions/routerrpcResolveHoldForwardAction",
          "description": "The resolve action for this intercepted htlc."
        },
        "preimage": {
          "type": "string",
          "format": "byte",
          "description": "The preimage in case the resolve action is Settle."
        },
        "failure_message": {
          "type": "string",
          "format": "byte",
          "description": "Encrypted failure message in case the resolve action is Fail.\n\nIf failure_message is specified, the failure_code field must be set\nto zero."
        },
        "failure_code": {
          "$ref": "#/definitions/FailureFailureCode",
          "description": "Return the specified failure code in case the resolve action is Fail. The\nmessage data fields are populated automatically.\n\nIf a non-zero failure_code is specified, failure_message must not be set.\n\nFor backwards-compatibility reasons, TEMPORARY_CHANNEL_FAILURE is the\ndefault value for this field."
        },
        "in_amount_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The amount that was set on the p2p wire message of the incoming HTLC.\nThis field is ignored if the action is not RESUME_MODIFIED or the amount\nis zero."
        },
        "out_amount_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The amount to set on the p2p wire message of the resumed HTLC. This field\nis ignored if the action is not RESUME_MODIFIED or the amount is zero."
        },
        "out_wire_custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "Any custom records that should be set on the p2p wire message message of\nthe resumed HTLC. This field is ignored if the action is not\nRESUME_MODIFIED.\n\nThis map will merge with the existing set of custom records (if any),\nreplacing any conflicting types. Note that there currently is no support\nfor deleting existing custom records (they can only be replaced)."
        }
      },
      "description": "*\nForwardHtlcInterceptResponse enables the caller to resolve a previously hold\nforward. The caller can choose either to:\n- `Resume`: Execute the default behavior (usually forward).\n- `ResumeModified`: Execute the default behavior (usually forward) with HTLC\nfield modifications.\n- `Reject`: Fail the htlc backwards.\n- `Settle`: Settle this htlc with a given preimage."
    },
    "routerrpcGetMissionControlConfigResponse": {
      "type": "object",
      "properties": {
        "config": {
          "$ref": "#/definitions/routerrpcMissionControlConfig",
          "description": "Mission control's currently active config."
        }
      }
    },
    "routerrpcHtlcEvent": {
      "type": "object",
      "properties": {
        "incoming_channel_id": {
          "type": "string",
          "format": "uint64",
          "description": "The short channel id that the incoming htlc arrived at our node on. This\nvalue is zero for sends."
        },
        "outgoing_channel_id": {
          "type": "string",
          "format": "uint64",
          "description": "The short channel id that the outgoing htlc left our node on. This value\nis zero for receives."
        },
        "incoming_htlc_id": {
          "type": "string",
          "format": "uint64",
          "description": "Incoming id is the index of the incoming htlc in the incoming channel.\nThis value is zero for sends."
        },
        "outgoing_htlc_id": {
          "type": "string",
          "format": "uint64",
          "description": "Outgoing id is the index of the outgoing htlc in the outgoing channel.\nThis value is zero for receives."
        },
        "timestamp_ns": {
          "type": "string",
          "format": "uint64",
          "description": "The time in unix nanoseconds that the event occurred."
        },
        "event_type": {
          "$ref": "#/definitions/routerrpcHtlcEventEventType",
          "description": "The event type indicates whether the htlc was part of a send, receive or\nforward."
        },
        "forward_event": {
          "$ref": "#/definitions/routerrpcForwardEvent"
        },
        "forward_fail_event": {
          "$ref": "#/definitions/routerrpcForwardFailEvent"
        },
        "settle_event": {
          "$ref": "#/definitions/routerrpcSettleEvent"
        },
        "link_fail_event": {
          "$ref": "#/definitions/routerrpcLinkFailEvent"
        },
        "subscribed_event": {
          "$ref": "#/definitions/routerrpcSubscribedEvent"
        },
        "final_htlc_event": {
          "$ref": "#/definitions/routerrpcFinalHtlcEvent"
        }
      },
      "title": "HtlcEvent contains the htlc event that was processed. These are served on a\nbest-effort basis; events are not persisted, delivery is not guaranteed\n(in the event of a crash in the switch, forward events may be lost) and\nsome events may be replayed upon restart. Events consumed from this package\nshould be de-duplicated by the htlc's unique combination of incoming and\noutgoing channel id and htlc id. [EXPERIMENTAL]"
    },
    "routerrpcHtlcEventEventType": {
      "type": "string",
      "enum": [
        "UNKNOWN",
        "SEND",
        "RECEIVE",
        "FORWARD"
      ],
      "default": "UNKNOWN"
    },
    "routerrpcHtlcInfo": {
      "type": "object",
      "properties": {
        "incoming_timelock": {
          "type": "integer",
          "format": "int64",
          "description": "The timelock on the incoming htlc."
        },
        "outgoing_timelock": {
          "type": "integer",
          "format": "int64",
          "description": "The timelock on the outgoing htlc."
        },
        "incoming_amt_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The amount of the incoming htlc."
        },
        "outgoing_amt_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The amount of the outgoing htlc."
        }
      }
    },
    "routerrpcLinkFailEvent": {
      "type": "object",
      "properties": {
        "info": {
          "$ref": "#/definitions/routerrpcHtlcInfo",
          "description": "Info contains details about the htlc that we failed."
        },
        "wire_failure": {
          "$ref": "#/definitions/FailureFailureCode",
          "description": "FailureCode is the BOLT error code for the failure."
        },
        "failure_detail": {
          "$ref": "#/definitions/routerrpcFailureDetail",
          "description": "FailureDetail provides additional information about the reason for the\nfailure. This detail enriches the information provided by the wire message\nand may be 'no detail' if the wire message requires no additional metadata."
        },
        "failure_string": {
          "type": "string",
          "description": "A string representation of the link failure."
        }
      }
    },
    "routerrpcMissionControlConfig": {
      "type": "object",
      "properties": {
        "half_life_seconds": {
          "type": "string",
          "format": "uint64",
          "description": "Deprecated, use AprioriParameters. The amount of time mission control will\ntake to restore a penalized node or channel back to 50% success probability,\nexpressed in seconds. Setting this value to a higher value will penalize\nfailures for longer, making mission control less likely to route through\nnodes and channels that we have previously recorded failures for."
        },
        "hop_probability": {
          "type": "number",
          "format": "float",
          "description": "Deprecated, use AprioriParameters. The probability of success mission\ncontrol should assign to hop in a route where it has no other information\navailable. Higher values will make mission control more willing to try hops\nthat we have no information about, lower values will discourage trying these\nhops."
        },
        "weight": {
          "type": "number",
          "format": "float",
          "description": "Deprecated, use AprioriParameters. The importance that mission control\nshould place on historical results, expressed as a value in [0;1]. Setting\nthis value to 1 will ignore all historical payments and just use the hop\nprobability to assess the probability of success for each hop. A zero value\nignores hop probability completely and relies entirely on historical\nresults, unless none are available."
        },
        "maximum_payment_results": {
          "type": "integer",
          "format": "int64",
          "description": "The maximum number of payment results that mission control will store."
        },
        "minimum_failure_relax_interval": {
          "type": "string",
          "format": "uint64",
          "description": "The minimum time that must have passed since the previously recorded failure\nbefore we raise the failure amount."
        },
        "model": {
          "$ref": "#/definitions/MissionControlConfigProbabilityModel",
          "description": "ProbabilityModel defines which probability estimator should be used in\npathfinding. Note that the bimodal estimator is experimental."
        },
        "apriori": {
          "$ref": "#/definitions/routerrpcAprioriParameters"
        },
        "bimodal": {
          "$ref": "#/definitions/routerrpcBimodalParameters"
        }
      }
    },
    "routerrpcPairData": {
      "type": "object",
      "properties": {
        "fail_time": {
          "type": "string",
          "format": "int64",
          "description": "Time of last failure."
        },
        "fail_amt_sat": {
          "type": "string",
          "format": "int64",
          "description": "Lowest amount that failed to forward rounded to whole sats. This may be\nset to zero if the failure is independent of amount."
        },
        "fail_amt_msat": {
          "type": "string",
          "format": "int64",
          "description": "Lowest amount that failed to forward in millisats. This may be\nset to zero if the failure is independent of amount."
        },
        "success_time": {
          "type": "string",
          "format": "int64",
          "description": "Time of last success."
        },
        "success_amt_sat": {
          "type": "string",
          "format": "int64",
          "description": "Highest amount that we could successfully forward rounded to whole sats."
        },
        "success_amt_msat": {
          "type": "string",
          "format": "int64",
          "description": "Highest amount that we could successfully forward in millisats."
        }
      }
    },
    "routerrpcPairHistory": {
      "type": "object",
      "properties": {
        "node_from": {
          "type": "string",
          "format": "byte",
          "description": "The source node pubkey of the pair."
        },
        "node_to": {
          "type": "string",
          "format": "byte",
          "description": "The destination node pubkey of the pair."
        },
        "history": {
          "$ref": "#/definitions/routerrpcPairData"
        }
      },
      "description": "PairHistory contains the mission control state for a particular node pair."
    },
    "routerrpcPaymentState": {
      "type": "string",
      "enum": [
        "IN_FLIGHT",
        "SUCCEEDED",
        "FAILED_TIMEOUT",
        "FAILED_NO_ROUTE",
        "FAILED_ERROR",
        "FAILED_INCORRECT_PAYMENT_DETAILS",
        "FAILED_INSUFFICIENT_BALANCE"
      ],
      "default": "IN_FLIGHT",
      "description": " - IN_FLIGHT: Payment is still in flight.\n - SUCCEEDED: Payment completed successfully.\n - FAILED_TIMEOUT: There are more routes to try, but the payment timeout was exceeded.\n - FAILED_NO_ROUTE: All possible routes were tried and failed permanently. Or were no\nroutes to the destination at all.\n - FAILED_ERROR: A non-recoverable error has occurred.\n - FAILED_INCORRECT_PAYMENT_DETAILS: Payment details incorrect (unknown hash, invalid amt or\ninvalid final cltv delta)\n - FAILED_INSUFFICIENT_BALANCE: Insufficient local balance."
    },
    "routerrpcPaymentStatus": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/routerrpcPaymentState",
          "description": "Current state the payment is in."
        },
        "preimage": {
          "type": "string",
          "format": "byte",
          "description": "The pre-image of the payment when state is SUCCEEDED."
        },
        "htlcs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcHTLCAttempt"
          },
          "description": "The HTLCs made in attempt to settle the payment [EXPERIMENTAL]."
        }
      }
    },
    "routerrpcQueryMissionControlResponse": {
      "type": "object",
      "properties": {
        "pairs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/routerrpcPairHistory"
          },
          "description": "Node pair-level mission control state."
        }
      },
      "description": "QueryMissionControlResponse contains mission control state."
    },
    "routerrpcQueryProbabilityResponse": {
      "type": "object",
      "properties": {
        "probability": {
          "type": "number",
          "format": "double",
          "description": "The success probability for the requested pair."
        },
        "history": {
          "$ref": "#/definitions/routerrpcPairData",
          "description": "The historical data for the requested pair."
        }
      }
    },
    "routerrpcResetMissionControlRequest": {
      "type": "object"
    },
    "routerrpcResetMissionControlResponse": {
      "type": "object"
    },
    "routerrpcResolveHoldForwardAction": {
      "type": "string",
      "enum": [
        "SETTLE",
        "FAIL",
        "RESUME",
        "RESUME_MODIFIED"
      ],
      "default": "SETTLE",
      "description": " - SETTLE: SETTLE is an action that is used to settle an HTLC instead of forwarding\nit.\n - FAIL: FAIL is an action that is used to fail an HTLC backwards.\n - RESUME: RESUME is an action that is used to resume a forward HTLC.\n - RESUME_MODIFIED: RESUME_MODIFIED is an action that is used to resume a hold forward HTLC\nwith modifications specified during interception."
    },
    "routerrpcRouteFeeRequest": {
      "type": "object",
      "properties": {
        "dest": {
          "type": "string",
          "format": "byte",
          "description": "The destination one wishes to obtain a routing fee quote to. If set, this\nparameter requires the amt_sat parameter also to be set. This parameter\ncombination triggers a graph based routing fee estimation as opposed to a\npayment probe based estimate in case a payment request is provided. The\ngraph based estimation is an algorithm that is executed on the in memory\ngraph. Hence its runtime is significantly shorter than a payment probe\nestimation that sends out actual payments to the network."
        },
        "amt_sat": {
          "type": "string",
          "format": "int64",
          "description": "The amount one wishes to send to the target destination. It is only to be\nused in combination with the dest parameter."
        },
        "payment_request": {
          "type": "string",
          "description": "A payment request of the target node that the route fee request is intended\nfor. Its parameters are input to probe payments that estimate routing fees.\nThe timeout parameter can be specified to set a maximum time on the probing\nattempt. Cannot be used in combination with dest and amt_sat."
        },
        "timeout": {
          "type": "integer",
          "format": "int64",
          "description": "A user preference of how long a probe payment should maximally be allowed to\ntake, denoted in seconds. The probing payment loop is aborted if this\ntimeout is reached. Note that the probing process itself can take longer\nthan the timeout if the HTLC becomes delayed or stuck. Canceling the context\nof this call will not cancel the payment loop, the duration is only\ncontrolled by the timeout parameter."
        }
      }
    },
    "routerrpcRouteFeeResponse": {
      "type": "object",
      "properties": {
        "routing_fee_msat": {
          "type": "string",
          "format": "int64",
          "description": "A lower bound of the estimated fee to the target destination within the\nnetwork, expressed in milli-satoshis."
        },
        "time_lock_delay": {
          "type": "string",
          "format": "int64",
          "description": "An estimate of the worst case time delay that can occur. Note that callers\nwill still need to factor in the final CLTV delta of the last hop into this\nvalue."
        },
        "failure_reason": {
          "$ref": "#/definitions/lnrpcPaymentFailureReason",
          "description": "An indication whether a probing payment succeeded or whether and why it\nfailed. FAILURE_REASON_NONE indicates success."
        }
      }
    },
    "routerrpcSendPaymentRequest": {
      "type": "object",
      "properties": {
        "dest": {
          "type": "string",
          "format": "byte",
          "title": "The identity pubkey of the payment recipient"
        },
        "amt": {
          "type": "string",
          "format": "int64",
          "description": "Number of satoshis to send.\n\nThe fields amt and amt_msat are mutually exclusive."
        },
        "payment_hash": {
          "type": "string",
          "format": "byte",
          "title": "The hash to use within the payment's HTLC"
        },
        "final_cltv_delta": {
          "type": "integer",
          "format": "int32",
          "description": "The CLTV delta from the current height that should be used to set the\ntimelock for the final hop."
        },
        "payment_request": {
          "type": "string",
          "description": "A bare-bones invoice for a payment within the Lightning Network.  With the\ndetails of the invoice, the sender has all the data necessary to send a\npayment to the recipient. The amount in the payment request may be zero. In\nthat case it is required to set the amt field as well. If no payment request\nis specified, the following fields are required: dest, amt and payment_hash."
        },
        "timeout_seconds": {
          "type": "integer",
          "format": "int32",
          "description": "An optional limit, expressed in seconds, on the time to wait before\nattempting the first HTLC. Once HTLCs are in flight, the payment will\nnot be aborted until the HTLCs are either settled or failed. If the field\nis not set or is explicitly set to zero, the default value of 60 seconds\nwill be applied."
        },
        "fee_limit_sat": {
          "type": "string",
          "format": "int64",
          "description": "The maximum number of satoshis that will be paid as a fee of the payment.\nIf this field is left to the default value of 0, only zero-fee routes will\nbe considered. This usually means single hop routes connecting directly to\nthe destination. To send the payment without a fee limit, use max int here.\n\nThe fields fee_limit_sat and fee_limit_msat are mutually exclusive."
        },
        "outgoing_chan_id": {
          "type": "string",
          "format": "uint64",
          "description": "Deprecated, use outgoing_chan_ids. The channel id of the channel that must\nbe taken to the first hop. If zero, any channel may be used (unless\noutgoing_chan_ids are set)."
        },
        "cltv_limit": {
          "type": "integer",
          "format": "int32",
          "description": "An optional maximum total time lock for the route. This should not\nexceed lnd's `--max-cltv-expiry` setting. If zero, then the value of\n`--max-cltv-expiry` is enforced."
        },
        "route_hints": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/lnrpcRouteHint"
          },
          "description": "Optional route hints to reach the destination through private channels."
        },
        "dest_custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "An optional field that can be used to pass an arbitrary set of TLV records\nto a peer which understands the new records. This can be used to pass\napplication specific data during the payment attempt. Record types are\nrequired to be in the custom range \u003e= 65536. When using REST, the values\nmust be encoded as base64."
        },
        "amt_msat": {
          "type": "string",
          "format": "int64",
          "description": "Number of millisatoshis to send.\n\nThe fields amt and amt_msat are mutually exclusive."
        },
        "fee_limit_msat": {
          "type": "string",
          "format": "int64",
          "description": "The maximum number of millisatoshis that will be paid as a fee of the\npayment. If this field is left to the default value of 0, only zero-fee\nroutes will be considered. This usually means single hop routes connecting\ndirectly to the destination. To send the payment without a fee limit, use\nmax int here.\n\nThe fields fee_limit_sat and fee_limit_msat are mutually exclusive."
        },
        "last_hop_pubkey": {
          "type": "string",
          "format": "byte",
          "description": "The pubkey of the last hop of the route. If empty, any hop may be used."
        },
        "allow_self_payment": {
          "type": "boolean",
          "description": "If set, circular payments to self are permitted."
        },
        "dest_features": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/lnrpcFeatureBit"
          },
          "description": "Features assumed to be supported by the final node. All transitive feature\ndependencies must also be set properly. For a given feature bit pair, either\noptional or remote may be set, but not both. If this field is nil or empty,\nthe router will try to load destination features from the graph as a\nfallback."
        },
        "max_parts": {
          "type": "integer",
          "format": "int64",
          "description": "The maximum number of partial payments that may be use to complete the full\namount."
        },
        "no_inflight_updates": {
          "type": "boolean",
          "description": "If set, only the final payment update is streamed back. Intermediate updates\nthat show which htlcs are still in flight are suppressed."
        },
        "outgoing_chan_ids": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "description": "The channel ids of the channels are allowed for the first hop. If empty,\nany channel may be used."
        },
        "payment_addr": {
          "type": "string",
          "format": "byte",
          "description": "An optional payment addr to be included within the last hop of the route.\nThis is also called payment secret in specifications (e.g. BOLT 11)."
        },
        "max_shard_size_msat": {
          "type": "string",
          "format": "uint64",
          "description": "The largest payment split that should be attempted when making a payment if\nsplitting is necessary. Setting this value will effectively cause lnd to\nsplit more aggressively, vs only when it thinks it needs to. Note that this\nvalue is in milli-satoshis."
        },
        "amp": {
          "type": "boolean",
          "description": "If set, an AMP-payment will be attempted."
        },
        "time_pref": {
          "type": "number",
          "format": "double",
          "description": "The time preference for this payment. Set to -1 to optimize for fees\nonly, to 1 to optimize for reliability only or a value inbetween for a mix."
        },
        "cancelable": {
          "type": "boolean",
          "description": "If set, the payment loop can be interrupted by manually canceling the\npayment context, even before the payment timeout is reached. Note that the\npayment may still succeed after cancellation, as in-flight attempts can\nstill settle afterwards. Canceling will only prevent further attempts from\nbeing sent."
        },
        "first_hop_custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "An optional field that can be used to pass an arbitrary set of TLV records\nto the first hop peer of this payment. This can be used to pass application\nspecific data during the payment attempt. Record types are required to be in\nthe custom range \u003e= 65536. When using REST, the values must be encoded as\nbase64."
        }
      }
    },
    "routerrpcSendToRouteRequest": {
      "type": "object",
      "properties": {
        "payment_hash": {
          "type": "string",
          "format": "byte",
          "description": "The payment hash to use for the HTLC."
        },
        "route": {
          "$ref": "#/definitions/lnrpcRoute",
          "description": "Route that should be used to attempt to complete the payment."
        },
        "skip_temp_err": {
          "type": "boolean",
          "description": "Whether the payment should be marked as failed when a temporary error is\nreturned from the given route. Set it to true so the payment won't be\nfailed unless a terminal error is occurred, such as payment timeout, no\nroutes, incorrect payment details, or insufficient funds."
        },
        "first_hop_custom_records": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "description": "An optional field that can be used to pass an arbitrary set of TLV records\nto the first hop peer of this payment. This can be used to pass application\nspecific data during the payment attempt. Record types are required to be in\nthe custom range \u003e= 65536. When using REST, the values must be encoded as\nbase64."
        }
      }
    },
    "routerrpcSendToRouteResponse": {
      "type": "object",
      "properties": {
        "preimage": {
          "type": "string",
          "format": "byte",
          "description": "The preimage obtained by making the payment."
        },
        "failure": {
          "$ref": "#/definitions/lnrpcFailure",
          "description": "The failure message in case the payment failed."
        }
      }
    },
    "routerrpcSetMissionControlConfigRequest": {
      "type": "object",
      "properties": {
        "config": {
          "$ref": "#/definitions/routerrpcMissionControlConfig",
          "description": "The config to set for mission control. Note that all values *must* be set,\nbecause the full config will be applied."
        }
      }
    },
    "routerrpcSetMissionControlConfigResponse": {
      "type": "object"
    },
    "routerrpcSettleEvent": {
      "type": "object",
      "properties": {
        "preimage": {
          "type": "string",
          "format": "byte",
          "description": "The revealed preimage."
        }
      }
    },
    "routerrpcSubscribedEvent": {
      "type": "object"
    },
    "routerrpcUpdateChanStatusRequest": {
      "type": "object",
      "properties": {
        "chan_point": {
          "$ref": "#/definitions/lnrpcChannelPoint"
        },
        "action": {
          "$ref": "#/definitions/routerrpcChanStatusAction"
        }
      }
    },
    "routerrpcUpdateChanStatusResponse": {
      "type": "object"
    },
    "routerrpcXImportMissionControlRequest": {
      "type": "object",
      "properties": {
        "pairs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/routerrpcPairHistory"
          },
          "description": "Node pair-level mission control state to be imported."
        },
        "force": {
          "type": "boolean",
          "description": "Whether to force override MC pair history. Note that even with force\noverride the failure pair is imported before the success pair and both\nstill clamp existing failure/success amounts."
        }
      }
    },
    "routerrpcXImportMissionControlResponse": {
      "type": "object"
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    }
  }
}
