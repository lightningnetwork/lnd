// Code generated by protoc-gen-go. DO NOT EDIT.
// source: rpc.proto

/*
Package lnrpc is a generated protocol buffer package.

It is generated from these files:
	rpc.proto

It has these top-level messages:
	Transaction
	GetTransactionsRequest
	TransactionDetails
	SendRequest
	SendResponse
	ChannelPoint
	LightningAddress
	SendManyRequest
	SendManyResponse
	SendCoinsRequest
	SendCoinsResponse
	NewAddressRequest
	NewWitnessAddressRequest
	NewAddressResponse
	SignMessageRequest
	SignMessageResponse
	VerifyMessageRequest
	VerifyMessageResponse
	ConnectPeerRequest
	ConnectPeerResponse
	DisconnectPeerRequest
	DisconnectPeerResponse
	HTLC
	ActiveChannel
	ListChannelsRequest
	ListChannelsResponse
	Peer
	ListPeersRequest
	ListPeersResponse
	GetInfoRequest
	GetInfoResponse
	ConfirmationUpdate
	ChannelOpenUpdate
	ChannelCloseUpdate
	CloseChannelRequest
	CloseStatusUpdate
	PendingUpdate
	OpenChannelRequest
	OpenStatusUpdate
	PendingChannelRequest
	PendingChannelResponse
	WalletBalanceRequest
	WalletBalanceResponse
	ChannelBalanceRequest
	ChannelBalanceResponse
	QueryRoutesRequest
	QueryRoutesResponse
	Hop
	Route
	NodeInfoRequest
	NodeInfo
	LightningNode
	NodeAddress
	RoutingPolicy
	ChannelEdge
	ChannelGraphRequest
	ChannelGraph
	ChanInfoRequest
	NetworkInfoRequest
	NetworkInfo
	StopRequest
	StopResponse
	GraphTopologySubscription
	GraphTopologyUpdate
	NodeUpdate
	ChannelEdgeUpdate
	ClosedChannelUpdate
	SetAliasRequest
	SetAliasResponse
	Invoice
	AddInvoiceResponse
	PaymentHash
	ListInvoiceRequest
	ListInvoiceResponse
	InvoiceSubscription
	Payment
	ListPaymentsRequest
	ListPaymentsResponse
	DeleteAllPaymentsRequest
	DeleteAllPaymentsResponse
	DebugLevelRequest
	DebugLevelResponse
	PayReqString
	PayReq
	FeeReportRequest
	ChannelFeeReport
	FeeReportResponse
	FeeUpdateRequest
	FeeUpdateResponse
*/
package lnrpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type NewAddressRequest_AddressType int32

const (
	NewAddressRequest_WITNESS_PUBKEY_HASH NewAddressRequest_AddressType = 0
	NewAddressRequest_NESTED_PUBKEY_HASH  NewAddressRequest_AddressType = 1
	NewAddressRequest_PUBKEY_HASH         NewAddressRequest_AddressType = 2
)

var NewAddressRequest_AddressType_name = map[int32]string{
	0: "WITNESS_PUBKEY_HASH",
	1: "NESTED_PUBKEY_HASH",
	2: "PUBKEY_HASH",
}
var NewAddressRequest_AddressType_value = map[string]int32{
	"WITNESS_PUBKEY_HASH": 0,
	"NESTED_PUBKEY_HASH":  1,
	"PUBKEY_HASH":         2,
}

func (x NewAddressRequest_AddressType) String() string {
	return proto.EnumName(NewAddressRequest_AddressType_name, int32(x))
}
func (NewAddressRequest_AddressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{11, 0}
}

type Transaction struct {
	// / The transaction hash
	TxHash string `protobuf:"bytes,1,opt,name=tx_hash" json:"tx_hash,omitempty"`
	// / The transaction ammount, denominated in satoshis
	Amount int64 `protobuf:"varint,2,opt,name=amount" json:"amount,omitempty"`
	// / The number of confirmations
	NumConfirmations int32 `protobuf:"varint,3,opt,name=num_confirmations" json:"num_confirmations,omitempty"`
	// / The hash of the block this transaction was included in
	BlockHash string `protobuf:"bytes,4,opt,name=block_hash" json:"block_hash,omitempty"`
	// / The height of the block this transaction was included in
	BlockHeight int32 `protobuf:"varint,5,opt,name=block_height" json:"block_height,omitempty"`
	// / Timestamp of this transaction
	TimeStamp int64 `protobuf:"varint,6,opt,name=time_stamp" json:"time_stamp,omitempty"`
	// / Fees paid for this transaction
	TotalFees int64 `protobuf:"varint,7,opt,name=total_fees" json:"total_fees,omitempty"`
}

func (m *Transaction) Reset()                    { *m = Transaction{} }
func (m *Transaction) String() string            { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()               {}
func (*Transaction) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Transaction) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *Transaction) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Transaction) GetNumConfirmations() int32 {
	if m != nil {
		return m.NumConfirmations
	}
	return 0
}

func (m *Transaction) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *Transaction) GetBlockHeight() int32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *Transaction) GetTimeStamp() int64 {
	if m != nil {
		return m.TimeStamp
	}
	return 0
}

func (m *Transaction) GetTotalFees() int64 {
	if m != nil {
		return m.TotalFees
	}
	return 0
}

type GetTransactionsRequest struct {
}

func (m *GetTransactionsRequest) Reset()                    { *m = GetTransactionsRequest{} }
func (m *GetTransactionsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetTransactionsRequest) ProtoMessage()               {}
func (*GetTransactionsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type TransactionDetails struct {
	// / The list of transactions relevant to the wallet.
	Transactions []*Transaction `protobuf:"bytes,1,rep,name=transactions" json:"transactions,omitempty"`
}

func (m *TransactionDetails) Reset()                    { *m = TransactionDetails{} }
func (m *TransactionDetails) String() string            { return proto.CompactTextString(m) }
func (*TransactionDetails) ProtoMessage()               {}
func (*TransactionDetails) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *TransactionDetails) GetTransactions() []*Transaction {
	if m != nil {
		return m.Transactions
	}
	return nil
}

type SendRequest struct {
	// / The identity pubkey of the payment recipient
	Dest []byte `protobuf:"bytes,1,opt,name=dest,proto3" json:"dest,omitempty"`
	// / The hex-encoded identity pubkey of the payment recipient
	DestString string `protobuf:"bytes,2,opt,name=dest_string,json=destString" json:"dest_string,omitempty"`
	// / Number of satoshis to send.
	Amt int64 `protobuf:"varint,3,opt,name=amt" json:"amt,omitempty"`
	// / The hash to use within the payment's HTLC
	PaymentHash []byte `protobuf:"bytes,4,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	// / The hex-encoded hash to use within the payment's HTLC
	PaymentHashString string `protobuf:"bytes,5,opt,name=payment_hash_string,json=paymentHashString" json:"payment_hash_string,omitempty"`
	// *
	// A bare-bones invoice for a payment within the Lightning Network.  With the
	// details of the invoice, the sender has all the data necessary to send a
	// payment to the recipient.
	PaymentRequest string `protobuf:"bytes,6,opt,name=payment_request,json=paymentRequest" json:"payment_request,omitempty"`
}

func (m *SendRequest) Reset()                    { *m = SendRequest{} }
func (m *SendRequest) String() string            { return proto.CompactTextString(m) }
func (*SendRequest) ProtoMessage()               {}
func (*SendRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SendRequest) GetDest() []byte {
	if m != nil {
		return m.Dest
	}
	return nil
}

func (m *SendRequest) GetDestString() string {
	if m != nil {
		return m.DestString
	}
	return ""
}

func (m *SendRequest) GetAmt() int64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *SendRequest) GetPaymentHash() []byte {
	if m != nil {
		return m.PaymentHash
	}
	return nil
}

func (m *SendRequest) GetPaymentHashString() string {
	if m != nil {
		return m.PaymentHashString
	}
	return ""
}

func (m *SendRequest) GetPaymentRequest() string {
	if m != nil {
		return m.PaymentRequest
	}
	return ""
}

type SendResponse struct {
	PaymentError    string `protobuf:"bytes,1,opt,name=payment_error" json:"payment_error,omitempty"`
	PaymentPreimage []byte `protobuf:"bytes,2,opt,name=payment_preimage,proto3" json:"payment_preimage,omitempty"`
	PaymentRoute    *Route `protobuf:"bytes,3,opt,name=payment_route" json:"payment_route,omitempty"`
}

func (m *SendResponse) Reset()                    { *m = SendResponse{} }
func (m *SendResponse) String() string            { return proto.CompactTextString(m) }
func (*SendResponse) ProtoMessage()               {}
func (*SendResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SendResponse) GetPaymentError() string {
	if m != nil {
		return m.PaymentError
	}
	return ""
}

func (m *SendResponse) GetPaymentPreimage() []byte {
	if m != nil {
		return m.PaymentPreimage
	}
	return nil
}

func (m *SendResponse) GetPaymentRoute() *Route {
	if m != nil {
		return m.PaymentRoute
	}
	return nil
}

type ChannelPoint struct {
	// / Txid of the funding transaction
	FundingTxid []byte `protobuf:"bytes,1,opt,name=funding_txid,proto3" json:"funding_txid,omitempty"`
	// / Hex-encoded string representing the funding transaction
	FundingTxidStr string `protobuf:"bytes,2,opt,name=funding_txid_str" json:"funding_txid_str,omitempty"`
	// / The index of the output of the funding transaction
	OutputIndex uint32 `protobuf:"varint,3,opt,name=output_index" json:"output_index,omitempty"`
}

func (m *ChannelPoint) Reset()                    { *m = ChannelPoint{} }
func (m *ChannelPoint) String() string            { return proto.CompactTextString(m) }
func (*ChannelPoint) ProtoMessage()               {}
func (*ChannelPoint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ChannelPoint) GetFundingTxid() []byte {
	if m != nil {
		return m.FundingTxid
	}
	return nil
}

func (m *ChannelPoint) GetFundingTxidStr() string {
	if m != nil {
		return m.FundingTxidStr
	}
	return ""
}

func (m *ChannelPoint) GetOutputIndex() uint32 {
	if m != nil {
		return m.OutputIndex
	}
	return 0
}

type LightningAddress struct {
	// / The identity pubkey of the Lightning node
	Pubkey string `protobuf:"bytes,1,opt,name=pubkey" json:"pubkey,omitempty"`
	// / The network location of the lightning node, e.g. `69.69.69.69:1337` or `localhost:10011`
	Host string `protobuf:"bytes,2,opt,name=host" json:"host,omitempty"`
}

func (m *LightningAddress) Reset()                    { *m = LightningAddress{} }
func (m *LightningAddress) String() string            { return proto.CompactTextString(m) }
func (*LightningAddress) ProtoMessage()               {}
func (*LightningAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *LightningAddress) GetPubkey() string {
	if m != nil {
		return m.Pubkey
	}
	return ""
}

func (m *LightningAddress) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

type SendManyRequest struct {
	// / The map from addresses to amounts
	AddrToAmount map[string]int64 `protobuf:"bytes,1,rep,name=AddrToAmount" json:"AddrToAmount,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *SendManyRequest) Reset()                    { *m = SendManyRequest{} }
func (m *SendManyRequest) String() string            { return proto.CompactTextString(m) }
func (*SendManyRequest) ProtoMessage()               {}
func (*SendManyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *SendManyRequest) GetAddrToAmount() map[string]int64 {
	if m != nil {
		return m.AddrToAmount
	}
	return nil
}

type SendManyResponse struct {
	// / The id of the transaction
	Txid string `protobuf:"bytes,1,opt,name=txid" json:"txid,omitempty"`
}

func (m *SendManyResponse) Reset()                    { *m = SendManyResponse{} }
func (m *SendManyResponse) String() string            { return proto.CompactTextString(m) }
func (*SendManyResponse) ProtoMessage()               {}
func (*SendManyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *SendManyResponse) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

type SendCoinsRequest struct {
	// / The address to send coins to
	Addr string `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
	// / The amount in satoshis to send
	Amount int64 `protobuf:"varint,2,opt,name=amount" json:"amount,omitempty"`
}

func (m *SendCoinsRequest) Reset()                    { *m = SendCoinsRequest{} }
func (m *SendCoinsRequest) String() string            { return proto.CompactTextString(m) }
func (*SendCoinsRequest) ProtoMessage()               {}
func (*SendCoinsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *SendCoinsRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *SendCoinsRequest) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type SendCoinsResponse struct {
	// / The transaction ID of the transaction
	Txid string `protobuf:"bytes,1,opt,name=txid" json:"txid,omitempty"`
}

func (m *SendCoinsResponse) Reset()                    { *m = SendCoinsResponse{} }
func (m *SendCoinsResponse) String() string            { return proto.CompactTextString(m) }
func (*SendCoinsResponse) ProtoMessage()               {}
func (*SendCoinsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *SendCoinsResponse) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

// *
// `AddressType` has to be one of:
//
// - `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)
// - `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)
// - `p2pkh`:  Pay to public key hash (`PUBKEY_HASH` = 2)
type NewAddressRequest struct {
	// / The address type
	Type NewAddressRequest_AddressType `protobuf:"varint,1,opt,name=type,enum=lnrpc.NewAddressRequest_AddressType" json:"type,omitempty"`
}

func (m *NewAddressRequest) Reset()                    { *m = NewAddressRequest{} }
func (m *NewAddressRequest) String() string            { return proto.CompactTextString(m) }
func (*NewAddressRequest) ProtoMessage()               {}
func (*NewAddressRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *NewAddressRequest) GetType() NewAddressRequest_AddressType {
	if m != nil {
		return m.Type
	}
	return NewAddressRequest_WITNESS_PUBKEY_HASH
}

type NewWitnessAddressRequest struct {
}

func (m *NewWitnessAddressRequest) Reset()                    { *m = NewWitnessAddressRequest{} }
func (m *NewWitnessAddressRequest) String() string            { return proto.CompactTextString(m) }
func (*NewWitnessAddressRequest) ProtoMessage()               {}
func (*NewWitnessAddressRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

type NewAddressResponse struct {
	// / The newly generated wallet address
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
}

func (m *NewAddressResponse) Reset()                    { *m = NewAddressResponse{} }
func (m *NewAddressResponse) String() string            { return proto.CompactTextString(m) }
func (*NewAddressResponse) ProtoMessage()               {}
func (*NewAddressResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *NewAddressResponse) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type SignMessageRequest struct {
	// / The message to be signed
	Msg []byte `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *SignMessageRequest) Reset()                    { *m = SignMessageRequest{} }
func (m *SignMessageRequest) String() string            { return proto.CompactTextString(m) }
func (*SignMessageRequest) ProtoMessage()               {}
func (*SignMessageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *SignMessageRequest) GetMsg() []byte {
	if m != nil {
		return m.Msg
	}
	return nil
}

type SignMessageResponse struct {
	// / The signature for the given message
	Signature string `protobuf:"bytes,1,opt,name=signature" json:"signature,omitempty"`
}

func (m *SignMessageResponse) Reset()                    { *m = SignMessageResponse{} }
func (m *SignMessageResponse) String() string            { return proto.CompactTextString(m) }
func (*SignMessageResponse) ProtoMessage()               {}
func (*SignMessageResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *SignMessageResponse) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

type VerifyMessageRequest struct {
	// / The message over which the signature is to be verified
	Msg []byte `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	// / The signature to be verifed over the given message
	Signature string `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
}

func (m *VerifyMessageRequest) Reset()                    { *m = VerifyMessageRequest{} }
func (m *VerifyMessageRequest) String() string            { return proto.CompactTextString(m) }
func (*VerifyMessageRequest) ProtoMessage()               {}
func (*VerifyMessageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *VerifyMessageRequest) GetMsg() []byte {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *VerifyMessageRequest) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

type VerifyMessageResponse struct {
	// / Whether the signature was valid over the given message
	Valid bool `protobuf:"varint,1,opt,name=valid" json:"valid,omitempty"`
	// / The pubkey recovered from the signature
	Pubkey string `protobuf:"bytes,2,opt,name=pubkey" json:"pubkey,omitempty"`
}

func (m *VerifyMessageResponse) Reset()                    { *m = VerifyMessageResponse{} }
func (m *VerifyMessageResponse) String() string            { return proto.CompactTextString(m) }
func (*VerifyMessageResponse) ProtoMessage()               {}
func (*VerifyMessageResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *VerifyMessageResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *VerifyMessageResponse) GetPubkey() string {
	if m != nil {
		return m.Pubkey
	}
	return ""
}

type ConnectPeerRequest struct {
	// / Lightning address of the peer, in the format `<pubkey>@host`
	Addr *LightningAddress `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
	// * If set, the daemon will attempt to persistently connect to the target
	// peer.  Otherwise, the call will be synchronous.
	Perm bool `protobuf:"varint,2,opt,name=perm" json:"perm,omitempty"`
}

func (m *ConnectPeerRequest) Reset()                    { *m = ConnectPeerRequest{} }
func (m *ConnectPeerRequest) String() string            { return proto.CompactTextString(m) }
func (*ConnectPeerRequest) ProtoMessage()               {}
func (*ConnectPeerRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ConnectPeerRequest) GetAddr() *LightningAddress {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *ConnectPeerRequest) GetPerm() bool {
	if m != nil {
		return m.Perm
	}
	return false
}

type ConnectPeerResponse struct {
	// / The id of the newly connected peer
	PeerId int32 `protobuf:"varint,1,opt,name=peer_id" json:"peer_id,omitempty"`
}

func (m *ConnectPeerResponse) Reset()                    { *m = ConnectPeerResponse{} }
func (m *ConnectPeerResponse) String() string            { return proto.CompactTextString(m) }
func (*ConnectPeerResponse) ProtoMessage()               {}
func (*ConnectPeerResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *ConnectPeerResponse) GetPeerId() int32 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

type DisconnectPeerRequest struct {
	// / The pubkey of the node to disconnect from
	PubKey string `protobuf:"bytes,1,opt,name=pub_key" json:"pub_key,omitempty"`
}

func (m *DisconnectPeerRequest) Reset()                    { *m = DisconnectPeerRequest{} }
func (m *DisconnectPeerRequest) String() string            { return proto.CompactTextString(m) }
func (*DisconnectPeerRequest) ProtoMessage()               {}
func (*DisconnectPeerRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *DisconnectPeerRequest) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

type DisconnectPeerResponse struct {
}

func (m *DisconnectPeerResponse) Reset()                    { *m = DisconnectPeerResponse{} }
func (m *DisconnectPeerResponse) String() string            { return proto.CompactTextString(m) }
func (*DisconnectPeerResponse) ProtoMessage()               {}
func (*DisconnectPeerResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

type HTLC struct {
	Incoming         bool   `protobuf:"varint,1,opt,name=incoming" json:"incoming,omitempty"`
	Amount           int64  `protobuf:"varint,2,opt,name=amount" json:"amount,omitempty"`
	HashLock         []byte `protobuf:"bytes,3,opt,name=hash_lock,proto3" json:"hash_lock,omitempty"`
	ExpirationHeight uint32 `protobuf:"varint,4,opt,name=expiration_height" json:"expiration_height,omitempty"`
}

func (m *HTLC) Reset()                    { *m = HTLC{} }
func (m *HTLC) String() string            { return proto.CompactTextString(m) }
func (*HTLC) ProtoMessage()               {}
func (*HTLC) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *HTLC) GetIncoming() bool {
	if m != nil {
		return m.Incoming
	}
	return false
}

func (m *HTLC) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *HTLC) GetHashLock() []byte {
	if m != nil {
		return m.HashLock
	}
	return nil
}

func (m *HTLC) GetExpirationHeight() uint32 {
	if m != nil {
		return m.ExpirationHeight
	}
	return 0
}

type ActiveChannel struct {
	// / Whether this channel is active or not
	Active bool `protobuf:"varint,1,opt,name=active" json:"active,omitempty"`
	// / The identity pubkey of the remote node
	RemotePubkey string `protobuf:"bytes,2,opt,name=remote_pubkey" json:"remote_pubkey,omitempty"`
	// *
	// The outpoint (txid:index) of the funding transaction. With this value, Bob
	// will be able to generate a signature for Alice's version of the commitment
	// transaction.
	ChannelPoint string `protobuf:"bytes,3,opt,name=channel_point" json:"channel_point,omitempty"`
	// *
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChanId uint64 `protobuf:"varint,4,opt,name=chan_id" json:"chan_id,omitempty"`
	// / The total amount of funds held in this channel
	Capacity int64 `protobuf:"varint,5,opt,name=capacity" json:"capacity,omitempty"`
	// / This node's current balance in this channel
	LocalBalance int64 `protobuf:"varint,6,opt,name=local_balance" json:"local_balance,omitempty"`
	// / The counterparty's current balance in this channel
	RemoteBalance int64 `protobuf:"varint,7,opt,name=remote_balance" json:"remote_balance,omitempty"`
	// *
	// The amount calculated to be paid in fees for the current set of commitment
	// transactions. The fee amount is persisted with the channel in order to
	// allow the fee amount to be removed and recalculated with each channel state
	// update, including updates that happen after a system restart.
	CommitFee int64 `protobuf:"varint,8,opt,name=commit_fee" json:"commit_fee,omitempty"`
	// / The weight of the commitment transaction
	CommitWeight int64 `protobuf:"varint,9,opt,name=commit_weight" json:"commit_weight,omitempty"`
	// *
	// The required number of satoshis per kilo-weight that the requester will pay
	// at all times, for both the funding transaction and commitment transaction.
	// This value can later be updated once the channel is open.
	FeePerKw int64 `protobuf:"varint,10,opt,name=fee_per_kw" json:"fee_per_kw,omitempty"`
	// / The unsettled balance in this channel
	UnsettledBalance int64 `protobuf:"varint,11,opt,name=unsettled_balance" json:"unsettled_balance,omitempty"`
	// *
	// The total number of satoshis we've sent within this channel.
	TotalSatoshisSent int64 `protobuf:"varint,12,opt,name=total_satoshis_sent" json:"total_satoshis_sent,omitempty"`
	// *
	// The total number of satoshis we've received within this channel.
	TotalSatoshisReceived int64 `protobuf:"varint,13,opt,name=total_satoshis_received" json:"total_satoshis_received,omitempty"`
	// *
	// The total number of updates conducted within this channel.
	NumUpdates uint64 `protobuf:"varint,14,opt,name=num_updates" json:"num_updates,omitempty"`
	// *
	// The list of active, uncleared HTLCs currently pending within the channel.
	PendingHtlcs []*HTLC `protobuf:"bytes,15,rep,name=pending_htlcs" json:"pending_htlcs,omitempty"`
}

func (m *ActiveChannel) Reset()                    { *m = ActiveChannel{} }
func (m *ActiveChannel) String() string            { return proto.CompactTextString(m) }
func (*ActiveChannel) ProtoMessage()               {}
func (*ActiveChannel) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *ActiveChannel) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *ActiveChannel) GetRemotePubkey() string {
	if m != nil {
		return m.RemotePubkey
	}
	return ""
}

func (m *ActiveChannel) GetChannelPoint() string {
	if m != nil {
		return m.ChannelPoint
	}
	return ""
}

func (m *ActiveChannel) GetChanId() uint64 {
	if m != nil {
		return m.ChanId
	}
	return 0
}

func (m *ActiveChannel) GetCapacity() int64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *ActiveChannel) GetLocalBalance() int64 {
	if m != nil {
		return m.LocalBalance
	}
	return 0
}

func (m *ActiveChannel) GetRemoteBalance() int64 {
	if m != nil {
		return m.RemoteBalance
	}
	return 0
}

func (m *ActiveChannel) GetCommitFee() int64 {
	if m != nil {
		return m.CommitFee
	}
	return 0
}

func (m *ActiveChannel) GetCommitWeight() int64 {
	if m != nil {
		return m.CommitWeight
	}
	return 0
}

func (m *ActiveChannel) GetFeePerKw() int64 {
	if m != nil {
		return m.FeePerKw
	}
	return 0
}

func (m *ActiveChannel) GetUnsettledBalance() int64 {
	if m != nil {
		return m.UnsettledBalance
	}
	return 0
}

func (m *ActiveChannel) GetTotalSatoshisSent() int64 {
	if m != nil {
		return m.TotalSatoshisSent
	}
	return 0
}

func (m *ActiveChannel) GetTotalSatoshisReceived() int64 {
	if m != nil {
		return m.TotalSatoshisReceived
	}
	return 0
}

func (m *ActiveChannel) GetNumUpdates() uint64 {
	if m != nil {
		return m.NumUpdates
	}
	return 0
}

func (m *ActiveChannel) GetPendingHtlcs() []*HTLC {
	if m != nil {
		return m.PendingHtlcs
	}
	return nil
}

type ListChannelsRequest struct {
}

func (m *ListChannelsRequest) Reset()                    { *m = ListChannelsRequest{} }
func (m *ListChannelsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListChannelsRequest) ProtoMessage()               {}
func (*ListChannelsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

type ListChannelsResponse struct {
	// / The list of active channels
	Channels []*ActiveChannel `protobuf:"bytes,11,rep,name=channels" json:"channels,omitempty"`
}

func (m *ListChannelsResponse) Reset()                    { *m = ListChannelsResponse{} }
func (m *ListChannelsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListChannelsResponse) ProtoMessage()               {}
func (*ListChannelsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *ListChannelsResponse) GetChannels() []*ActiveChannel {
	if m != nil {
		return m.Channels
	}
	return nil
}

type Peer struct {
	// / The identity pubkey of the peer
	PubKey string `protobuf:"bytes,1,opt,name=pub_key" json:"pub_key,omitempty"`
	// / The peer's id from the local point of view
	PeerId int32 `protobuf:"varint,2,opt,name=peer_id" json:"peer_id,omitempty"`
	// / Network address of the peer; eg `127.0.0.1:10011`
	Address string `protobuf:"bytes,3,opt,name=address" json:"address,omitempty"`
	// / Bytes of data transmitted to this peer
	BytesSent uint64 `protobuf:"varint,4,opt,name=bytes_sent" json:"bytes_sent,omitempty"`
	// / Bytes of data transmitted from this peer
	BytesRecv uint64 `protobuf:"varint,5,opt,name=bytes_recv" json:"bytes_recv,omitempty"`
	// / Satoshis sent to this peer
	SatSent int64 `protobuf:"varint,6,opt,name=sat_sent" json:"sat_sent,omitempty"`
	// / Satoshis received from this peer
	SatRecv int64 `protobuf:"varint,7,opt,name=sat_recv" json:"sat_recv,omitempty"`
	// / A channel is inbound if the counterparty initiated the channel
	Inbound bool `protobuf:"varint,8,opt,name=inbound" json:"inbound,omitempty"`
	// / Ping time to this peer
	PingTime int64 `protobuf:"varint,9,opt,name=ping_time" json:"ping_time,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *Peer) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *Peer) GetPeerId() int32 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *Peer) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Peer) GetBytesSent() uint64 {
	if m != nil {
		return m.BytesSent
	}
	return 0
}

func (m *Peer) GetBytesRecv() uint64 {
	if m != nil {
		return m.BytesRecv
	}
	return 0
}

func (m *Peer) GetSatSent() int64 {
	if m != nil {
		return m.SatSent
	}
	return 0
}

func (m *Peer) GetSatRecv() int64 {
	if m != nil {
		return m.SatRecv
	}
	return 0
}

func (m *Peer) GetInbound() bool {
	if m != nil {
		return m.Inbound
	}
	return false
}

func (m *Peer) GetPingTime() int64 {
	if m != nil {
		return m.PingTime
	}
	return 0
}

type ListPeersRequest struct {
}

func (m *ListPeersRequest) Reset()                    { *m = ListPeersRequest{} }
func (m *ListPeersRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPeersRequest) ProtoMessage()               {}
func (*ListPeersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

type ListPeersResponse struct {
	// / The list of currently connected peers
	Peers []*Peer `protobuf:"bytes,1,rep,name=peers" json:"peers,omitempty"`
}

func (m *ListPeersResponse) Reset()                    { *m = ListPeersResponse{} }
func (m *ListPeersResponse) String() string            { return proto.CompactTextString(m) }
func (*ListPeersResponse) ProtoMessage()               {}
func (*ListPeersResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *ListPeersResponse) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type GetInfoRequest struct {
}

func (m *GetInfoRequest) Reset()                    { *m = GetInfoRequest{} }
func (m *GetInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetInfoRequest) ProtoMessage()               {}
func (*GetInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

type GetInfoResponse struct {
	// / The identity pubkey of the current node.
	IdentityPubkey string `protobuf:"bytes,1,opt,name=identity_pubkey" json:"identity_pubkey,omitempty"`
	// / If applicable, the alias of the current node, e.g. "bob"
	Alias string `protobuf:"bytes,2,opt,name=alias" json:"alias,omitempty"`
	// / Number of pending channels
	NumPendingChannels uint32 `protobuf:"varint,3,opt,name=num_pending_channels" json:"num_pending_channels,omitempty"`
	// / Number of active channels
	NumActiveChannels uint32 `protobuf:"varint,4,opt,name=num_active_channels" json:"num_active_channels,omitempty"`
	// / Number of peers
	NumPeers uint32 `protobuf:"varint,5,opt,name=num_peers" json:"num_peers,omitempty"`
	// / The node's current view of the height of the best block
	BlockHeight uint32 `protobuf:"varint,6,opt,name=block_height" json:"block_height,omitempty"`
	// / The node's current view of the hash of the best block
	BlockHash string `protobuf:"bytes,8,opt,name=block_hash" json:"block_hash,omitempty"`
	// / Whether the wallet's view is synced to the main chain
	SyncedToChain bool `protobuf:"varint,9,opt,name=synced_to_chain" json:"synced_to_chain,omitempty"`
	// / Whether the current node is connected to testnet
	Testnet bool `protobuf:"varint,10,opt,name=testnet" json:"testnet,omitempty"`
	// / A list of active chains the node is connected to
	Chains []string `protobuf:"bytes,11,rep,name=chains" json:"chains,omitempty"`
}

func (m *GetInfoResponse) Reset()                    { *m = GetInfoResponse{} }
func (m *GetInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetInfoResponse) ProtoMessage()               {}
func (*GetInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *GetInfoResponse) GetIdentityPubkey() string {
	if m != nil {
		return m.IdentityPubkey
	}
	return ""
}

func (m *GetInfoResponse) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *GetInfoResponse) GetNumPendingChannels() uint32 {
	if m != nil {
		return m.NumPendingChannels
	}
	return 0
}

func (m *GetInfoResponse) GetNumActiveChannels() uint32 {
	if m != nil {
		return m.NumActiveChannels
	}
	return 0
}

func (m *GetInfoResponse) GetNumPeers() uint32 {
	if m != nil {
		return m.NumPeers
	}
	return 0
}

func (m *GetInfoResponse) GetBlockHeight() uint32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *GetInfoResponse) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *GetInfoResponse) GetSyncedToChain() bool {
	if m != nil {
		return m.SyncedToChain
	}
	return false
}

func (m *GetInfoResponse) GetTestnet() bool {
	if m != nil {
		return m.Testnet
	}
	return false
}

func (m *GetInfoResponse) GetChains() []string {
	if m != nil {
		return m.Chains
	}
	return nil
}

type ConfirmationUpdate struct {
	BlockSha     []byte `protobuf:"bytes,1,opt,name=block_sha,json=blockSha,proto3" json:"block_sha,omitempty"`
	BlockHeight  int32  `protobuf:"varint,2,opt,name=block_height,json=blockHeight" json:"block_height,omitempty"`
	NumConfsLeft uint32 `protobuf:"varint,3,opt,name=num_confs_left,json=numConfsLeft" json:"num_confs_left,omitempty"`
}

func (m *ConfirmationUpdate) Reset()                    { *m = ConfirmationUpdate{} }
func (m *ConfirmationUpdate) String() string            { return proto.CompactTextString(m) }
func (*ConfirmationUpdate) ProtoMessage()               {}
func (*ConfirmationUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *ConfirmationUpdate) GetBlockSha() []byte {
	if m != nil {
		return m.BlockSha
	}
	return nil
}

func (m *ConfirmationUpdate) GetBlockHeight() int32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *ConfirmationUpdate) GetNumConfsLeft() uint32 {
	if m != nil {
		return m.NumConfsLeft
	}
	return 0
}

type ChannelOpenUpdate struct {
	ChannelPoint *ChannelPoint `protobuf:"bytes,1,opt,name=channel_point" json:"channel_point,omitempty"`
}

func (m *ChannelOpenUpdate) Reset()                    { *m = ChannelOpenUpdate{} }
func (m *ChannelOpenUpdate) String() string            { return proto.CompactTextString(m) }
func (*ChannelOpenUpdate) ProtoMessage()               {}
func (*ChannelOpenUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *ChannelOpenUpdate) GetChannelPoint() *ChannelPoint {
	if m != nil {
		return m.ChannelPoint
	}
	return nil
}

type ChannelCloseUpdate struct {
	ClosingTxid []byte `protobuf:"bytes,1,opt,name=closing_txid,proto3" json:"closing_txid,omitempty"`
	Success     bool   `protobuf:"varint,2,opt,name=success" json:"success,omitempty"`
}

func (m *ChannelCloseUpdate) Reset()                    { *m = ChannelCloseUpdate{} }
func (m *ChannelCloseUpdate) String() string            { return proto.CompactTextString(m) }
func (*ChannelCloseUpdate) ProtoMessage()               {}
func (*ChannelCloseUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *ChannelCloseUpdate) GetClosingTxid() []byte {
	if m != nil {
		return m.ClosingTxid
	}
	return nil
}

func (m *ChannelCloseUpdate) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type CloseChannelRequest struct {
	// *
	// The outpoint (txid:index) of the funding transaction. With this value, Bob
	// will be able to generate a signature for Alice's version of the commitment
	// transaction.
	ChannelPoint *ChannelPoint `protobuf:"bytes,1,opt,name=channel_point,json=channelPoint" json:"channel_point,omitempty"`
	// / If true, then the channel will be closed forcibly. This means the current commitment transaction will be signed and broadcast.
	Force bool `protobuf:"varint,2,opt,name=force" json:"force,omitempty"`
}

func (m *CloseChannelRequest) Reset()                    { *m = CloseChannelRequest{} }
func (m *CloseChannelRequest) String() string            { return proto.CompactTextString(m) }
func (*CloseChannelRequest) ProtoMessage()               {}
func (*CloseChannelRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *CloseChannelRequest) GetChannelPoint() *ChannelPoint {
	if m != nil {
		return m.ChannelPoint
	}
	return nil
}

func (m *CloseChannelRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

type CloseStatusUpdate struct {
	// Types that are valid to be assigned to Update:
	//	*CloseStatusUpdate_ClosePending
	//	*CloseStatusUpdate_Confirmation
	//	*CloseStatusUpdate_ChanClose
	Update isCloseStatusUpdate_Update `protobuf_oneof:"update"`
}

func (m *CloseStatusUpdate) Reset()                    { *m = CloseStatusUpdate{} }
func (m *CloseStatusUpdate) String() string            { return proto.CompactTextString(m) }
func (*CloseStatusUpdate) ProtoMessage()               {}
func (*CloseStatusUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

type isCloseStatusUpdate_Update interface {
	isCloseStatusUpdate_Update()
}

type CloseStatusUpdate_ClosePending struct {
	ClosePending *PendingUpdate `protobuf:"bytes,1,opt,name=close_pending,oneof"`
}
type CloseStatusUpdate_Confirmation struct {
	Confirmation *ConfirmationUpdate `protobuf:"bytes,2,opt,name=confirmation,oneof"`
}
type CloseStatusUpdate_ChanClose struct {
	ChanClose *ChannelCloseUpdate `protobuf:"bytes,3,opt,name=chan_close,oneof"`
}

func (*CloseStatusUpdate_ClosePending) isCloseStatusUpdate_Update() {}
func (*CloseStatusUpdate_Confirmation) isCloseStatusUpdate_Update() {}
func (*CloseStatusUpdate_ChanClose) isCloseStatusUpdate_Update()    {}

func (m *CloseStatusUpdate) GetUpdate() isCloseStatusUpdate_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *CloseStatusUpdate) GetClosePending() *PendingUpdate {
	if x, ok := m.GetUpdate().(*CloseStatusUpdate_ClosePending); ok {
		return x.ClosePending
	}
	return nil
}

func (m *CloseStatusUpdate) GetConfirmation() *ConfirmationUpdate {
	if x, ok := m.GetUpdate().(*CloseStatusUpdate_Confirmation); ok {
		return x.Confirmation
	}
	return nil
}

func (m *CloseStatusUpdate) GetChanClose() *ChannelCloseUpdate {
	if x, ok := m.GetUpdate().(*CloseStatusUpdate_ChanClose); ok {
		return x.ChanClose
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CloseStatusUpdate) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CloseStatusUpdate_OneofMarshaler, _CloseStatusUpdate_OneofUnmarshaler, _CloseStatusUpdate_OneofSizer, []interface{}{
		(*CloseStatusUpdate_ClosePending)(nil),
		(*CloseStatusUpdate_Confirmation)(nil),
		(*CloseStatusUpdate_ChanClose)(nil),
	}
}

func _CloseStatusUpdate_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CloseStatusUpdate)
	// update
	switch x := m.Update.(type) {
	case *CloseStatusUpdate_ClosePending:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClosePending); err != nil {
			return err
		}
	case *CloseStatusUpdate_Confirmation:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Confirmation); err != nil {
			return err
		}
	case *CloseStatusUpdate_ChanClose:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ChanClose); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CloseStatusUpdate.Update has unexpected type %T", x)
	}
	return nil
}

func _CloseStatusUpdate_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CloseStatusUpdate)
	switch tag {
	case 1: // update.close_pending
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PendingUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &CloseStatusUpdate_ClosePending{msg}
		return true, err
	case 2: // update.confirmation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConfirmationUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &CloseStatusUpdate_Confirmation{msg}
		return true, err
	case 3: // update.chan_close
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChannelCloseUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &CloseStatusUpdate_ChanClose{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CloseStatusUpdate_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CloseStatusUpdate)
	// update
	switch x := m.Update.(type) {
	case *CloseStatusUpdate_ClosePending:
		s := proto.Size(x.ClosePending)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CloseStatusUpdate_Confirmation:
		s := proto.Size(x.Confirmation)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CloseStatusUpdate_ChanClose:
		s := proto.Size(x.ChanClose)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PendingUpdate struct {
	Txid        []byte `protobuf:"bytes,1,opt,name=txid,proto3" json:"txid,omitempty"`
	OutputIndex uint32 `protobuf:"varint,2,opt,name=output_index" json:"output_index,omitempty"`
}

func (m *PendingUpdate) Reset()                    { *m = PendingUpdate{} }
func (m *PendingUpdate) String() string            { return proto.CompactTextString(m) }
func (*PendingUpdate) ProtoMessage()               {}
func (*PendingUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *PendingUpdate) GetTxid() []byte {
	if m != nil {
		return m.Txid
	}
	return nil
}

func (m *PendingUpdate) GetOutputIndex() uint32 {
	if m != nil {
		return m.OutputIndex
	}
	return 0
}

type OpenChannelRequest struct {
	// / The peer_id of the node to open a channel with
	TargetPeerId int32 `protobuf:"varint,1,opt,name=target_peer_id" json:"target_peer_id,omitempty"`
	// / The pubkey of the node to open a channel with
	NodePubkey []byte `protobuf:"bytes,2,opt,name=node_pubkey,proto3" json:"node_pubkey,omitempty"`
	// / The hex encorded pubkey of the node to open a channel with
	NodePubkeyString string `protobuf:"bytes,3,opt,name=node_pubkey_string" json:"node_pubkey_string,omitempty"`
	// / The number of satoshis the wallet should commit to the channel
	LocalFundingAmount int64 `protobuf:"varint,4,opt,name=local_funding_amount" json:"local_funding_amount,omitempty"`
	// / The number of satoshis to push to the remote side as part of the initial commitment state
	PushSat int64 `protobuf:"varint,5,opt,name=push_sat" json:"push_sat,omitempty"`
}

func (m *OpenChannelRequest) Reset()                    { *m = OpenChannelRequest{} }
func (m *OpenChannelRequest) String() string            { return proto.CompactTextString(m) }
func (*OpenChannelRequest) ProtoMessage()               {}
func (*OpenChannelRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *OpenChannelRequest) GetTargetPeerId() int32 {
	if m != nil {
		return m.TargetPeerId
	}
	return 0
}

func (m *OpenChannelRequest) GetNodePubkey() []byte {
	if m != nil {
		return m.NodePubkey
	}
	return nil
}

func (m *OpenChannelRequest) GetNodePubkeyString() string {
	if m != nil {
		return m.NodePubkeyString
	}
	return ""
}

func (m *OpenChannelRequest) GetLocalFundingAmount() int64 {
	if m != nil {
		return m.LocalFundingAmount
	}
	return 0
}

func (m *OpenChannelRequest) GetPushSat() int64 {
	if m != nil {
		return m.PushSat
	}
	return 0
}

type OpenStatusUpdate struct {
	// Types that are valid to be assigned to Update:
	//	*OpenStatusUpdate_ChanPending
	//	*OpenStatusUpdate_Confirmation
	//	*OpenStatusUpdate_ChanOpen
	Update isOpenStatusUpdate_Update `protobuf_oneof:"update"`
}

func (m *OpenStatusUpdate) Reset()                    { *m = OpenStatusUpdate{} }
func (m *OpenStatusUpdate) String() string            { return proto.CompactTextString(m) }
func (*OpenStatusUpdate) ProtoMessage()               {}
func (*OpenStatusUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

type isOpenStatusUpdate_Update interface {
	isOpenStatusUpdate_Update()
}

type OpenStatusUpdate_ChanPending struct {
	ChanPending *PendingUpdate `protobuf:"bytes,1,opt,name=chan_pending,oneof"`
}
type OpenStatusUpdate_Confirmation struct {
	Confirmation *ConfirmationUpdate `protobuf:"bytes,2,opt,name=confirmation,oneof"`
}
type OpenStatusUpdate_ChanOpen struct {
	ChanOpen *ChannelOpenUpdate `protobuf:"bytes,3,opt,name=chan_open,oneof"`
}

func (*OpenStatusUpdate_ChanPending) isOpenStatusUpdate_Update()  {}
func (*OpenStatusUpdate_Confirmation) isOpenStatusUpdate_Update() {}
func (*OpenStatusUpdate_ChanOpen) isOpenStatusUpdate_Update()     {}

func (m *OpenStatusUpdate) GetUpdate() isOpenStatusUpdate_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *OpenStatusUpdate) GetChanPending() *PendingUpdate {
	if x, ok := m.GetUpdate().(*OpenStatusUpdate_ChanPending); ok {
		return x.ChanPending
	}
	return nil
}

func (m *OpenStatusUpdate) GetConfirmation() *ConfirmationUpdate {
	if x, ok := m.GetUpdate().(*OpenStatusUpdate_Confirmation); ok {
		return x.Confirmation
	}
	return nil
}

func (m *OpenStatusUpdate) GetChanOpen() *ChannelOpenUpdate {
	if x, ok := m.GetUpdate().(*OpenStatusUpdate_ChanOpen); ok {
		return x.ChanOpen
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OpenStatusUpdate) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _OpenStatusUpdate_OneofMarshaler, _OpenStatusUpdate_OneofUnmarshaler, _OpenStatusUpdate_OneofSizer, []interface{}{
		(*OpenStatusUpdate_ChanPending)(nil),
		(*OpenStatusUpdate_Confirmation)(nil),
		(*OpenStatusUpdate_ChanOpen)(nil),
	}
}

func _OpenStatusUpdate_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OpenStatusUpdate)
	// update
	switch x := m.Update.(type) {
	case *OpenStatusUpdate_ChanPending:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ChanPending); err != nil {
			return err
		}
	case *OpenStatusUpdate_Confirmation:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Confirmation); err != nil {
			return err
		}
	case *OpenStatusUpdate_ChanOpen:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ChanOpen); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("OpenStatusUpdate.Update has unexpected type %T", x)
	}
	return nil
}

func _OpenStatusUpdate_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OpenStatusUpdate)
	switch tag {
	case 1: // update.chan_pending
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PendingUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &OpenStatusUpdate_ChanPending{msg}
		return true, err
	case 2: // update.confirmation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConfirmationUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &OpenStatusUpdate_Confirmation{msg}
		return true, err
	case 3: // update.chan_open
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChannelOpenUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &OpenStatusUpdate_ChanOpen{msg}
		return true, err
	default:
		return false, nil
	}
}

func _OpenStatusUpdate_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*OpenStatusUpdate)
	// update
	switch x := m.Update.(type) {
	case *OpenStatusUpdate_ChanPending:
		s := proto.Size(x.ChanPending)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *OpenStatusUpdate_Confirmation:
		s := proto.Size(x.Confirmation)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *OpenStatusUpdate_ChanOpen:
		s := proto.Size(x.ChanOpen)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PendingChannelRequest struct {
}

func (m *PendingChannelRequest) Reset()                    { *m = PendingChannelRequest{} }
func (m *PendingChannelRequest) String() string            { return proto.CompactTextString(m) }
func (*PendingChannelRequest) ProtoMessage()               {}
func (*PendingChannelRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

type PendingChannelResponse struct {
	// / The balance in satoshis encumbered in pending channels
	TotalLimboBalance int64 `protobuf:"varint,1,opt,name=total_limbo_balance" json:"total_limbo_balance,omitempty"`
	// / Channels pending opening
	PendingOpenChannels []*PendingChannelResponse_PendingOpenChannel `protobuf:"bytes,2,rep,name=pending_open_channels" json:"pending_open_channels,omitempty"`
	// / Channels pending closing
	PendingClosingChannels []*PendingChannelResponse_ClosedChannel `protobuf:"bytes,3,rep,name=pending_closing_channels" json:"pending_closing_channels,omitempty"`
	// / Channels pending force closing
	PendingForceClosingChannels []*PendingChannelResponse_ForceClosedChannel `protobuf:"bytes,4,rep,name=pending_force_closing_channels" json:"pending_force_closing_channels,omitempty"`
}

func (m *PendingChannelResponse) Reset()                    { *m = PendingChannelResponse{} }
func (m *PendingChannelResponse) String() string            { return proto.CompactTextString(m) }
func (*PendingChannelResponse) ProtoMessage()               {}
func (*PendingChannelResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *PendingChannelResponse) GetTotalLimboBalance() int64 {
	if m != nil {
		return m.TotalLimboBalance
	}
	return 0
}

func (m *PendingChannelResponse) GetPendingOpenChannels() []*PendingChannelResponse_PendingOpenChannel {
	if m != nil {
		return m.PendingOpenChannels
	}
	return nil
}

func (m *PendingChannelResponse) GetPendingClosingChannels() []*PendingChannelResponse_ClosedChannel {
	if m != nil {
		return m.PendingClosingChannels
	}
	return nil
}

func (m *PendingChannelResponse) GetPendingForceClosingChannels() []*PendingChannelResponse_ForceClosedChannel {
	if m != nil {
		return m.PendingForceClosingChannels
	}
	return nil
}

type PendingChannelResponse_PendingChannel struct {
	RemoteNodePub string `protobuf:"bytes,1,opt,name=remote_node_pub" json:"remote_node_pub,omitempty"`
	ChannelPoint  string `protobuf:"bytes,2,opt,name=channel_point" json:"channel_point,omitempty"`
	Capacity      int64  `protobuf:"varint,3,opt,name=capacity" json:"capacity,omitempty"`
	LocalBalance  int64  `protobuf:"varint,4,opt,name=local_balance" json:"local_balance,omitempty"`
	RemoteBalance int64  `protobuf:"varint,5,opt,name=remote_balance" json:"remote_balance,omitempty"`
}

func (m *PendingChannelResponse_PendingChannel) Reset()         { *m = PendingChannelResponse_PendingChannel{} }
func (m *PendingChannelResponse_PendingChannel) String() string { return proto.CompactTextString(m) }
func (*PendingChannelResponse_PendingChannel) ProtoMessage()    {}
func (*PendingChannelResponse_PendingChannel) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{40, 0}
}

func (m *PendingChannelResponse_PendingChannel) GetRemoteNodePub() string {
	if m != nil {
		return m.RemoteNodePub
	}
	return ""
}

func (m *PendingChannelResponse_PendingChannel) GetChannelPoint() string {
	if m != nil {
		return m.ChannelPoint
	}
	return ""
}

func (m *PendingChannelResponse_PendingChannel) GetCapacity() int64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *PendingChannelResponse_PendingChannel) GetLocalBalance() int64 {
	if m != nil {
		return m.LocalBalance
	}
	return 0
}

func (m *PendingChannelResponse_PendingChannel) GetRemoteBalance() int64 {
	if m != nil {
		return m.RemoteBalance
	}
	return 0
}

type PendingChannelResponse_PendingOpenChannel struct {
	// / The pending channel
	Channel *PendingChannelResponse_PendingChannel `protobuf:"bytes,1,opt,name=channel" json:"channel,omitempty"`
	// / The height at which this channel will be confirmed
	ConfirmationHeight uint32 `protobuf:"varint,2,opt,name=confirmation_height" json:"confirmation_height,omitempty"`
	// / The number of blocks until this channel is open
	BlocksTillOpen uint32 `protobuf:"varint,3,opt,name=blocks_till_open" json:"blocks_till_open,omitempty"`
	// *
	// The amount calculated to be paid in fees for the current set of
	// commitment transactions. The fee amount is persisted with the channel
	// in order to allow the fee amount to be removed and recalculated with
	// each channel state update, including updates that happen after a system
	// restart.
	CommitFee int64 `protobuf:"varint,4,opt,name=commit_fee" json:"commit_fee,omitempty"`
	// / The weight of the commitment transaction
	CommitWeight int64 `protobuf:"varint,5,opt,name=commit_weight" json:"commit_weight,omitempty"`
	// *
	// The required number of satoshis per kilo-weight that the requester will
	// pay at all times, for both the funding transaction and commitment
	// transaction. This value can later be updated once the channel is open.
	FeePerKw int64 `protobuf:"varint,6,opt,name=fee_per_kw" json:"fee_per_kw,omitempty"`
}

func (m *PendingChannelResponse_PendingOpenChannel) Reset() {
	*m = PendingChannelResponse_PendingOpenChannel{}
}
func (m *PendingChannelResponse_PendingOpenChannel) String() string { return proto.CompactTextString(m) }
func (*PendingChannelResponse_PendingOpenChannel) ProtoMessage()    {}
func (*PendingChannelResponse_PendingOpenChannel) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{40, 1}
}

func (m *PendingChannelResponse_PendingOpenChannel) GetChannel() *PendingChannelResponse_PendingChannel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *PendingChannelResponse_PendingOpenChannel) GetConfirmationHeight() uint32 {
	if m != nil {
		return m.ConfirmationHeight
	}
	return 0
}

func (m *PendingChannelResponse_PendingOpenChannel) GetBlocksTillOpen() uint32 {
	if m != nil {
		return m.BlocksTillOpen
	}
	return 0
}

func (m *PendingChannelResponse_PendingOpenChannel) GetCommitFee() int64 {
	if m != nil {
		return m.CommitFee
	}
	return 0
}

func (m *PendingChannelResponse_PendingOpenChannel) GetCommitWeight() int64 {
	if m != nil {
		return m.CommitWeight
	}
	return 0
}

func (m *PendingChannelResponse_PendingOpenChannel) GetFeePerKw() int64 {
	if m != nil {
		return m.FeePerKw
	}
	return 0
}

type PendingChannelResponse_ClosedChannel struct {
	// / The pending channel to be closed
	Channel *PendingChannelResponse_PendingChannel `protobuf:"bytes,1,opt,name=channel" json:"channel,omitempty"`
	// / The transaction id of the closing transaction
	ClosingTxid string `protobuf:"bytes,2,opt,name=closing_txid" json:"closing_txid,omitempty"`
}

func (m *PendingChannelResponse_ClosedChannel) Reset()         { *m = PendingChannelResponse_ClosedChannel{} }
func (m *PendingChannelResponse_ClosedChannel) String() string { return proto.CompactTextString(m) }
func (*PendingChannelResponse_ClosedChannel) ProtoMessage()    {}
func (*PendingChannelResponse_ClosedChannel) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{40, 2}
}

func (m *PendingChannelResponse_ClosedChannel) GetChannel() *PendingChannelResponse_PendingChannel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *PendingChannelResponse_ClosedChannel) GetClosingTxid() string {
	if m != nil {
		return m.ClosingTxid
	}
	return ""
}

type PendingChannelResponse_ForceClosedChannel struct {
	// / The pending channel to be force closed
	Channel *PendingChannelResponse_PendingChannel `protobuf:"bytes,1,opt,name=channel" json:"channel,omitempty"`
	// / The transaction id of the closing transaction
	ClosingTxid string `protobuf:"bytes,2,opt,name=closing_txid" json:"closing_txid,omitempty"`
	// / The balance in satoshis encumbered in this pending channel
	LimboBalance int64 `protobuf:"varint,3,opt,name=limbo_balance" json:"limbo_balance,omitempty"`
	// / The height at which funds can be sweeped into the wallet
	MaturityHeight uint32 `protobuf:"varint,4,opt,name=maturity_height" json:"maturity_height,omitempty"`
	// / Remaining # of blocks until funds can be sweeped into the wallet
	BlocksTilMaturity uint32 `protobuf:"varint,5,opt,name=blocks_til_maturity" json:"blocks_til_maturity,omitempty"`
}

func (m *PendingChannelResponse_ForceClosedChannel) Reset() {
	*m = PendingChannelResponse_ForceClosedChannel{}
}
func (m *PendingChannelResponse_ForceClosedChannel) String() string { return proto.CompactTextString(m) }
func (*PendingChannelResponse_ForceClosedChannel) ProtoMessage()    {}
func (*PendingChannelResponse_ForceClosedChannel) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{40, 3}
}

func (m *PendingChannelResponse_ForceClosedChannel) GetChannel() *PendingChannelResponse_PendingChannel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *PendingChannelResponse_ForceClosedChannel) GetClosingTxid() string {
	if m != nil {
		return m.ClosingTxid
	}
	return ""
}

func (m *PendingChannelResponse_ForceClosedChannel) GetLimboBalance() int64 {
	if m != nil {
		return m.LimboBalance
	}
	return 0
}

func (m *PendingChannelResponse_ForceClosedChannel) GetMaturityHeight() uint32 {
	if m != nil {
		return m.MaturityHeight
	}
	return 0
}

func (m *PendingChannelResponse_ForceClosedChannel) GetBlocksTilMaturity() uint32 {
	if m != nil {
		return m.BlocksTilMaturity
	}
	return 0
}

type WalletBalanceRequest struct {
	// / If only witness outputs should be considered when calculating the wallet's balance
	WitnessOnly bool `protobuf:"varint,1,opt,name=witness_only,json=witnessOnly" json:"witness_only,omitempty"`
}

func (m *WalletBalanceRequest) Reset()                    { *m = WalletBalanceRequest{} }
func (m *WalletBalanceRequest) String() string            { return proto.CompactTextString(m) }
func (*WalletBalanceRequest) ProtoMessage()               {}
func (*WalletBalanceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *WalletBalanceRequest) GetWitnessOnly() bool {
	if m != nil {
		return m.WitnessOnly
	}
	return false
}

type WalletBalanceResponse struct {
	// / The balance of the wallet
	Balance int64 `protobuf:"varint,1,opt,name=balance" json:"balance,omitempty"`
}

func (m *WalletBalanceResponse) Reset()                    { *m = WalletBalanceResponse{} }
func (m *WalletBalanceResponse) String() string            { return proto.CompactTextString(m) }
func (*WalletBalanceResponse) ProtoMessage()               {}
func (*WalletBalanceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

func (m *WalletBalanceResponse) GetBalance() int64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

type ChannelBalanceRequest struct {
}

func (m *ChannelBalanceRequest) Reset()                    { *m = ChannelBalanceRequest{} }
func (m *ChannelBalanceRequest) String() string            { return proto.CompactTextString(m) }
func (*ChannelBalanceRequest) ProtoMessage()               {}
func (*ChannelBalanceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

type ChannelBalanceResponse struct {
	// / Sum of channels balances denominated in satoshis
	Balance int64 `protobuf:"varint,1,opt,name=balance" json:"balance,omitempty"`
}

func (m *ChannelBalanceResponse) Reset()                    { *m = ChannelBalanceResponse{} }
func (m *ChannelBalanceResponse) String() string            { return proto.CompactTextString(m) }
func (*ChannelBalanceResponse) ProtoMessage()               {}
func (*ChannelBalanceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *ChannelBalanceResponse) GetBalance() int64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

type QueryRoutesRequest struct {
	// / The 33-byte hex-encoded public key for the payment destination
	PubKey string `protobuf:"bytes,1,opt,name=pub_key,json=pubKey" json:"pub_key,omitempty"`
	// / The amount to send expressed in satoshis
	Amt int64 `protobuf:"varint,2,opt,name=amt" json:"amt,omitempty"`
}

func (m *QueryRoutesRequest) Reset()                    { *m = QueryRoutesRequest{} }
func (m *QueryRoutesRequest) String() string            { return proto.CompactTextString(m) }
func (*QueryRoutesRequest) ProtoMessage()               {}
func (*QueryRoutesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

func (m *QueryRoutesRequest) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *QueryRoutesRequest) GetAmt() int64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

type QueryRoutesResponse struct {
	Routes []*Route `protobuf:"bytes,1,rep,name=routes" json:"routes,omitempty"`
}

func (m *QueryRoutesResponse) Reset()                    { *m = QueryRoutesResponse{} }
func (m *QueryRoutesResponse) String() string            { return proto.CompactTextString(m) }
func (*QueryRoutesResponse) ProtoMessage()               {}
func (*QueryRoutesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

func (m *QueryRoutesResponse) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

type Hop struct {
	// *
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChanId       uint64 `protobuf:"varint,1,opt,name=chan_id" json:"chan_id,omitempty"`
	ChanCapacity int64  `protobuf:"varint,2,opt,name=chan_capacity" json:"chan_capacity,omitempty"`
	AmtToForward int64  `protobuf:"varint,3,opt,name=amt_to_forward" json:"amt_to_forward,omitempty"`
	Fee          int64  `protobuf:"varint,4,opt,name=fee" json:"fee,omitempty"`
	Expiry       uint32 `protobuf:"varint,5,opt,name=expiry" json:"expiry,omitempty"`
}

func (m *Hop) Reset()                    { *m = Hop{} }
func (m *Hop) String() string            { return proto.CompactTextString(m) }
func (*Hop) ProtoMessage()               {}
func (*Hop) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{47} }

func (m *Hop) GetChanId() uint64 {
	if m != nil {
		return m.ChanId
	}
	return 0
}

func (m *Hop) GetChanCapacity() int64 {
	if m != nil {
		return m.ChanCapacity
	}
	return 0
}

func (m *Hop) GetAmtToForward() int64 {
	if m != nil {
		return m.AmtToForward
	}
	return 0
}

func (m *Hop) GetFee() int64 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *Hop) GetExpiry() uint32 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

// *
// A path through the channel graph which runs over one or more channels in
// succession. This struct carries all the information required to craft the
// Sphinx onion packet, and send the payment along the first hop in the path. A
// route is only selected as valid if all the channels have sufficient capacity to
// carry the initial payment amount after fees are accounted for.
type Route struct {
	// *
	// The cumulative (final) time lock across the entire route.  This is the CLTV
	// value that should be extended to the first hop in the route. All other hops
	// will decrement the time-lock as advertised, leaving enough time for all
	// hops to wait for or present the payment preimage to complete the payment.
	TotalTimeLock uint32 `protobuf:"varint,1,opt,name=total_time_lock" json:"total_time_lock,omitempty"`
	// *
	// The sum of the fees paid at each hop within the final route.  In the case
	// of a one-hop payment, this value will be zero as we don't need to pay a fee
	// it ourself.
	TotalFees int64 `protobuf:"varint,2,opt,name=total_fees" json:"total_fees,omitempty"`
	// *
	// The total amount of funds required to complete a payment over this route.
	// This value includes the cumulative fees at each hop. As a result, the HTLC
	// extended to the first-hop in the route will need to have at least this many
	// satoshis, otherwise the route will fail at an intermediate node due to an
	// insufficient amount of fees.
	TotalAmt int64 `protobuf:"varint,3,opt,name=total_amt" json:"total_amt,omitempty"`
	// *
	// Contains details concerning the specific forwarding details at each hop.
	Hops []*Hop `protobuf:"bytes,4,rep,name=hops" json:"hops,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{48} }

func (m *Route) GetTotalTimeLock() uint32 {
	if m != nil {
		return m.TotalTimeLock
	}
	return 0
}

func (m *Route) GetTotalFees() int64 {
	if m != nil {
		return m.TotalFees
	}
	return 0
}

func (m *Route) GetTotalAmt() int64 {
	if m != nil {
		return m.TotalAmt
	}
	return 0
}

func (m *Route) GetHops() []*Hop {
	if m != nil {
		return m.Hops
	}
	return nil
}

type NodeInfoRequest struct {
	// / The 33-byte hex-encoded compressed public of the target node
	PubKey string `protobuf:"bytes,1,opt,name=pub_key,json=pubKey" json:"pub_key,omitempty"`
}

func (m *NodeInfoRequest) Reset()                    { *m = NodeInfoRequest{} }
func (m *NodeInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*NodeInfoRequest) ProtoMessage()               {}
func (*NodeInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{49} }

func (m *NodeInfoRequest) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

type NodeInfo struct {
	// *
	// An individual vertex/node within the channel graph. A node is
	// connected to other nodes by one or more channel edges emanating from it. As
	// the graph is directed, a node will also have an incoming edge attached to
	// it for each outgoing edge.
	Node          *LightningNode `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
	NumChannels   uint32         `protobuf:"varint,2,opt,name=num_channels" json:"num_channels,omitempty"`
	TotalCapacity int64          `protobuf:"varint,3,opt,name=total_capacity" json:"total_capacity,omitempty"`
}

func (m *NodeInfo) Reset()                    { *m = NodeInfo{} }
func (m *NodeInfo) String() string            { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()               {}
func (*NodeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{50} }

func (m *NodeInfo) GetNode() *LightningNode {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *NodeInfo) GetNumChannels() uint32 {
	if m != nil {
		return m.NumChannels
	}
	return 0
}

func (m *NodeInfo) GetTotalCapacity() int64 {
	if m != nil {
		return m.TotalCapacity
	}
	return 0
}

// *
// An individual vertex/node within the channel graph. A node is
// connected to other nodes by one or more channel edges emanating from it. As the
// graph is directed, a node will also have an incoming edge attached to it for
// each outgoing edge.
type LightningNode struct {
	LastUpdate uint32         `protobuf:"varint,1,opt,name=last_update" json:"last_update,omitempty"`
	PubKey     string         `protobuf:"bytes,2,opt,name=pub_key" json:"pub_key,omitempty"`
	Alias      string         `protobuf:"bytes,3,opt,name=alias" json:"alias,omitempty"`
	Addresses  []*NodeAddress `protobuf:"bytes,4,rep,name=addresses" json:"addresses,omitempty"`
}

func (m *LightningNode) Reset()                    { *m = LightningNode{} }
func (m *LightningNode) String() string            { return proto.CompactTextString(m) }
func (*LightningNode) ProtoMessage()               {}
func (*LightningNode) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{51} }

func (m *LightningNode) GetLastUpdate() uint32 {
	if m != nil {
		return m.LastUpdate
	}
	return 0
}

func (m *LightningNode) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *LightningNode) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *LightningNode) GetAddresses() []*NodeAddress {
	if m != nil {
		return m.Addresses
	}
	return nil
}

type NodeAddress struct {
	Network string `protobuf:"bytes,1,opt,name=network" json:"network,omitempty"`
	Addr    string `protobuf:"bytes,2,opt,name=addr" json:"addr,omitempty"`
}

func (m *NodeAddress) Reset()                    { *m = NodeAddress{} }
func (m *NodeAddress) String() string            { return proto.CompactTextString(m) }
func (*NodeAddress) ProtoMessage()               {}
func (*NodeAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{52} }

func (m *NodeAddress) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *NodeAddress) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type RoutingPolicy struct {
	TimeLockDelta    uint32 `protobuf:"varint,1,opt,name=time_lock_delta" json:"time_lock_delta,omitempty"`
	MinHtlc          int64  `protobuf:"varint,2,opt,name=min_htlc" json:"min_htlc,omitempty"`
	FeeBaseMsat      int64  `protobuf:"varint,3,opt,name=fee_base_msat" json:"fee_base_msat,omitempty"`
	FeeRateMilliMsat int64  `protobuf:"varint,4,opt,name=fee_rate_milli_msat" json:"fee_rate_milli_msat,omitempty"`
}

func (m *RoutingPolicy) Reset()                    { *m = RoutingPolicy{} }
func (m *RoutingPolicy) String() string            { return proto.CompactTextString(m) }
func (*RoutingPolicy) ProtoMessage()               {}
func (*RoutingPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{53} }

func (m *RoutingPolicy) GetTimeLockDelta() uint32 {
	if m != nil {
		return m.TimeLockDelta
	}
	return 0
}

func (m *RoutingPolicy) GetMinHtlc() int64 {
	if m != nil {
		return m.MinHtlc
	}
	return 0
}

func (m *RoutingPolicy) GetFeeBaseMsat() int64 {
	if m != nil {
		return m.FeeBaseMsat
	}
	return 0
}

func (m *RoutingPolicy) GetFeeRateMilliMsat() int64 {
	if m != nil {
		return m.FeeRateMilliMsat
	}
	return 0
}

// *
// A fully authenticated channel along with all its unique attributes.
// Once an authenticated channel announcement has been processed on the network,
// then a instance of ChannelEdgeInfo encapsulating the channels attributes is
// stored. The other portions relevant to routing policy of a channel are stored
// within a ChannelEdgePolicy for each direction of the channel.
type ChannelEdge struct {
	// *
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChannelId   uint64         `protobuf:"varint,1,opt,name=channel_id" json:"channel_id,omitempty"`
	ChanPoint   string         `protobuf:"bytes,2,opt,name=chan_point" json:"chan_point,omitempty"`
	LastUpdate  uint32         `protobuf:"varint,3,opt,name=last_update" json:"last_update,omitempty"`
	Node1Pub    string         `protobuf:"bytes,4,opt,name=node1_pub" json:"node1_pub,omitempty"`
	Node2Pub    string         `protobuf:"bytes,5,opt,name=node2_pub" json:"node2_pub,omitempty"`
	Capacity    int64          `protobuf:"varint,6,opt,name=capacity" json:"capacity,omitempty"`
	Node1Policy *RoutingPolicy `protobuf:"bytes,7,opt,name=node1_policy" json:"node1_policy,omitempty"`
	Node2Policy *RoutingPolicy `protobuf:"bytes,8,opt,name=node2_policy" json:"node2_policy,omitempty"`
}

func (m *ChannelEdge) Reset()                    { *m = ChannelEdge{} }
func (m *ChannelEdge) String() string            { return proto.CompactTextString(m) }
func (*ChannelEdge) ProtoMessage()               {}
func (*ChannelEdge) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{54} }

func (m *ChannelEdge) GetChannelId() uint64 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ChannelEdge) GetChanPoint() string {
	if m != nil {
		return m.ChanPoint
	}
	return ""
}

func (m *ChannelEdge) GetLastUpdate() uint32 {
	if m != nil {
		return m.LastUpdate
	}
	return 0
}

func (m *ChannelEdge) GetNode1Pub() string {
	if m != nil {
		return m.Node1Pub
	}
	return ""
}

func (m *ChannelEdge) GetNode2Pub() string {
	if m != nil {
		return m.Node2Pub
	}
	return ""
}

func (m *ChannelEdge) GetCapacity() int64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *ChannelEdge) GetNode1Policy() *RoutingPolicy {
	if m != nil {
		return m.Node1Policy
	}
	return nil
}

func (m *ChannelEdge) GetNode2Policy() *RoutingPolicy {
	if m != nil {
		return m.Node2Policy
	}
	return nil
}

type ChannelGraphRequest struct {
}

func (m *ChannelGraphRequest) Reset()                    { *m = ChannelGraphRequest{} }
func (m *ChannelGraphRequest) String() string            { return proto.CompactTextString(m) }
func (*ChannelGraphRequest) ProtoMessage()               {}
func (*ChannelGraphRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{55} }

// / Returns a new instance of the directed channel graph.
type ChannelGraph struct {
	// / The list of `LightningNode`s in this channel graph
	Nodes []*LightningNode `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`
	// / The list of `ChannelEdge`s in this channel graph
	Edges []*ChannelEdge `protobuf:"bytes,2,rep,name=edges" json:"edges,omitempty"`
}

func (m *ChannelGraph) Reset()                    { *m = ChannelGraph{} }
func (m *ChannelGraph) String() string            { return proto.CompactTextString(m) }
func (*ChannelGraph) ProtoMessage()               {}
func (*ChannelGraph) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{56} }

func (m *ChannelGraph) GetNodes() []*LightningNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *ChannelGraph) GetEdges() []*ChannelEdge {
	if m != nil {
		return m.Edges
	}
	return nil
}

type ChanInfoRequest struct {
	// *
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChanId uint64 `protobuf:"varint,1,opt,name=chan_id,json=chanId" json:"chan_id,omitempty"`
}

func (m *ChanInfoRequest) Reset()                    { *m = ChanInfoRequest{} }
func (m *ChanInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*ChanInfoRequest) ProtoMessage()               {}
func (*ChanInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{57} }

func (m *ChanInfoRequest) GetChanId() uint64 {
	if m != nil {
		return m.ChanId
	}
	return 0
}

type NetworkInfoRequest struct {
}

func (m *NetworkInfoRequest) Reset()                    { *m = NetworkInfoRequest{} }
func (m *NetworkInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*NetworkInfoRequest) ProtoMessage()               {}
func (*NetworkInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{58} }

type NetworkInfo struct {
	GraphDiameter        uint32  `protobuf:"varint,1,opt,name=graph_diameter" json:"graph_diameter,omitempty"`
	AvgOutDegree         float64 `protobuf:"fixed64,2,opt,name=avg_out_degree" json:"avg_out_degree,omitempty"`
	MaxOutDegree         uint32  `protobuf:"varint,3,opt,name=max_out_degree" json:"max_out_degree,omitempty"`
	NumNodes             uint32  `protobuf:"varint,4,opt,name=num_nodes" json:"num_nodes,omitempty"`
	NumChannels          uint32  `protobuf:"varint,5,opt,name=num_channels" json:"num_channels,omitempty"`
	TotalNetworkCapacity int64   `protobuf:"varint,6,opt,name=total_network_capacity" json:"total_network_capacity,omitempty"`
	AvgChannelSize       float64 `protobuf:"fixed64,7,opt,name=avg_channel_size" json:"avg_channel_size,omitempty"`
	MinChannelSize       int64   `protobuf:"varint,8,opt,name=min_channel_size" json:"min_channel_size,omitempty"`
	MaxChannelSize       int64   `protobuf:"varint,9,opt,name=max_channel_size" json:"max_channel_size,omitempty"`
}

func (m *NetworkInfo) Reset()                    { *m = NetworkInfo{} }
func (m *NetworkInfo) String() string            { return proto.CompactTextString(m) }
func (*NetworkInfo) ProtoMessage()               {}
func (*NetworkInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{59} }

func (m *NetworkInfo) GetGraphDiameter() uint32 {
	if m != nil {
		return m.GraphDiameter
	}
	return 0
}

func (m *NetworkInfo) GetAvgOutDegree() float64 {
	if m != nil {
		return m.AvgOutDegree
	}
	return 0
}

func (m *NetworkInfo) GetMaxOutDegree() uint32 {
	if m != nil {
		return m.MaxOutDegree
	}
	return 0
}

func (m *NetworkInfo) GetNumNodes() uint32 {
	if m != nil {
		return m.NumNodes
	}
	return 0
}

func (m *NetworkInfo) GetNumChannels() uint32 {
	if m != nil {
		return m.NumChannels
	}
	return 0
}

func (m *NetworkInfo) GetTotalNetworkCapacity() int64 {
	if m != nil {
		return m.TotalNetworkCapacity
	}
	return 0
}

func (m *NetworkInfo) GetAvgChannelSize() float64 {
	if m != nil {
		return m.AvgChannelSize
	}
	return 0
}

func (m *NetworkInfo) GetMinChannelSize() int64 {
	if m != nil {
		return m.MinChannelSize
	}
	return 0
}

func (m *NetworkInfo) GetMaxChannelSize() int64 {
	if m != nil {
		return m.MaxChannelSize
	}
	return 0
}

type StopRequest struct {
}

func (m *StopRequest) Reset()                    { *m = StopRequest{} }
func (m *StopRequest) String() string            { return proto.CompactTextString(m) }
func (*StopRequest) ProtoMessage()               {}
func (*StopRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{60} }

type StopResponse struct {
}

func (m *StopResponse) Reset()                    { *m = StopResponse{} }
func (m *StopResponse) String() string            { return proto.CompactTextString(m) }
func (*StopResponse) ProtoMessage()               {}
func (*StopResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{61} }

type GraphTopologySubscription struct {
}

func (m *GraphTopologySubscription) Reset()                    { *m = GraphTopologySubscription{} }
func (m *GraphTopologySubscription) String() string            { return proto.CompactTextString(m) }
func (*GraphTopologySubscription) ProtoMessage()               {}
func (*GraphTopologySubscription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{62} }

type GraphTopologyUpdate struct {
	NodeUpdates    []*NodeUpdate          `protobuf:"bytes,1,rep,name=node_updates,json=nodeUpdates" json:"node_updates,omitempty"`
	ChannelUpdates []*ChannelEdgeUpdate   `protobuf:"bytes,2,rep,name=channel_updates,json=channelUpdates" json:"channel_updates,omitempty"`
	ClosedChans    []*ClosedChannelUpdate `protobuf:"bytes,3,rep,name=closed_chans,json=closedChans" json:"closed_chans,omitempty"`
}

func (m *GraphTopologyUpdate) Reset()                    { *m = GraphTopologyUpdate{} }
func (m *GraphTopologyUpdate) String() string            { return proto.CompactTextString(m) }
func (*GraphTopologyUpdate) ProtoMessage()               {}
func (*GraphTopologyUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{63} }

func (m *GraphTopologyUpdate) GetNodeUpdates() []*NodeUpdate {
	if m != nil {
		return m.NodeUpdates
	}
	return nil
}

func (m *GraphTopologyUpdate) GetChannelUpdates() []*ChannelEdgeUpdate {
	if m != nil {
		return m.ChannelUpdates
	}
	return nil
}

func (m *GraphTopologyUpdate) GetClosedChans() []*ClosedChannelUpdate {
	if m != nil {
		return m.ClosedChans
	}
	return nil
}

type NodeUpdate struct {
	Addresses      []string `protobuf:"bytes,1,rep,name=addresses" json:"addresses,omitempty"`
	IdentityKey    string   `protobuf:"bytes,2,opt,name=identity_key,json=identityKey" json:"identity_key,omitempty"`
	GlobalFeatures []byte   `protobuf:"bytes,3,opt,name=global_features,json=globalFeatures,proto3" json:"global_features,omitempty"`
	Alias          string   `protobuf:"bytes,4,opt,name=alias" json:"alias,omitempty"`
}

func (m *NodeUpdate) Reset()                    { *m = NodeUpdate{} }
func (m *NodeUpdate) String() string            { return proto.CompactTextString(m) }
func (*NodeUpdate) ProtoMessage()               {}
func (*NodeUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{64} }

func (m *NodeUpdate) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *NodeUpdate) GetIdentityKey() string {
	if m != nil {
		return m.IdentityKey
	}
	return ""
}

func (m *NodeUpdate) GetGlobalFeatures() []byte {
	if m != nil {
		return m.GlobalFeatures
	}
	return nil
}

func (m *NodeUpdate) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

type ChannelEdgeUpdate struct {
	// *
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChanId          uint64         `protobuf:"varint,1,opt,name=chan_id,json=chanId" json:"chan_id,omitempty"`
	ChanPoint       *ChannelPoint  `protobuf:"bytes,2,opt,name=chan_point,json=chanPoint" json:"chan_point,omitempty"`
	Capacity        int64          `protobuf:"varint,3,opt,name=capacity" json:"capacity,omitempty"`
	RoutingPolicy   *RoutingPolicy `protobuf:"bytes,4,opt,name=routing_policy,json=routingPolicy" json:"routing_policy,omitempty"`
	AdvertisingNode string         `protobuf:"bytes,5,opt,name=advertising_node,json=advertisingNode" json:"advertising_node,omitempty"`
	ConnectingNode  string         `protobuf:"bytes,6,opt,name=connecting_node,json=connectingNode" json:"connecting_node,omitempty"`
}

func (m *ChannelEdgeUpdate) Reset()                    { *m = ChannelEdgeUpdate{} }
func (m *ChannelEdgeUpdate) String() string            { return proto.CompactTextString(m) }
func (*ChannelEdgeUpdate) ProtoMessage()               {}
func (*ChannelEdgeUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{65} }

func (m *ChannelEdgeUpdate) GetChanId() uint64 {
	if m != nil {
		return m.ChanId
	}
	return 0
}

func (m *ChannelEdgeUpdate) GetChanPoint() *ChannelPoint {
	if m != nil {
		return m.ChanPoint
	}
	return nil
}

func (m *ChannelEdgeUpdate) GetCapacity() int64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *ChannelEdgeUpdate) GetRoutingPolicy() *RoutingPolicy {
	if m != nil {
		return m.RoutingPolicy
	}
	return nil
}

func (m *ChannelEdgeUpdate) GetAdvertisingNode() string {
	if m != nil {
		return m.AdvertisingNode
	}
	return ""
}

func (m *ChannelEdgeUpdate) GetConnectingNode() string {
	if m != nil {
		return m.ConnectingNode
	}
	return ""
}

type ClosedChannelUpdate struct {
	// *
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChanId       uint64        `protobuf:"varint,1,opt,name=chan_id,json=chanId" json:"chan_id,omitempty"`
	Capacity     int64         `protobuf:"varint,2,opt,name=capacity" json:"capacity,omitempty"`
	ClosedHeight uint32        `protobuf:"varint,3,opt,name=closed_height,json=closedHeight" json:"closed_height,omitempty"`
	ChanPoint    *ChannelPoint `protobuf:"bytes,4,opt,name=chan_point,json=chanPoint" json:"chan_point,omitempty"`
}

func (m *ClosedChannelUpdate) Reset()                    { *m = ClosedChannelUpdate{} }
func (m *ClosedChannelUpdate) String() string            { return proto.CompactTextString(m) }
func (*ClosedChannelUpdate) ProtoMessage()               {}
func (*ClosedChannelUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{66} }

func (m *ClosedChannelUpdate) GetChanId() uint64 {
	if m != nil {
		return m.ChanId
	}
	return 0
}

func (m *ClosedChannelUpdate) GetCapacity() int64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *ClosedChannelUpdate) GetClosedHeight() uint32 {
	if m != nil {
		return m.ClosedHeight
	}
	return 0
}

func (m *ClosedChannelUpdate) GetChanPoint() *ChannelPoint {
	if m != nil {
		return m.ChanPoint
	}
	return nil
}

type SetAliasRequest struct {
	NewAlias string `protobuf:"bytes,1,opt,name=new_alias,json=newAlias" json:"new_alias,omitempty"`
}

func (m *SetAliasRequest) Reset()                    { *m = SetAliasRequest{} }
func (m *SetAliasRequest) String() string            { return proto.CompactTextString(m) }
func (*SetAliasRequest) ProtoMessage()               {}
func (*SetAliasRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{67} }

func (m *SetAliasRequest) GetNewAlias() string {
	if m != nil {
		return m.NewAlias
	}
	return ""
}

type SetAliasResponse struct {
}

func (m *SetAliasResponse) Reset()                    { *m = SetAliasResponse{} }
func (m *SetAliasResponse) String() string            { return proto.CompactTextString(m) }
func (*SetAliasResponse) ProtoMessage()               {}
func (*SetAliasResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{68} }

type Invoice struct {
	// / An optional memo to attach along with the invoice
	Memo string `protobuf:"bytes,1,opt,name=memo" json:"memo,omitempty"`
	// / An optional cryptographic receipt of payment
	Receipt []byte `protobuf:"bytes,2,opt,name=receipt,proto3" json:"receipt,omitempty"`
	// *
	// The hex-encoded preimage (32 byte) which will allow settling an incoming
	// HTLC payable to this preimage
	RPreimage []byte `protobuf:"bytes,3,opt,name=r_preimage,proto3" json:"r_preimage,omitempty"`
	// / The hash of the preimage
	RHash []byte `protobuf:"bytes,4,opt,name=r_hash,proto3" json:"r_hash,omitempty"`
	// / The value of this invoice in satoshis
	Value int64 `protobuf:"varint,5,opt,name=value" json:"value,omitempty"`
	// / Whether this invoice has been fulfilled
	Settled bool `protobuf:"varint,6,opt,name=settled" json:"settled,omitempty"`
	// / When this invoice was created
	CreationDate int64 `protobuf:"varint,7,opt,name=creation_date" json:"creation_date,omitempty"`
	// / When this invoice was settled
	SettleDate int64 `protobuf:"varint,8,opt,name=settle_date" json:"settle_date,omitempty"`
	// *
	// A bare-bones invoice for a payment within the Lightning Network.  With the
	// details of the invoice, the sender has all the data necessary to send a
	// payment to the recipient.
	PaymentRequest string `protobuf:"bytes,9,opt,name=payment_request" json:"payment_request,omitempty"`
}

func (m *Invoice) Reset()                    { *m = Invoice{} }
func (m *Invoice) String() string            { return proto.CompactTextString(m) }
func (*Invoice) ProtoMessage()               {}
func (*Invoice) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{69} }

func (m *Invoice) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *Invoice) GetReceipt() []byte {
	if m != nil {
		return m.Receipt
	}
	return nil
}

func (m *Invoice) GetRPreimage() []byte {
	if m != nil {
		return m.RPreimage
	}
	return nil
}

func (m *Invoice) GetRHash() []byte {
	if m != nil {
		return m.RHash
	}
	return nil
}

func (m *Invoice) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Invoice) GetSettled() bool {
	if m != nil {
		return m.Settled
	}
	return false
}

func (m *Invoice) GetCreationDate() int64 {
	if m != nil {
		return m.CreationDate
	}
	return 0
}

func (m *Invoice) GetSettleDate() int64 {
	if m != nil {
		return m.SettleDate
	}
	return 0
}

func (m *Invoice) GetPaymentRequest() string {
	if m != nil {
		return m.PaymentRequest
	}
	return ""
}

type AddInvoiceResponse struct {
	RHash []byte `protobuf:"bytes,1,opt,name=r_hash,proto3" json:"r_hash,omitempty"`
	// *
	// A bare-bones invoice for a payment within the Lightning Network.  With the
	// details of the invoice, the sender has all the data necessary to send a
	// payment to the recipient.
	PaymentRequest string `protobuf:"bytes,2,opt,name=payment_request" json:"payment_request,omitempty"`
}

func (m *AddInvoiceResponse) Reset()                    { *m = AddInvoiceResponse{} }
func (m *AddInvoiceResponse) String() string            { return proto.CompactTextString(m) }
func (*AddInvoiceResponse) ProtoMessage()               {}
func (*AddInvoiceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{70} }

func (m *AddInvoiceResponse) GetRHash() []byte {
	if m != nil {
		return m.RHash
	}
	return nil
}

func (m *AddInvoiceResponse) GetPaymentRequest() string {
	if m != nil {
		return m.PaymentRequest
	}
	return ""
}

type PaymentHash struct {
	// *
	// The hex-encoded payment hash of the invoice to be looked up. The passed
	// payment hash must be exactly 32 bytes, otherwise an error is returned.
	RHashStr string `protobuf:"bytes,1,opt,name=r_hash_str" json:"r_hash_str,omitempty"`
	// / The payment hash of the invoice to be looked up.
	RHash []byte `protobuf:"bytes,2,opt,name=r_hash,proto3" json:"r_hash,omitempty"`
}

func (m *PaymentHash) Reset()                    { *m = PaymentHash{} }
func (m *PaymentHash) String() string            { return proto.CompactTextString(m) }
func (*PaymentHash) ProtoMessage()               {}
func (*PaymentHash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{71} }

func (m *PaymentHash) GetRHashStr() string {
	if m != nil {
		return m.RHashStr
	}
	return ""
}

func (m *PaymentHash) GetRHash() []byte {
	if m != nil {
		return m.RHash
	}
	return nil
}

type ListInvoiceRequest struct {
	// / Toggles if all invoices should be returned, or only those that are currently unsettled.
	PendingOnly bool `protobuf:"varint,1,opt,name=pending_only,json=pendingOnly" json:"pending_only,omitempty"`
}

func (m *ListInvoiceRequest) Reset()                    { *m = ListInvoiceRequest{} }
func (m *ListInvoiceRequest) String() string            { return proto.CompactTextString(m) }
func (*ListInvoiceRequest) ProtoMessage()               {}
func (*ListInvoiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{72} }

func (m *ListInvoiceRequest) GetPendingOnly() bool {
	if m != nil {
		return m.PendingOnly
	}
	return false
}

type ListInvoiceResponse struct {
	Invoices []*Invoice `protobuf:"bytes,1,rep,name=invoices" json:"invoices,omitempty"`
}

func (m *ListInvoiceResponse) Reset()                    { *m = ListInvoiceResponse{} }
func (m *ListInvoiceResponse) String() string            { return proto.CompactTextString(m) }
func (*ListInvoiceResponse) ProtoMessage()               {}
func (*ListInvoiceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{73} }

func (m *ListInvoiceResponse) GetInvoices() []*Invoice {
	if m != nil {
		return m.Invoices
	}
	return nil
}

type InvoiceSubscription struct {
}

func (m *InvoiceSubscription) Reset()                    { *m = InvoiceSubscription{} }
func (m *InvoiceSubscription) String() string            { return proto.CompactTextString(m) }
func (*InvoiceSubscription) ProtoMessage()               {}
func (*InvoiceSubscription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{74} }

type Payment struct {
	// / The payment hash
	PaymentHash string `protobuf:"bytes,1,opt,name=payment_hash" json:"payment_hash,omitempty"`
	// / The value of the payment in satoshis
	Value int64 `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
	// / The date of this payment
	CreationDate int64 `protobuf:"varint,3,opt,name=creation_date" json:"creation_date,omitempty"`
	// / The path this payment took
	Path []string `protobuf:"bytes,4,rep,name=path" json:"path,omitempty"`
	// / The fee paid for this payment in satoshis
	Fee int64 `protobuf:"varint,5,opt,name=fee" json:"fee,omitempty"`
}

func (m *Payment) Reset()                    { *m = Payment{} }
func (m *Payment) String() string            { return proto.CompactTextString(m) }
func (*Payment) ProtoMessage()               {}
func (*Payment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{75} }

func (m *Payment) GetPaymentHash() string {
	if m != nil {
		return m.PaymentHash
	}
	return ""
}

func (m *Payment) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Payment) GetCreationDate() int64 {
	if m != nil {
		return m.CreationDate
	}
	return 0
}

func (m *Payment) GetPath() []string {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Payment) GetFee() int64 {
	if m != nil {
		return m.Fee
	}
	return 0
}

type ListPaymentsRequest struct {
}

func (m *ListPaymentsRequest) Reset()                    { *m = ListPaymentsRequest{} }
func (m *ListPaymentsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPaymentsRequest) ProtoMessage()               {}
func (*ListPaymentsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{76} }

type ListPaymentsResponse struct {
	// / The list of payments
	Payments []*Payment `protobuf:"bytes,1,rep,name=payments" json:"payments,omitempty"`
}

func (m *ListPaymentsResponse) Reset()                    { *m = ListPaymentsResponse{} }
func (m *ListPaymentsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListPaymentsResponse) ProtoMessage()               {}
func (*ListPaymentsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{77} }

func (m *ListPaymentsResponse) GetPayments() []*Payment {
	if m != nil {
		return m.Payments
	}
	return nil
}

type DeleteAllPaymentsRequest struct {
}

func (m *DeleteAllPaymentsRequest) Reset()                    { *m = DeleteAllPaymentsRequest{} }
func (m *DeleteAllPaymentsRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteAllPaymentsRequest) ProtoMessage()               {}
func (*DeleteAllPaymentsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{78} }

type DeleteAllPaymentsResponse struct {
}

func (m *DeleteAllPaymentsResponse) Reset()                    { *m = DeleteAllPaymentsResponse{} }
func (m *DeleteAllPaymentsResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteAllPaymentsResponse) ProtoMessage()               {}
func (*DeleteAllPaymentsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{79} }

type DebugLevelRequest struct {
	Show      bool   `protobuf:"varint,1,opt,name=show" json:"show,omitempty"`
	LevelSpec string `protobuf:"bytes,2,opt,name=level_spec,json=levelSpec" json:"level_spec,omitempty"`
}

func (m *DebugLevelRequest) Reset()                    { *m = DebugLevelRequest{} }
func (m *DebugLevelRequest) String() string            { return proto.CompactTextString(m) }
func (*DebugLevelRequest) ProtoMessage()               {}
func (*DebugLevelRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{80} }

func (m *DebugLevelRequest) GetShow() bool {
	if m != nil {
		return m.Show
	}
	return false
}

func (m *DebugLevelRequest) GetLevelSpec() string {
	if m != nil {
		return m.LevelSpec
	}
	return ""
}

type DebugLevelResponse struct {
	SubSystems string `protobuf:"bytes,1,opt,name=sub_systems" json:"sub_systems,omitempty"`
}

func (m *DebugLevelResponse) Reset()                    { *m = DebugLevelResponse{} }
func (m *DebugLevelResponse) String() string            { return proto.CompactTextString(m) }
func (*DebugLevelResponse) ProtoMessage()               {}
func (*DebugLevelResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{81} }

func (m *DebugLevelResponse) GetSubSystems() string {
	if m != nil {
		return m.SubSystems
	}
	return ""
}

type PayReqString struct {
	// / The payment request string to be decoded
	PayReq string `protobuf:"bytes,1,opt,name=pay_req,json=payReq" json:"pay_req,omitempty"`
}

func (m *PayReqString) Reset()                    { *m = PayReqString{} }
func (m *PayReqString) String() string            { return proto.CompactTextString(m) }
func (*PayReqString) ProtoMessage()               {}
func (*PayReqString) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{82} }

func (m *PayReqString) GetPayReq() string {
	if m != nil {
		return m.PayReq
	}
	return ""
}

type PayReq struct {
	Destination string `protobuf:"bytes,1,opt,name=destination" json:"destination,omitempty"`
	PaymentHash string `protobuf:"bytes,2,opt,name=payment_hash" json:"payment_hash,omitempty"`
	NumSatoshis int64  `protobuf:"varint,3,opt,name=num_satoshis" json:"num_satoshis,omitempty"`
}

func (m *PayReq) Reset()                    { *m = PayReq{} }
func (m *PayReq) String() string            { return proto.CompactTextString(m) }
func (*PayReq) ProtoMessage()               {}
func (*PayReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{83} }

func (m *PayReq) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *PayReq) GetPaymentHash() string {
	if m != nil {
		return m.PaymentHash
	}
	return ""
}

func (m *PayReq) GetNumSatoshis() int64 {
	if m != nil {
		return m.NumSatoshis
	}
	return 0
}

type FeeReportRequest struct {
}

func (m *FeeReportRequest) Reset()                    { *m = FeeReportRequest{} }
func (m *FeeReportRequest) String() string            { return proto.CompactTextString(m) }
func (*FeeReportRequest) ProtoMessage()               {}
func (*FeeReportRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{84} }

type ChannelFeeReport struct {
	// / The channel that this fee report belongs to.
	ChanPoint string `protobuf:"bytes,1,opt,name=chan_point,json=channel_point" json:"chan_point,omitempty"`
	// / The base fee charged regardless of the number of milli-satoshis sent.
	BaseFeeMsat int64 `protobuf:"varint,2,opt,name=base_fee_msat" json:"base_fee_msat,omitempty"`
	// / The amount charged per milli-satoshis transferred expressed in millionths of a satoshi.
	FeePerMil int64 `protobuf:"varint,3,opt,name=fee_per_mil" json:"fee_per_mil,omitempty"`
	// / The effective fee rate in milli-satoshis. Computed by dividing the fee_per_mil value by 1 million.
	FeeRate float64 `protobuf:"fixed64,4,opt,name=fee_rate" json:"fee_rate,omitempty"`
}

func (m *ChannelFeeReport) Reset()                    { *m = ChannelFeeReport{} }
func (m *ChannelFeeReport) String() string            { return proto.CompactTextString(m) }
func (*ChannelFeeReport) ProtoMessage()               {}
func (*ChannelFeeReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{85} }

func (m *ChannelFeeReport) GetChanPoint() string {
	if m != nil {
		return m.ChanPoint
	}
	return ""
}

func (m *ChannelFeeReport) GetBaseFeeMsat() int64 {
	if m != nil {
		return m.BaseFeeMsat
	}
	return 0
}

func (m *ChannelFeeReport) GetFeePerMil() int64 {
	if m != nil {
		return m.FeePerMil
	}
	return 0
}

func (m *ChannelFeeReport) GetFeeRate() float64 {
	if m != nil {
		return m.FeeRate
	}
	return 0
}

type FeeReportResponse struct {
	// / An array of channel fee reports which describes the current fee schedule for each channel.
	ChannelFees []*ChannelFeeReport `protobuf:"bytes,1,rep,name=channel_fees" json:"channel_fees,omitempty"`
}

func (m *FeeReportResponse) Reset()                    { *m = FeeReportResponse{} }
func (m *FeeReportResponse) String() string            { return proto.CompactTextString(m) }
func (*FeeReportResponse) ProtoMessage()               {}
func (*FeeReportResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{86} }

func (m *FeeReportResponse) GetChannelFees() []*ChannelFeeReport {
	if m != nil {
		return m.ChannelFees
	}
	return nil
}

type FeeUpdateRequest struct {
	// Types that are valid to be assigned to Scope:
	//	*FeeUpdateRequest_Global
	//	*FeeUpdateRequest_ChanPoint
	Scope isFeeUpdateRequest_Scope `protobuf_oneof:"scope"`
	// / The base fee charged regardless of the number of milli-satoshis sent.
	BaseFeeMsat int64 `protobuf:"varint,3,opt,name=base_fee_msat" json:"base_fee_msat,omitempty"`
	// / The effective fee rate in milli-satoshis. The precision of this value goes up to 6 decimal places, so 1e-6.
	FeeRate float64 `protobuf:"fixed64,4,opt,name=fee_rate" json:"fee_rate,omitempty"`
}

func (m *FeeUpdateRequest) Reset()                    { *m = FeeUpdateRequest{} }
func (m *FeeUpdateRequest) String() string            { return proto.CompactTextString(m) }
func (*FeeUpdateRequest) ProtoMessage()               {}
func (*FeeUpdateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{87} }

type isFeeUpdateRequest_Scope interface {
	isFeeUpdateRequest_Scope()
}

type FeeUpdateRequest_Global struct {
	Global bool `protobuf:"varint,1,opt,name=global,oneof"`
}
type FeeUpdateRequest_ChanPoint struct {
	ChanPoint *ChannelPoint `protobuf:"bytes,2,opt,name=chan_point,oneof"`
}

func (*FeeUpdateRequest_Global) isFeeUpdateRequest_Scope()    {}
func (*FeeUpdateRequest_ChanPoint) isFeeUpdateRequest_Scope() {}

func (m *FeeUpdateRequest) GetScope() isFeeUpdateRequest_Scope {
	if m != nil {
		return m.Scope
	}
	return nil
}

func (m *FeeUpdateRequest) GetGlobal() bool {
	if x, ok := m.GetScope().(*FeeUpdateRequest_Global); ok {
		return x.Global
	}
	return false
}

func (m *FeeUpdateRequest) GetChanPoint() *ChannelPoint {
	if x, ok := m.GetScope().(*FeeUpdateRequest_ChanPoint); ok {
		return x.ChanPoint
	}
	return nil
}

func (m *FeeUpdateRequest) GetBaseFeeMsat() int64 {
	if m != nil {
		return m.BaseFeeMsat
	}
	return 0
}

func (m *FeeUpdateRequest) GetFeeRate() float64 {
	if m != nil {
		return m.FeeRate
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FeeUpdateRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FeeUpdateRequest_OneofMarshaler, _FeeUpdateRequest_OneofUnmarshaler, _FeeUpdateRequest_OneofSizer, []interface{}{
		(*FeeUpdateRequest_Global)(nil),
		(*FeeUpdateRequest_ChanPoint)(nil),
	}
}

func _FeeUpdateRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FeeUpdateRequest)
	// scope
	switch x := m.Scope.(type) {
	case *FeeUpdateRequest_Global:
		t := uint64(0)
		if x.Global {
			t = 1
		}
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *FeeUpdateRequest_ChanPoint:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ChanPoint); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FeeUpdateRequest.Scope has unexpected type %T", x)
	}
	return nil
}

func _FeeUpdateRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FeeUpdateRequest)
	switch tag {
	case 1: // scope.global
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Scope = &FeeUpdateRequest_Global{x != 0}
		return true, err
	case 2: // scope.chan_point
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChannelPoint)
		err := b.DecodeMessage(msg)
		m.Scope = &FeeUpdateRequest_ChanPoint{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FeeUpdateRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FeeUpdateRequest)
	// scope
	switch x := m.Scope.(type) {
	case *FeeUpdateRequest_Global:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += 1
	case *FeeUpdateRequest_ChanPoint:
		s := proto.Size(x.ChanPoint)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type FeeUpdateResponse struct {
}

func (m *FeeUpdateResponse) Reset()                    { *m = FeeUpdateResponse{} }
func (m *FeeUpdateResponse) String() string            { return proto.CompactTextString(m) }
func (*FeeUpdateResponse) ProtoMessage()               {}
func (*FeeUpdateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{88} }

func init() {
	proto.RegisterType((*Transaction)(nil), "lnrpc.Transaction")
	proto.RegisterType((*GetTransactionsRequest)(nil), "lnrpc.GetTransactionsRequest")
	proto.RegisterType((*TransactionDetails)(nil), "lnrpc.TransactionDetails")
	proto.RegisterType((*SendRequest)(nil), "lnrpc.SendRequest")
	proto.RegisterType((*SendResponse)(nil), "lnrpc.SendResponse")
	proto.RegisterType((*ChannelPoint)(nil), "lnrpc.ChannelPoint")
	proto.RegisterType((*LightningAddress)(nil), "lnrpc.LightningAddress")
	proto.RegisterType((*SendManyRequest)(nil), "lnrpc.SendManyRequest")
	proto.RegisterType((*SendManyResponse)(nil), "lnrpc.SendManyResponse")
	proto.RegisterType((*SendCoinsRequest)(nil), "lnrpc.SendCoinsRequest")
	proto.RegisterType((*SendCoinsResponse)(nil), "lnrpc.SendCoinsResponse")
	proto.RegisterType((*NewAddressRequest)(nil), "lnrpc.NewAddressRequest")
	proto.RegisterType((*NewWitnessAddressRequest)(nil), "lnrpc.NewWitnessAddressRequest")
	proto.RegisterType((*NewAddressResponse)(nil), "lnrpc.NewAddressResponse")
	proto.RegisterType((*SignMessageRequest)(nil), "lnrpc.SignMessageRequest")
	proto.RegisterType((*SignMessageResponse)(nil), "lnrpc.SignMessageResponse")
	proto.RegisterType((*VerifyMessageRequest)(nil), "lnrpc.VerifyMessageRequest")
	proto.RegisterType((*VerifyMessageResponse)(nil), "lnrpc.VerifyMessageResponse")
	proto.RegisterType((*ConnectPeerRequest)(nil), "lnrpc.ConnectPeerRequest")
	proto.RegisterType((*ConnectPeerResponse)(nil), "lnrpc.ConnectPeerResponse")
	proto.RegisterType((*DisconnectPeerRequest)(nil), "lnrpc.DisconnectPeerRequest")
	proto.RegisterType((*DisconnectPeerResponse)(nil), "lnrpc.DisconnectPeerResponse")
	proto.RegisterType((*HTLC)(nil), "lnrpc.HTLC")
	proto.RegisterType((*ActiveChannel)(nil), "lnrpc.ActiveChannel")
	proto.RegisterType((*ListChannelsRequest)(nil), "lnrpc.ListChannelsRequest")
	proto.RegisterType((*ListChannelsResponse)(nil), "lnrpc.ListChannelsResponse")
	proto.RegisterType((*Peer)(nil), "lnrpc.Peer")
	proto.RegisterType((*ListPeersRequest)(nil), "lnrpc.ListPeersRequest")
	proto.RegisterType((*ListPeersResponse)(nil), "lnrpc.ListPeersResponse")
	proto.RegisterType((*GetInfoRequest)(nil), "lnrpc.GetInfoRequest")
	proto.RegisterType((*GetInfoResponse)(nil), "lnrpc.GetInfoResponse")
	proto.RegisterType((*ConfirmationUpdate)(nil), "lnrpc.ConfirmationUpdate")
	proto.RegisterType((*ChannelOpenUpdate)(nil), "lnrpc.ChannelOpenUpdate")
	proto.RegisterType((*ChannelCloseUpdate)(nil), "lnrpc.ChannelCloseUpdate")
	proto.RegisterType((*CloseChannelRequest)(nil), "lnrpc.CloseChannelRequest")
	proto.RegisterType((*CloseStatusUpdate)(nil), "lnrpc.CloseStatusUpdate")
	proto.RegisterType((*PendingUpdate)(nil), "lnrpc.PendingUpdate")
	proto.RegisterType((*OpenChannelRequest)(nil), "lnrpc.OpenChannelRequest")
	proto.RegisterType((*OpenStatusUpdate)(nil), "lnrpc.OpenStatusUpdate")
	proto.RegisterType((*PendingChannelRequest)(nil), "lnrpc.PendingChannelRequest")
	proto.RegisterType((*PendingChannelResponse)(nil), "lnrpc.PendingChannelResponse")
	proto.RegisterType((*PendingChannelResponse_PendingChannel)(nil), "lnrpc.PendingChannelResponse.PendingChannel")
	proto.RegisterType((*PendingChannelResponse_PendingOpenChannel)(nil), "lnrpc.PendingChannelResponse.PendingOpenChannel")
	proto.RegisterType((*PendingChannelResponse_ClosedChannel)(nil), "lnrpc.PendingChannelResponse.ClosedChannel")
	proto.RegisterType((*PendingChannelResponse_ForceClosedChannel)(nil), "lnrpc.PendingChannelResponse.ForceClosedChannel")
	proto.RegisterType((*WalletBalanceRequest)(nil), "lnrpc.WalletBalanceRequest")
	proto.RegisterType((*WalletBalanceResponse)(nil), "lnrpc.WalletBalanceResponse")
	proto.RegisterType((*ChannelBalanceRequest)(nil), "lnrpc.ChannelBalanceRequest")
	proto.RegisterType((*ChannelBalanceResponse)(nil), "lnrpc.ChannelBalanceResponse")
	proto.RegisterType((*QueryRoutesRequest)(nil), "lnrpc.QueryRoutesRequest")
	proto.RegisterType((*QueryRoutesResponse)(nil), "lnrpc.QueryRoutesResponse")
	proto.RegisterType((*Hop)(nil), "lnrpc.Hop")
	proto.RegisterType((*Route)(nil), "lnrpc.Route")
	proto.RegisterType((*NodeInfoRequest)(nil), "lnrpc.NodeInfoRequest")
	proto.RegisterType((*NodeInfo)(nil), "lnrpc.NodeInfo")
	proto.RegisterType((*LightningNode)(nil), "lnrpc.LightningNode")
	proto.RegisterType((*NodeAddress)(nil), "lnrpc.NodeAddress")
	proto.RegisterType((*RoutingPolicy)(nil), "lnrpc.RoutingPolicy")
	proto.RegisterType((*ChannelEdge)(nil), "lnrpc.ChannelEdge")
	proto.RegisterType((*ChannelGraphRequest)(nil), "lnrpc.ChannelGraphRequest")
	proto.RegisterType((*ChannelGraph)(nil), "lnrpc.ChannelGraph")
	proto.RegisterType((*ChanInfoRequest)(nil), "lnrpc.ChanInfoRequest")
	proto.RegisterType((*NetworkInfoRequest)(nil), "lnrpc.NetworkInfoRequest")
	proto.RegisterType((*NetworkInfo)(nil), "lnrpc.NetworkInfo")
	proto.RegisterType((*StopRequest)(nil), "lnrpc.StopRequest")
	proto.RegisterType((*StopResponse)(nil), "lnrpc.StopResponse")
	proto.RegisterType((*GraphTopologySubscription)(nil), "lnrpc.GraphTopologySubscription")
	proto.RegisterType((*GraphTopologyUpdate)(nil), "lnrpc.GraphTopologyUpdate")
	proto.RegisterType((*NodeUpdate)(nil), "lnrpc.NodeUpdate")
	proto.RegisterType((*ChannelEdgeUpdate)(nil), "lnrpc.ChannelEdgeUpdate")
	proto.RegisterType((*ClosedChannelUpdate)(nil), "lnrpc.ClosedChannelUpdate")
	proto.RegisterType((*SetAliasRequest)(nil), "lnrpc.SetAliasRequest")
	proto.RegisterType((*SetAliasResponse)(nil), "lnrpc.SetAliasResponse")
	proto.RegisterType((*Invoice)(nil), "lnrpc.Invoice")
	proto.RegisterType((*AddInvoiceResponse)(nil), "lnrpc.AddInvoiceResponse")
	proto.RegisterType((*PaymentHash)(nil), "lnrpc.PaymentHash")
	proto.RegisterType((*ListInvoiceRequest)(nil), "lnrpc.ListInvoiceRequest")
	proto.RegisterType((*ListInvoiceResponse)(nil), "lnrpc.ListInvoiceResponse")
	proto.RegisterType((*InvoiceSubscription)(nil), "lnrpc.InvoiceSubscription")
	proto.RegisterType((*Payment)(nil), "lnrpc.Payment")
	proto.RegisterType((*ListPaymentsRequest)(nil), "lnrpc.ListPaymentsRequest")
	proto.RegisterType((*ListPaymentsResponse)(nil), "lnrpc.ListPaymentsResponse")
	proto.RegisterType((*DeleteAllPaymentsRequest)(nil), "lnrpc.DeleteAllPaymentsRequest")
	proto.RegisterType((*DeleteAllPaymentsResponse)(nil), "lnrpc.DeleteAllPaymentsResponse")
	proto.RegisterType((*DebugLevelRequest)(nil), "lnrpc.DebugLevelRequest")
	proto.RegisterType((*DebugLevelResponse)(nil), "lnrpc.DebugLevelResponse")
	proto.RegisterType((*PayReqString)(nil), "lnrpc.PayReqString")
	proto.RegisterType((*PayReq)(nil), "lnrpc.PayReq")
	proto.RegisterType((*FeeReportRequest)(nil), "lnrpc.FeeReportRequest")
	proto.RegisterType((*ChannelFeeReport)(nil), "lnrpc.ChannelFeeReport")
	proto.RegisterType((*FeeReportResponse)(nil), "lnrpc.FeeReportResponse")
	proto.RegisterType((*FeeUpdateRequest)(nil), "lnrpc.FeeUpdateRequest")
	proto.RegisterType((*FeeUpdateResponse)(nil), "lnrpc.FeeUpdateResponse")
	proto.RegisterEnum("lnrpc.NewAddressRequest_AddressType", NewAddressRequest_AddressType_name, NewAddressRequest_AddressType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Lightning service

type LightningClient interface {
	// * lncli: `walletbalance`
	// WalletBalance returns the sum of all confirmed unspent outputs under control
	// by the wallet. This method can be modified by having the request specify
	// only witness outputs should be factored into the final output sum.
	WalletBalance(ctx context.Context, in *WalletBalanceRequest, opts ...grpc.CallOption) (*WalletBalanceResponse, error)
	// * lncli: `channelbalance`
	// ChannelBalance returns the total funds available across all open channels
	// in satoshis.
	ChannelBalance(ctx context.Context, in *ChannelBalanceRequest, opts ...grpc.CallOption) (*ChannelBalanceResponse, error)
	// * lncli: `listchaintxns`
	// GetTransactions returns a list describing all the known transactions
	// relevant to the wallet.
	GetTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (*TransactionDetails, error)
	// * lncli: `sendcoins`
	// SendCoins executes a request to send coins to a particular address. Unlike
	// SendMany, this RPC call only allows creating a single output at a time.
	SendCoins(ctx context.Context, in *SendCoinsRequest, opts ...grpc.CallOption) (*SendCoinsResponse, error)
	// *
	// SubscribeTransactions creates a uni-directional stream from the server to
	// the client in which any newly discovered transactions relevant to the
	// wallet are sent over.
	SubscribeTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (Lightning_SubscribeTransactionsClient, error)
	// * lncli: `sendmany`
	// SendMany handles a request for a transaction that creates multiple specified
	// outputs in parallel.
	SendMany(ctx context.Context, in *SendManyRequest, opts ...grpc.CallOption) (*SendManyResponse, error)
	// * lncli: `newaddress`
	// NewAddress creates a new address under control of the local wallet.
	NewAddress(ctx context.Context, in *NewAddressRequest, opts ...grpc.CallOption) (*NewAddressResponse, error)
	// *
	// NewWitnessAddress creates a new witness address under control of the local wallet.
	NewWitnessAddress(ctx context.Context, in *NewWitnessAddressRequest, opts ...grpc.CallOption) (*NewAddressResponse, error)
	// * lncli: `signmessage`
	// SignMessage signs a message with this node's private key. The returned
	// signature string is `zbase32` encoded and pubkey recoverable, meaning that
	// only the message digest and signature are needed for verification.
	SignMessage(ctx context.Context, in *SignMessageRequest, opts ...grpc.CallOption) (*SignMessageResponse, error)
	// * lncli: `verifymessage`
	// VerifyMessage verifies a signature over a msg. The signature must be
	// zbase32 encoded and signed by an active node in the resident node's
	// channel database. In addition to returning the validity of the signature,
	// VerifyMessage also returns the recovered pubkey from the signature.
	VerifyMessage(ctx context.Context, in *VerifyMessageRequest, opts ...grpc.CallOption) (*VerifyMessageResponse, error)
	// * lncli: `connect`
	// ConnectPeer attempts to establish a connection to a remote peer. This is at
	// the networking level, and is used for communication between nodes. This is
	// distinct from establishing a channel with a peer.
	ConnectPeer(ctx context.Context, in *ConnectPeerRequest, opts ...grpc.CallOption) (*ConnectPeerResponse, error)
	// * lncli: `disconnect`
	// DisconnectPeer attempts to disconnect one peer from another identified by a
	// given pubKey. In the case that we currently have a pending or active channel
	// with the target peer, then this action will be not be allowed.
	DisconnectPeer(ctx context.Context, in *DisconnectPeerRequest, opts ...grpc.CallOption) (*DisconnectPeerResponse, error)
	// * lncli: `listpeers`
	// ListPeers returns a verbose listing of all currently active peers.
	ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error)
	// * lncli: `getinfo`
	// GetInfo returns general information concerning the lightning node including
	// it's identity pubkey, alias, the chains it is connected to, and information
	// concerning the number of open+pending channels.
	GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error)
	// * lncli: `pendingchannels`
	// PendingChannels returns a list of all the channels that are currently
	// considered "pending". A channel is pending if it has finished the funding
	// workflow and is waiting for confirmations for the funding txn, or is in the
	// process of closure, either initiated cooperatively or non-cooperatively.
	PendingChannels(ctx context.Context, in *PendingChannelRequest, opts ...grpc.CallOption) (*PendingChannelResponse, error)
	// * lncli: `listchannels`
	// ListChannels returns a description of all the open channels that this node
	// is a participant in.
	ListChannels(ctx context.Context, in *ListChannelsRequest, opts ...grpc.CallOption) (*ListChannelsResponse, error)
	// *
	// OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
	// call is meant to be consumed by clients to the REST proxy. As with all
	// other sync calls, all byte slices are intended to be populated as hex
	// encoded strings.
	OpenChannelSync(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*ChannelPoint, error)
	// * lncli: `openchannel`
	// OpenChannel attempts to open a singly funded channel specified in the
	// request to a remote peer.
	OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (Lightning_OpenChannelClient, error)
	// * lncli: `closechannel`
	// CloseChannel attempts to close an active channel identified by its channel
	// outpoint (ChannelPoint). The actions of this method can additionally be
	// augmented to attempt a force close after a timeout period in the case of an
	// inactive peer.
	CloseChannel(ctx context.Context, in *CloseChannelRequest, opts ...grpc.CallOption) (Lightning_CloseChannelClient, error)
	// * lncli: `sendpayment`
	// SendPayment dispatches a bi-directional streaming RPC for sending payments
	// through the Lightning Network. A single RPC invocation creates a persistent
	// bi-directional stream allowing clients to rapidly send payments through the
	// Lightning Network with a single persistent connection.
	SendPayment(ctx context.Context, opts ...grpc.CallOption) (Lightning_SendPaymentClient, error)
	// *
	// SendPaymentSync is the synchronous non-streaming version of SendPayment.
	// This RPC is intended to be consumed by clients of the REST proxy.
	// Additionally, this RPC expects the destination's public key and the payment
	// hash (if any) to be encoded as hex strings.
	SendPaymentSync(ctx context.Context, in *SendRequest, opts ...grpc.CallOption) (*SendResponse, error)
	// * lncli: `addinvoice`
	// AddInvoice attempts to add a new invoice to the invoice database. Any
	// duplicated invoices are rejected, therefore all invoices *must* have a
	// unique payment preimage.
	AddInvoice(ctx context.Context, in *Invoice, opts ...grpc.CallOption) (*AddInvoiceResponse, error)
	// * lncli: `listinvoices`
	// ListInvoices returns a list of all the invoices currently stored within the
	// database. Any active debug invoices are ignored.
	ListInvoices(ctx context.Context, in *ListInvoiceRequest, opts ...grpc.CallOption) (*ListInvoiceResponse, error)
	// * lncli: `lookupinvoice`
	// LookupInvoice attemps to look up an invoice according to its payment hash.
	// The passed payment hash *must* be exactly 32 bytes, if not, an error is
	// returned.
	LookupInvoice(ctx context.Context, in *PaymentHash, opts ...grpc.CallOption) (*Invoice, error)
	// *
	// SubscribeInvoices returns a uni-directional stream (sever -> client) for
	// notifying the client of newly added/settled invoices.
	SubscribeInvoices(ctx context.Context, in *InvoiceSubscription, opts ...grpc.CallOption) (Lightning_SubscribeInvoicesClient, error)
	// * lncli: `decodepayreq`
	// DecodePayReq takes an encoded payment request string and attempts to decode
	// it, returning a full description of the conditions encoded within the
	// payment request.
	DecodePayReq(ctx context.Context, in *PayReqString, opts ...grpc.CallOption) (*PayReq, error)
	// * lncli: `listpayments`
	// ListPayments returns a list of all outgoing payments.
	ListPayments(ctx context.Context, in *ListPaymentsRequest, opts ...grpc.CallOption) (*ListPaymentsResponse, error)
	// *
	// DeleteAllPayments deletes all outgoing payments from DB.
	DeleteAllPayments(ctx context.Context, in *DeleteAllPaymentsRequest, opts ...grpc.CallOption) (*DeleteAllPaymentsResponse, error)
	// * lncli: `describegraph`
	// DescribeGraph returns a description of the latest graph state from the
	// point of view of the node. The graph information is partitioned into two
	// components: all the nodes/vertexes, and all the edges that connect the
	// vertexes themselves.  As this is a directed graph, the edges also contain
	// the node directional specific routing policy which includes: the time lock
	// delta, fee information, etc.
	DescribeGraph(ctx context.Context, in *ChannelGraphRequest, opts ...grpc.CallOption) (*ChannelGraph, error)
	// * lncli: `getchaninfo`
	// GetChanInfo returns the latest authenticated network announcement for the
	// given channel identified by its channel ID: an 8-byte integer which
	// uniquely identifies the location of transaction's funding output within the
	// blockchain.
	GetChanInfo(ctx context.Context, in *ChanInfoRequest, opts ...grpc.CallOption) (*ChannelEdge, error)
	// * lncli: `getnodeinfo`
	// GetNodeInfo returns the latest advertised, aggregated, and authenticated
	// channel information for the specified node identified by its public key.
	GetNodeInfo(ctx context.Context, in *NodeInfoRequest, opts ...grpc.CallOption) (*NodeInfo, error)
	// * lncli: `queryroutes`
	// QueryRoutes attempts to query the daemon's Channel Router for a possible
	// route to a target destination capable of carrying a specific amount of
	// satoshis. The retuned route contains the full details required to craft and
	// send an HTLC, also including the necessary information that should be
	// present within the Sphinx packet encapsualted within the HTLC.
	QueryRoutes(ctx context.Context, in *QueryRoutesRequest, opts ...grpc.CallOption) (*QueryRoutesResponse, error)
	// * lncli: `getnetworkinfo`
	// GetNetworkInfo returns some basic stats about the known channel graph from
	// the point of view of the node.
	GetNetworkInfo(ctx context.Context, in *NetworkInfoRequest, opts ...grpc.CallOption) (*NetworkInfo, error)
	// * lncli: `stop`
	// StopDaemon will send a shutdown request to the interrupt handler, triggering
	// a graceful shutdown of the daemon.
	StopDaemon(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error)
	// *
	// SubscribeChannelGraph launches a streaming RPC that allows the caller to
	// receive notifications upon any changes to the channel graph topology from
	// the point of view of the responding node. Events notified include: new
	// nodes coming online, nodes updating their authenticated attributes, new
	// channels being advertised, updates in the routing policy for a directional
	// channel edge, and when channels are closed on-chain.
	SubscribeChannelGraph(ctx context.Context, in *GraphTopologySubscription, opts ...grpc.CallOption) (Lightning_SubscribeChannelGraphClient, error)
	// *
	// SetAlias sets the alias for this node; e.g. "alice"
	SetAlias(ctx context.Context, in *SetAliasRequest, opts ...grpc.CallOption) (*SetAliasResponse, error)
	// * lncli: `debuglevel`
	// DebugLevel allows a caller to programmatically set the logging verbosity of
	// lnd. The logging can be targeted according to a coarse daemon-wide logging
	// level, or in a granular fashion to specify the logging for a target
	// sub-system.
	DebugLevel(ctx context.Context, in *DebugLevelRequest, opts ...grpc.CallOption) (*DebugLevelResponse, error)
	// * lncli: `feereport`
	// FeeReport allows the caller to obtain a report detailing the current fee
	// schedule enforced by the node globally for each channel.
	FeeReport(ctx context.Context, in *FeeReportRequest, opts ...grpc.CallOption) (*FeeReportResponse, error)
	// * lncli: `updatefees`
	// UpdateFees allows the caller to update the fee schedule for all channels
	// globally, or a particular channel.
	UpdateFees(ctx context.Context, in *FeeUpdateRequest, opts ...grpc.CallOption) (*FeeUpdateResponse, error)
}

type lightningClient struct {
	cc *grpc.ClientConn
}

func NewLightningClient(cc *grpc.ClientConn) LightningClient {
	return &lightningClient{cc}
}

func (c *lightningClient) WalletBalance(ctx context.Context, in *WalletBalanceRequest, opts ...grpc.CallOption) (*WalletBalanceResponse, error) {
	out := new(WalletBalanceResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/WalletBalance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) ChannelBalance(ctx context.Context, in *ChannelBalanceRequest, opts ...grpc.CallOption) (*ChannelBalanceResponse, error) {
	out := new(ChannelBalanceResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/ChannelBalance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) GetTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (*TransactionDetails, error) {
	out := new(TransactionDetails)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/GetTransactions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) SendCoins(ctx context.Context, in *SendCoinsRequest, opts ...grpc.CallOption) (*SendCoinsResponse, error) {
	out := new(SendCoinsResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/SendCoins", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) SubscribeTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (Lightning_SubscribeTransactionsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Lightning_serviceDesc.Streams[0], c.cc, "/lnrpc.Lightning/SubscribeTransactions", opts...)
	if err != nil {
		return nil, err
	}
	x := &lightningSubscribeTransactionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Lightning_SubscribeTransactionsClient interface {
	Recv() (*Transaction, error)
	grpc.ClientStream
}

type lightningSubscribeTransactionsClient struct {
	grpc.ClientStream
}

func (x *lightningSubscribeTransactionsClient) Recv() (*Transaction, error) {
	m := new(Transaction)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lightningClient) SendMany(ctx context.Context, in *SendManyRequest, opts ...grpc.CallOption) (*SendManyResponse, error) {
	out := new(SendManyResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/SendMany", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) NewAddress(ctx context.Context, in *NewAddressRequest, opts ...grpc.CallOption) (*NewAddressResponse, error) {
	out := new(NewAddressResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/NewAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) NewWitnessAddress(ctx context.Context, in *NewWitnessAddressRequest, opts ...grpc.CallOption) (*NewAddressResponse, error) {
	out := new(NewAddressResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/NewWitnessAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) SignMessage(ctx context.Context, in *SignMessageRequest, opts ...grpc.CallOption) (*SignMessageResponse, error) {
	out := new(SignMessageResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/SignMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) VerifyMessage(ctx context.Context, in *VerifyMessageRequest, opts ...grpc.CallOption) (*VerifyMessageResponse, error) {
	out := new(VerifyMessageResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/VerifyMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) ConnectPeer(ctx context.Context, in *ConnectPeerRequest, opts ...grpc.CallOption) (*ConnectPeerResponse, error) {
	out := new(ConnectPeerResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/ConnectPeer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) DisconnectPeer(ctx context.Context, in *DisconnectPeerRequest, opts ...grpc.CallOption) (*DisconnectPeerResponse, error) {
	out := new(DisconnectPeerResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/DisconnectPeer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error) {
	out := new(ListPeersResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/ListPeers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error) {
	out := new(GetInfoResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/GetInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) PendingChannels(ctx context.Context, in *PendingChannelRequest, opts ...grpc.CallOption) (*PendingChannelResponse, error) {
	out := new(PendingChannelResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/PendingChannels", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) ListChannels(ctx context.Context, in *ListChannelsRequest, opts ...grpc.CallOption) (*ListChannelsResponse, error) {
	out := new(ListChannelsResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/ListChannels", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) OpenChannelSync(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*ChannelPoint, error) {
	out := new(ChannelPoint)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/OpenChannelSync", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (Lightning_OpenChannelClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Lightning_serviceDesc.Streams[1], c.cc, "/lnrpc.Lightning/OpenChannel", opts...)
	if err != nil {
		return nil, err
	}
	x := &lightningOpenChannelClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Lightning_OpenChannelClient interface {
	Recv() (*OpenStatusUpdate, error)
	grpc.ClientStream
}

type lightningOpenChannelClient struct {
	grpc.ClientStream
}

func (x *lightningOpenChannelClient) Recv() (*OpenStatusUpdate, error) {
	m := new(OpenStatusUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lightningClient) CloseChannel(ctx context.Context, in *CloseChannelRequest, opts ...grpc.CallOption) (Lightning_CloseChannelClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Lightning_serviceDesc.Streams[2], c.cc, "/lnrpc.Lightning/CloseChannel", opts...)
	if err != nil {
		return nil, err
	}
	x := &lightningCloseChannelClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Lightning_CloseChannelClient interface {
	Recv() (*CloseStatusUpdate, error)
	grpc.ClientStream
}

type lightningCloseChannelClient struct {
	grpc.ClientStream
}

func (x *lightningCloseChannelClient) Recv() (*CloseStatusUpdate, error) {
	m := new(CloseStatusUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lightningClient) SendPayment(ctx context.Context, opts ...grpc.CallOption) (Lightning_SendPaymentClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Lightning_serviceDesc.Streams[3], c.cc, "/lnrpc.Lightning/SendPayment", opts...)
	if err != nil {
		return nil, err
	}
	x := &lightningSendPaymentClient{stream}
	return x, nil
}

type Lightning_SendPaymentClient interface {
	Send(*SendRequest) error
	Recv() (*SendResponse, error)
	grpc.ClientStream
}

type lightningSendPaymentClient struct {
	grpc.ClientStream
}

func (x *lightningSendPaymentClient) Send(m *SendRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *lightningSendPaymentClient) Recv() (*SendResponse, error) {
	m := new(SendResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lightningClient) SendPaymentSync(ctx context.Context, in *SendRequest, opts ...grpc.CallOption) (*SendResponse, error) {
	out := new(SendResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/SendPaymentSync", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) AddInvoice(ctx context.Context, in *Invoice, opts ...grpc.CallOption) (*AddInvoiceResponse, error) {
	out := new(AddInvoiceResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/AddInvoice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) ListInvoices(ctx context.Context, in *ListInvoiceRequest, opts ...grpc.CallOption) (*ListInvoiceResponse, error) {
	out := new(ListInvoiceResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/ListInvoices", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) LookupInvoice(ctx context.Context, in *PaymentHash, opts ...grpc.CallOption) (*Invoice, error) {
	out := new(Invoice)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/LookupInvoice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) SubscribeInvoices(ctx context.Context, in *InvoiceSubscription, opts ...grpc.CallOption) (Lightning_SubscribeInvoicesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Lightning_serviceDesc.Streams[4], c.cc, "/lnrpc.Lightning/SubscribeInvoices", opts...)
	if err != nil {
		return nil, err
	}
	x := &lightningSubscribeInvoicesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Lightning_SubscribeInvoicesClient interface {
	Recv() (*Invoice, error)
	grpc.ClientStream
}

type lightningSubscribeInvoicesClient struct {
	grpc.ClientStream
}

func (x *lightningSubscribeInvoicesClient) Recv() (*Invoice, error) {
	m := new(Invoice)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lightningClient) DecodePayReq(ctx context.Context, in *PayReqString, opts ...grpc.CallOption) (*PayReq, error) {
	out := new(PayReq)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/DecodePayReq", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) ListPayments(ctx context.Context, in *ListPaymentsRequest, opts ...grpc.CallOption) (*ListPaymentsResponse, error) {
	out := new(ListPaymentsResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/ListPayments", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) DeleteAllPayments(ctx context.Context, in *DeleteAllPaymentsRequest, opts ...grpc.CallOption) (*DeleteAllPaymentsResponse, error) {
	out := new(DeleteAllPaymentsResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/DeleteAllPayments", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) DescribeGraph(ctx context.Context, in *ChannelGraphRequest, opts ...grpc.CallOption) (*ChannelGraph, error) {
	out := new(ChannelGraph)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/DescribeGraph", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) GetChanInfo(ctx context.Context, in *ChanInfoRequest, opts ...grpc.CallOption) (*ChannelEdge, error) {
	out := new(ChannelEdge)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/GetChanInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) GetNodeInfo(ctx context.Context, in *NodeInfoRequest, opts ...grpc.CallOption) (*NodeInfo, error) {
	out := new(NodeInfo)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/GetNodeInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) QueryRoutes(ctx context.Context, in *QueryRoutesRequest, opts ...grpc.CallOption) (*QueryRoutesResponse, error) {
	out := new(QueryRoutesResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/QueryRoutes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) GetNetworkInfo(ctx context.Context, in *NetworkInfoRequest, opts ...grpc.CallOption) (*NetworkInfo, error) {
	out := new(NetworkInfo)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/GetNetworkInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) StopDaemon(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error) {
	out := new(StopResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/StopDaemon", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) SubscribeChannelGraph(ctx context.Context, in *GraphTopologySubscription, opts ...grpc.CallOption) (Lightning_SubscribeChannelGraphClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Lightning_serviceDesc.Streams[5], c.cc, "/lnrpc.Lightning/SubscribeChannelGraph", opts...)
	if err != nil {
		return nil, err
	}
	x := &lightningSubscribeChannelGraphClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Lightning_SubscribeChannelGraphClient interface {
	Recv() (*GraphTopologyUpdate, error)
	grpc.ClientStream
}

type lightningSubscribeChannelGraphClient struct {
	grpc.ClientStream
}

func (x *lightningSubscribeChannelGraphClient) Recv() (*GraphTopologyUpdate, error) {
	m := new(GraphTopologyUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lightningClient) SetAlias(ctx context.Context, in *SetAliasRequest, opts ...grpc.CallOption) (*SetAliasResponse, error) {
	out := new(SetAliasResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/SetAlias", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) DebugLevel(ctx context.Context, in *DebugLevelRequest, opts ...grpc.CallOption) (*DebugLevelResponse, error) {
	out := new(DebugLevelResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/DebugLevel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) FeeReport(ctx context.Context, in *FeeReportRequest, opts ...grpc.CallOption) (*FeeReportResponse, error) {
	out := new(FeeReportResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/FeeReport", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) UpdateFees(ctx context.Context, in *FeeUpdateRequest, opts ...grpc.CallOption) (*FeeUpdateResponse, error) {
	out := new(FeeUpdateResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/UpdateFees", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Lightning service

type LightningServer interface {
	// * lncli: `walletbalance`
	// WalletBalance returns the sum of all confirmed unspent outputs under control
	// by the wallet. This method can be modified by having the request specify
	// only witness outputs should be factored into the final output sum.
	WalletBalance(context.Context, *WalletBalanceRequest) (*WalletBalanceResponse, error)
	// * lncli: `channelbalance`
	// ChannelBalance returns the total funds available across all open channels
	// in satoshis.
	ChannelBalance(context.Context, *ChannelBalanceRequest) (*ChannelBalanceResponse, error)
	// * lncli: `listchaintxns`
	// GetTransactions returns a list describing all the known transactions
	// relevant to the wallet.
	GetTransactions(context.Context, *GetTransactionsRequest) (*TransactionDetails, error)
	// * lncli: `sendcoins`
	// SendCoins executes a request to send coins to a particular address. Unlike
	// SendMany, this RPC call only allows creating a single output at a time.
	SendCoins(context.Context, *SendCoinsRequest) (*SendCoinsResponse, error)
	// *
	// SubscribeTransactions creates a uni-directional stream from the server to
	// the client in which any newly discovered transactions relevant to the
	// wallet are sent over.
	SubscribeTransactions(*GetTransactionsRequest, Lightning_SubscribeTransactionsServer) error
	// * lncli: `sendmany`
	// SendMany handles a request for a transaction that creates multiple specified
	// outputs in parallel.
	SendMany(context.Context, *SendManyRequest) (*SendManyResponse, error)
	// * lncli: `newaddress`
	// NewAddress creates a new address under control of the local wallet.
	NewAddress(context.Context, *NewAddressRequest) (*NewAddressResponse, error)
	// *
	// NewWitnessAddress creates a new witness address under control of the local wallet.
	NewWitnessAddress(context.Context, *NewWitnessAddressRequest) (*NewAddressResponse, error)
	// * lncli: `signmessage`
	// SignMessage signs a message with this node's private key. The returned
	// signature string is `zbase32` encoded and pubkey recoverable, meaning that
	// only the message digest and signature are needed for verification.
	SignMessage(context.Context, *SignMessageRequest) (*SignMessageResponse, error)
	// * lncli: `verifymessage`
	// VerifyMessage verifies a signature over a msg. The signature must be
	// zbase32 encoded and signed by an active node in the resident node's
	// channel database. In addition to returning the validity of the signature,
	// VerifyMessage also returns the recovered pubkey from the signature.
	VerifyMessage(context.Context, *VerifyMessageRequest) (*VerifyMessageResponse, error)
	// * lncli: `connect`
	// ConnectPeer attempts to establish a connection to a remote peer. This is at
	// the networking level, and is used for communication between nodes. This is
	// distinct from establishing a channel with a peer.
	ConnectPeer(context.Context, *ConnectPeerRequest) (*ConnectPeerResponse, error)
	// * lncli: `disconnect`
	// DisconnectPeer attempts to disconnect one peer from another identified by a
	// given pubKey. In the case that we currently have a pending or active channel
	// with the target peer, then this action will be not be allowed.
	DisconnectPeer(context.Context, *DisconnectPeerRequest) (*DisconnectPeerResponse, error)
	// * lncli: `listpeers`
	// ListPeers returns a verbose listing of all currently active peers.
	ListPeers(context.Context, *ListPeersRequest) (*ListPeersResponse, error)
	// * lncli: `getinfo`
	// GetInfo returns general information concerning the lightning node including
	// it's identity pubkey, alias, the chains it is connected to, and information
	// concerning the number of open+pending channels.
	GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error)
	// * lncli: `pendingchannels`
	// PendingChannels returns a list of all the channels that are currently
	// considered "pending". A channel is pending if it has finished the funding
	// workflow and is waiting for confirmations for the funding txn, or is in the
	// process of closure, either initiated cooperatively or non-cooperatively.
	PendingChannels(context.Context, *PendingChannelRequest) (*PendingChannelResponse, error)
	// * lncli: `listchannels`
	// ListChannels returns a description of all the open channels that this node
	// is a participant in.
	ListChannels(context.Context, *ListChannelsRequest) (*ListChannelsResponse, error)
	// *
	// OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
	// call is meant to be consumed by clients to the REST proxy. As with all
	// other sync calls, all byte slices are intended to be populated as hex
	// encoded strings.
	OpenChannelSync(context.Context, *OpenChannelRequest) (*ChannelPoint, error)
	// * lncli: `openchannel`
	// OpenChannel attempts to open a singly funded channel specified in the
	// request to a remote peer.
	OpenChannel(*OpenChannelRequest, Lightning_OpenChannelServer) error
	// * lncli: `closechannel`
	// CloseChannel attempts to close an active channel identified by its channel
	// outpoint (ChannelPoint). The actions of this method can additionally be
	// augmented to attempt a force close after a timeout period in the case of an
	// inactive peer.
	CloseChannel(*CloseChannelRequest, Lightning_CloseChannelServer) error
	// * lncli: `sendpayment`
	// SendPayment dispatches a bi-directional streaming RPC for sending payments
	// through the Lightning Network. A single RPC invocation creates a persistent
	// bi-directional stream allowing clients to rapidly send payments through the
	// Lightning Network with a single persistent connection.
	SendPayment(Lightning_SendPaymentServer) error
	// *
	// SendPaymentSync is the synchronous non-streaming version of SendPayment.
	// This RPC is intended to be consumed by clients of the REST proxy.
	// Additionally, this RPC expects the destination's public key and the payment
	// hash (if any) to be encoded as hex strings.
	SendPaymentSync(context.Context, *SendRequest) (*SendResponse, error)
	// * lncli: `addinvoice`
	// AddInvoice attempts to add a new invoice to the invoice database. Any
	// duplicated invoices are rejected, therefore all invoices *must* have a
	// unique payment preimage.
	AddInvoice(context.Context, *Invoice) (*AddInvoiceResponse, error)
	// * lncli: `listinvoices`
	// ListInvoices returns a list of all the invoices currently stored within the
	// database. Any active debug invoices are ignored.
	ListInvoices(context.Context, *ListInvoiceRequest) (*ListInvoiceResponse, error)
	// * lncli: `lookupinvoice`
	// LookupInvoice attemps to look up an invoice according to its payment hash.
	// The passed payment hash *must* be exactly 32 bytes, if not, an error is
	// returned.
	LookupInvoice(context.Context, *PaymentHash) (*Invoice, error)
	// *
	// SubscribeInvoices returns a uni-directional stream (sever -> client) for
	// notifying the client of newly added/settled invoices.
	SubscribeInvoices(*InvoiceSubscription, Lightning_SubscribeInvoicesServer) error
	// * lncli: `decodepayreq`
	// DecodePayReq takes an encoded payment request string and attempts to decode
	// it, returning a full description of the conditions encoded within the
	// payment request.
	DecodePayReq(context.Context, *PayReqString) (*PayReq, error)
	// * lncli: `listpayments`
	// ListPayments returns a list of all outgoing payments.
	ListPayments(context.Context, *ListPaymentsRequest) (*ListPaymentsResponse, error)
	// *
	// DeleteAllPayments deletes all outgoing payments from DB.
	DeleteAllPayments(context.Context, *DeleteAllPaymentsRequest) (*DeleteAllPaymentsResponse, error)
	// * lncli: `describegraph`
	// DescribeGraph returns a description of the latest graph state from the
	// point of view of the node. The graph information is partitioned into two
	// components: all the nodes/vertexes, and all the edges that connect the
	// vertexes themselves.  As this is a directed graph, the edges also contain
	// the node directional specific routing policy which includes: the time lock
	// delta, fee information, etc.
	DescribeGraph(context.Context, *ChannelGraphRequest) (*ChannelGraph, error)
	// * lncli: `getchaninfo`
	// GetChanInfo returns the latest authenticated network announcement for the
	// given channel identified by its channel ID: an 8-byte integer which
	// uniquely identifies the location of transaction's funding output within the
	// blockchain.
	GetChanInfo(context.Context, *ChanInfoRequest) (*ChannelEdge, error)
	// * lncli: `getnodeinfo`
	// GetNodeInfo returns the latest advertised, aggregated, and authenticated
	// channel information for the specified node identified by its public key.
	GetNodeInfo(context.Context, *NodeInfoRequest) (*NodeInfo, error)
	// * lncli: `queryroutes`
	// QueryRoutes attempts to query the daemon's Channel Router for a possible
	// route to a target destination capable of carrying a specific amount of
	// satoshis. The retuned route contains the full details required to craft and
	// send an HTLC, also including the necessary information that should be
	// present within the Sphinx packet encapsualted within the HTLC.
	QueryRoutes(context.Context, *QueryRoutesRequest) (*QueryRoutesResponse, error)
	// * lncli: `getnetworkinfo`
	// GetNetworkInfo returns some basic stats about the known channel graph from
	// the point of view of the node.
	GetNetworkInfo(context.Context, *NetworkInfoRequest) (*NetworkInfo, error)
	// * lncli: `stop`
	// StopDaemon will send a shutdown request to the interrupt handler, triggering
	// a graceful shutdown of the daemon.
	StopDaemon(context.Context, *StopRequest) (*StopResponse, error)
	// *
	// SubscribeChannelGraph launches a streaming RPC that allows the caller to
	// receive notifications upon any changes to the channel graph topology from
	// the point of view of the responding node. Events notified include: new
	// nodes coming online, nodes updating their authenticated attributes, new
	// channels being advertised, updates in the routing policy for a directional
	// channel edge, and when channels are closed on-chain.
	SubscribeChannelGraph(*GraphTopologySubscription, Lightning_SubscribeChannelGraphServer) error
	// *
	// SetAlias sets the alias for this node; e.g. "alice"
	SetAlias(context.Context, *SetAliasRequest) (*SetAliasResponse, error)
	// * lncli: `debuglevel`
	// DebugLevel allows a caller to programmatically set the logging verbosity of
	// lnd. The logging can be targeted according to a coarse daemon-wide logging
	// level, or in a granular fashion to specify the logging for a target
	// sub-system.
	DebugLevel(context.Context, *DebugLevelRequest) (*DebugLevelResponse, error)
	// * lncli: `feereport`
	// FeeReport allows the caller to obtain a report detailing the current fee
	// schedule enforced by the node globally for each channel.
	FeeReport(context.Context, *FeeReportRequest) (*FeeReportResponse, error)
	// * lncli: `updatefees`
	// UpdateFees allows the caller to update the fee schedule for all channels
	// globally, or a particular channel.
	UpdateFees(context.Context, *FeeUpdateRequest) (*FeeUpdateResponse, error)
}

func RegisterLightningServer(s *grpc.Server, srv LightningServer) {
	s.RegisterService(&_Lightning_serviceDesc, srv)
}

func _Lightning_WalletBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WalletBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).WalletBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/WalletBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).WalletBalance(ctx, req.(*WalletBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_ChannelBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).ChannelBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/ChannelBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).ChannelBalance(ctx, req.(*ChannelBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_GetTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).GetTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/GetTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).GetTransactions(ctx, req.(*GetTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_SendCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendCoinsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).SendCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/SendCoins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).SendCoins(ctx, req.(*SendCoinsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_SubscribeTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetTransactionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LightningServer).SubscribeTransactions(m, &lightningSubscribeTransactionsServer{stream})
}

type Lightning_SubscribeTransactionsServer interface {
	Send(*Transaction) error
	grpc.ServerStream
}

type lightningSubscribeTransactionsServer struct {
	grpc.ServerStream
}

func (x *lightningSubscribeTransactionsServer) Send(m *Transaction) error {
	return x.ServerStream.SendMsg(m)
}

func _Lightning_SendMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendManyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).SendMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/SendMany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).SendMany(ctx, req.(*SendManyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_NewAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).NewAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/NewAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).NewAddress(ctx, req.(*NewAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_NewWitnessAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewWitnessAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).NewWitnessAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/NewWitnessAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).NewWitnessAddress(ctx, req.(*NewWitnessAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_SignMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).SignMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/SignMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).SignMessage(ctx, req.(*SignMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_VerifyMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).VerifyMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/VerifyMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).VerifyMessage(ctx, req.(*VerifyMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_ConnectPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).ConnectPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/ConnectPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).ConnectPeer(ctx, req.(*ConnectPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_DisconnectPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).DisconnectPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/DisconnectPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).DisconnectPeer(ctx, req.(*DisconnectPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_ListPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPeersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).ListPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/ListPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).ListPeers(ctx, req.(*ListPeersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/GetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).GetInfo(ctx, req.(*GetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_PendingChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PendingChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).PendingChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/PendingChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).PendingChannels(ctx, req.(*PendingChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_ListChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).ListChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/ListChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).ListChannels(ctx, req.(*ListChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_OpenChannelSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).OpenChannelSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/OpenChannelSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).OpenChannelSync(ctx, req.(*OpenChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_OpenChannel_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OpenChannelRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LightningServer).OpenChannel(m, &lightningOpenChannelServer{stream})
}

type Lightning_OpenChannelServer interface {
	Send(*OpenStatusUpdate) error
	grpc.ServerStream
}

type lightningOpenChannelServer struct {
	grpc.ServerStream
}

func (x *lightningOpenChannelServer) Send(m *OpenStatusUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _Lightning_CloseChannel_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CloseChannelRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LightningServer).CloseChannel(m, &lightningCloseChannelServer{stream})
}

type Lightning_CloseChannelServer interface {
	Send(*CloseStatusUpdate) error
	grpc.ServerStream
}

type lightningCloseChannelServer struct {
	grpc.ServerStream
}

func (x *lightningCloseChannelServer) Send(m *CloseStatusUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _Lightning_SendPayment_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LightningServer).SendPayment(&lightningSendPaymentServer{stream})
}

type Lightning_SendPaymentServer interface {
	Send(*SendResponse) error
	Recv() (*SendRequest, error)
	grpc.ServerStream
}

type lightningSendPaymentServer struct {
	grpc.ServerStream
}

func (x *lightningSendPaymentServer) Send(m *SendResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *lightningSendPaymentServer) Recv() (*SendRequest, error) {
	m := new(SendRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Lightning_SendPaymentSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).SendPaymentSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/SendPaymentSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).SendPaymentSync(ctx, req.(*SendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_AddInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Invoice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).AddInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/AddInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).AddInvoice(ctx, req.(*Invoice))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_ListInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).ListInvoices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/ListInvoices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).ListInvoices(ctx, req.(*ListInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_LookupInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaymentHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).LookupInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/LookupInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).LookupInvoice(ctx, req.(*PaymentHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_SubscribeInvoices_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InvoiceSubscription)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LightningServer).SubscribeInvoices(m, &lightningSubscribeInvoicesServer{stream})
}

type Lightning_SubscribeInvoicesServer interface {
	Send(*Invoice) error
	grpc.ServerStream
}

type lightningSubscribeInvoicesServer struct {
	grpc.ServerStream
}

func (x *lightningSubscribeInvoicesServer) Send(m *Invoice) error {
	return x.ServerStream.SendMsg(m)
}

func _Lightning_DecodePayReq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PayReqString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).DecodePayReq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/DecodePayReq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).DecodePayReq(ctx, req.(*PayReqString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_ListPayments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPaymentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).ListPayments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/ListPayments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).ListPayments(ctx, req.(*ListPaymentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_DeleteAllPayments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAllPaymentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).DeleteAllPayments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/DeleteAllPayments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).DeleteAllPayments(ctx, req.(*DeleteAllPaymentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_DescribeGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelGraphRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).DescribeGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/DescribeGraph",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).DescribeGraph(ctx, req.(*ChannelGraphRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_GetChanInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChanInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).GetChanInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/GetChanInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).GetChanInfo(ctx, req.(*ChanInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).GetNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/GetNodeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).GetNodeInfo(ctx, req.(*NodeInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_QueryRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRoutesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).QueryRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/QueryRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).QueryRoutes(ctx, req.(*QueryRoutesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_GetNetworkInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).GetNetworkInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/GetNetworkInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).GetNetworkInfo(ctx, req.(*NetworkInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_StopDaemon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).StopDaemon(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/StopDaemon",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).StopDaemon(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_SubscribeChannelGraph_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GraphTopologySubscription)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LightningServer).SubscribeChannelGraph(m, &lightningSubscribeChannelGraphServer{stream})
}

type Lightning_SubscribeChannelGraphServer interface {
	Send(*GraphTopologyUpdate) error
	grpc.ServerStream
}

type lightningSubscribeChannelGraphServer struct {
	grpc.ServerStream
}

func (x *lightningSubscribeChannelGraphServer) Send(m *GraphTopologyUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _Lightning_SetAlias_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAliasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).SetAlias(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/SetAlias",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).SetAlias(ctx, req.(*SetAliasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_DebugLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DebugLevelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).DebugLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/DebugLevel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).DebugLevel(ctx, req.(*DebugLevelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_FeeReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeeReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).FeeReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/FeeReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).FeeReport(ctx, req.(*FeeReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_UpdateFees_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeeUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).UpdateFees(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/UpdateFees",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).UpdateFees(ctx, req.(*FeeUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Lightning_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lnrpc.Lightning",
	HandlerType: (*LightningServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WalletBalance",
			Handler:    _Lightning_WalletBalance_Handler,
		},
		{
			MethodName: "ChannelBalance",
			Handler:    _Lightning_ChannelBalance_Handler,
		},
		{
			MethodName: "GetTransactions",
			Handler:    _Lightning_GetTransactions_Handler,
		},
		{
			MethodName: "SendCoins",
			Handler:    _Lightning_SendCoins_Handler,
		},
		{
			MethodName: "SendMany",
			Handler:    _Lightning_SendMany_Handler,
		},
		{
			MethodName: "NewAddress",
			Handler:    _Lightning_NewAddress_Handler,
		},
		{
			MethodName: "NewWitnessAddress",
			Handler:    _Lightning_NewWitnessAddress_Handler,
		},
		{
			MethodName: "SignMessage",
			Handler:    _Lightning_SignMessage_Handler,
		},
		{
			MethodName: "VerifyMessage",
			Handler:    _Lightning_VerifyMessage_Handler,
		},
		{
			MethodName: "ConnectPeer",
			Handler:    _Lightning_ConnectPeer_Handler,
		},
		{
			MethodName: "DisconnectPeer",
			Handler:    _Lightning_DisconnectPeer_Handler,
		},
		{
			MethodName: "ListPeers",
			Handler:    _Lightning_ListPeers_Handler,
		},
		{
			MethodName: "GetInfo",
			Handler:    _Lightning_GetInfo_Handler,
		},
		{
			MethodName: "PendingChannels",
			Handler:    _Lightning_PendingChannels_Handler,
		},
		{
			MethodName: "ListChannels",
			Handler:    _Lightning_ListChannels_Handler,
		},
		{
			MethodName: "OpenChannelSync",
			Handler:    _Lightning_OpenChannelSync_Handler,
		},
		{
			MethodName: "SendPaymentSync",
			Handler:    _Lightning_SendPaymentSync_Handler,
		},
		{
			MethodName: "AddInvoice",
			Handler:    _Lightning_AddInvoice_Handler,
		},
		{
			MethodName: "ListInvoices",
			Handler:    _Lightning_ListInvoices_Handler,
		},
		{
			MethodName: "LookupInvoice",
			Handler:    _Lightning_LookupInvoice_Handler,
		},
		{
			MethodName: "DecodePayReq",
			Handler:    _Lightning_DecodePayReq_Handler,
		},
		{
			MethodName: "ListPayments",
			Handler:    _Lightning_ListPayments_Handler,
		},
		{
			MethodName: "DeleteAllPayments",
			Handler:    _Lightning_DeleteAllPayments_Handler,
		},
		{
			MethodName: "DescribeGraph",
			Handler:    _Lightning_DescribeGraph_Handler,
		},
		{
			MethodName: "GetChanInfo",
			Handler:    _Lightning_GetChanInfo_Handler,
		},
		{
			MethodName: "GetNodeInfo",
			Handler:    _Lightning_GetNodeInfo_Handler,
		},
		{
			MethodName: "QueryRoutes",
			Handler:    _Lightning_QueryRoutes_Handler,
		},
		{
			MethodName: "GetNetworkInfo",
			Handler:    _Lightning_GetNetworkInfo_Handler,
		},
		{
			MethodName: "StopDaemon",
			Handler:    _Lightning_StopDaemon_Handler,
		},
		{
			MethodName: "SetAlias",
			Handler:    _Lightning_SetAlias_Handler,
		},
		{
			MethodName: "DebugLevel",
			Handler:    _Lightning_DebugLevel_Handler,
		},
		{
			MethodName: "FeeReport",
			Handler:    _Lightning_FeeReport_Handler,
		},
		{
			MethodName: "UpdateFees",
			Handler:    _Lightning_UpdateFees_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeTransactions",
			Handler:       _Lightning_SubscribeTransactions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "OpenChannel",
			Handler:       _Lightning_OpenChannel_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CloseChannel",
			Handler:       _Lightning_CloseChannel_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SendPayment",
			Handler:       _Lightning_SendPayment_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SubscribeInvoices",
			Handler:       _Lightning_SubscribeInvoices_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeChannelGraph",
			Handler:       _Lightning_SubscribeChannelGraph_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rpc.proto",
}

func init() { proto.RegisterFile("rpc.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 4501 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x7b, 0x5d, 0x6f, 0x1c, 0x4b,
	0x5a, 0x7f, 0x7a, 0x3c, 0x63, 0xcf, 0x3c, 0x33, 0xe3, 0x97, 0xf2, 0xdb, 0x64, 0x92, 0x93, 0x4d,
	0x6a, 0xa3, 0x13, 0xff, 0xbd, 0x2b, 0x3b, 0xf1, 0xfe, 0xf7, 0x90, 0x4d, 0x80, 0x23, 0xe7, 0xd5,
	0x87, 0xf5, 0xc9, 0xf1, 0xb6, 0x73, 0x4e, 0x60, 0x57, 0xa8, 0x69, 0x4f, 0x97, 0xc7, 0xbd, 0xe9,
	0xe9, 0xee, 0xd3, 0x5d, 0x13, 0x67, 0x36, 0x8a, 0x84, 0x0e, 0x08, 0x6e, 0x40, 0x2b, 0xb4, 0x08,
	0xc4, 0x0d, 0x5a, 0x09, 0x71, 0x09, 0x5f, 0x80, 0x6f, 0x80, 0x40, 0x42, 0xda, 0x2b, 0x6e, 0xb8,
	0xe2, 0x0b, 0x70, 0xc1, 0x3d, 0xaa, 0xd7, 0xae, 0xea, 0x6e, 0x27, 0x41, 0x20, 0xae, 0x3c, 0xf5,
	0xab, 0xa7, 0x9f, 0xaa, 0x7a, 0xea, 0xa9, 0xe7, 0xad, 0xca, 0xd0, 0xc9, 0xd2, 0xd1, 0x4e, 0x9a,
	0x25, 0x34, 0x41, 0xad, 0x28, 0xce, 0xd2, 0xd1, 0xf0, 0xea, 0x38, 0x49, 0xc6, 0x11, 0xd9, 0xf5,
	0xd3, 0x70, 0xd7, 0x8f, 0xe3, 0x84, 0xfa, 0x34, 0x4c, 0xe2, 0x5c, 0x10, 0xe1, 0xff, 0x70, 0xa0,
	0xfb, 0x3c, 0xf3, 0xe3, 0xdc, 0x1f, 0x31, 0x18, 0x0d, 0x60, 0x81, 0xbe, 0xf6, 0xce, 0xfc, 0xfc,
	0x6c, 0xe0, 0x5c, 0x77, 0xb6, 0x3a, 0xae, 0x6a, 0xa2, 0x0d, 0x98, 0xf7, 0x27, 0xc9, 0x34, 0xa6,
	0x83, 0xc6, 0x75, 0x67, 0x6b, 0xce, 0x95, 0x2d, 0xf4, 0x5d, 0x58, 0x89, 0xa7, 0x13, 0x6f, 0x94,
	0xc4, 0xa7, 0x61, 0x36, 0x11, 0xcc, 0x07, 0x73, 0xd7, 0x9d, 0xad, 0x96, 0x5b, 0xed, 0x40, 0xd7,
	0x00, 0x4e, 0xa2, 0x64, 0xf4, 0x52, 0x0c, 0xd1, 0xe4, 0x43, 0x18, 0x08, 0xc2, 0xd0, 0x93, 0x2d,
	0x12, 0x8e, 0xcf, 0xe8, 0xa0, 0xc5, 0x19, 0x59, 0x18, 0xe3, 0x41, 0xc3, 0x09, 0xf1, 0x72, 0xea,
	0x4f, 0xd2, 0xc1, 0x3c, 0x9f, 0x8d, 0x81, 0xf0, 0xfe, 0x84, 0xfa, 0x91, 0x77, 0x4a, 0x48, 0x3e,
	0x58, 0x90, 0xfd, 0x1a, 0xc1, 0x03, 0xd8, 0x78, 0x4a, 0xa8, 0xb1, 0xea, 0xdc, 0x25, 0x5f, 0x4f,
	0x49, 0x4e, 0xf1, 0x21, 0x20, 0x03, 0x7e, 0x44, 0xa8, 0x1f, 0x46, 0x39, 0xfa, 0x04, 0x7a, 0xd4,
	0x20, 0x1e, 0x38, 0xd7, 0xe7, 0xb6, 0xba, 0x7b, 0x68, 0x87, 0xcb, 0x77, 0xc7, 0xf8, 0xc0, 0xb5,
	0xe8, 0xf0, 0xbf, 0x38, 0xd0, 0x3d, 0x26, 0x71, 0x20, 0xb9, 0x23, 0x04, 0xcd, 0x80, 0xe4, 0x94,
	0x0b, 0xb6, 0xe7, 0xf2, 0xdf, 0xe8, 0x5b, 0xd0, 0x65, 0x7f, 0xbd, 0x9c, 0x66, 0x61, 0x3c, 0xe6,
	0xa2, 0xed, 0xb8, 0xc0, 0xa0, 0x63, 0x8e, 0xa0, 0x65, 0x98, 0xf3, 0x27, 0x94, 0x0b, 0x74, 0xce,
	0x65, 0x3f, 0xd1, 0x0d, 0xe8, 0xa5, 0xfe, 0x6c, 0x42, 0x62, 0x5a, 0x08, 0xb1, 0xe7, 0x76, 0x25,
	0x76, 0xc0, 0xa4, 0xb8, 0x03, 0xab, 0x26, 0x89, 0xe2, 0xde, 0xe2, 0xdc, 0x57, 0x0c, 0x4a, 0x39,
	0xc8, 0x2d, 0x58, 0x52, 0xf4, 0x99, 0x98, 0x2c, 0x17, 0x6b, 0xc7, 0x5d, 0x94, 0xb0, 0x12, 0xd0,
	0x9f, 0x3b, 0xd0, 0x13, 0x4b, 0xca, 0xd3, 0x24, 0xce, 0x09, 0xba, 0x09, 0x7d, 0xf5, 0x25, 0xc9,
	0xb2, 0x24, 0x93, 0x5a, 0x63, 0x83, 0x68, 0x1b, 0x96, 0x15, 0x90, 0x66, 0x24, 0x9c, 0xf8, 0x63,
	0xc2, 0x97, 0xda, 0x73, 0x2b, 0x38, 0xda, 0x2b, 0x38, 0x66, 0xc9, 0x94, 0x12, 0xbe, 0xf4, 0xee,
	0x5e, 0x4f, 0x8a, 0xdb, 0x65, 0x98, 0x6b, 0x93, 0xe0, 0x6f, 0x1c, 0xe8, 0x3d, 0x3c, 0xf3, 0xe3,
	0x98, 0x44, 0x47, 0x49, 0x18, 0x53, 0xa6, 0x46, 0xa7, 0xd3, 0x38, 0x08, 0xe3, 0xb1, 0x47, 0x5f,
	0x87, 0x81, 0x14, 0xb9, 0x85, 0xb1, 0x49, 0x99, 0x6d, 0x26, 0x24, 0x29, 0xff, 0x0a, 0xce, 0xf8,
	0x25, 0x53, 0x9a, 0x4e, 0xa9, 0x17, 0xc6, 0x01, 0x79, 0xcd, 0xe7, 0xd4, 0x77, 0x2d, 0x0c, 0xff,
	0x26, 0x2c, 0x1f, 0x32, 0xfd, 0x8c, 0xc3, 0x78, 0xbc, 0x1f, 0x04, 0x19, 0xc9, 0x73, 0x76, 0x68,
	0xd2, 0xe9, 0xc9, 0x4b, 0x32, 0x93, 0x72, 0x91, 0x2d, 0xa6, 0x0a, 0x67, 0x49, 0x4e, 0xe5, 0x78,
	0xfc, 0x37, 0xfe, 0xa5, 0x03, 0x4b, 0x4c, 0xb6, 0x9f, 0xfb, 0xf1, 0x4c, 0xa9, 0xcc, 0x21, 0xf4,
	0x18, 0xab, 0xe7, 0xc9, 0xbe, 0x38, 0x7a, 0x42, 0xf5, 0xb6, 0xa4, 0x2c, 0x4a, 0xd4, 0x3b, 0x26,
	0xe9, 0xe3, 0x98, 0x66, 0x33, 0xd7, 0xfa, 0x7a, 0xf8, 0x29, 0xac, 0x54, 0x48, 0x98, 0x82, 0x15,
	0xf3, 0x63, 0x3f, 0xd1, 0x1a, 0xb4, 0x5e, 0xf9, 0xd1, 0x94, 0xc8, 0x83, 0x2e, 0x1a, 0xf7, 0x1a,
	0x77, 0x1d, 0xfc, 0x31, 0x2c, 0x17, 0x63, 0x4a, 0x0d, 0x40, 0xd0, 0xd4, 0x22, 0xee, 0xb8, 0xfc,
	0x37, 0x13, 0x05, 0xa3, 0x7b, 0x98, 0x84, 0xfa, 0x6c, 0x31, 0x3a, 0x3f, 0x08, 0x94, 0x82, 0xf0,
	0xdf, 0x17, 0xd9, 0x14, 0x7c, 0x0b, 0x56, 0x8c, 0xef, 0xdf, 0x31, 0xd0, 0x5f, 0x3b, 0xb0, 0xf2,
	0x8c, 0x9c, 0x4b, 0x71, 0xab, 0xa1, 0xee, 0x42, 0x93, 0xce, 0x52, 0xc2, 0x29, 0x17, 0xf7, 0x6e,
	0x4a, 0x69, 0x55, 0xe8, 0x76, 0x64, 0xf3, 0xf9, 0x2c, 0x25, 0x2e, 0xff, 0x02, 0x7f, 0x01, 0x5d,
	0x03, 0x44, 0x9b, 0xb0, 0xfa, 0xe2, 0xb3, 0xe7, 0xcf, 0x1e, 0x1f, 0x1f, 0x7b, 0x47, 0x5f, 0x3e,
	0xf8, 0xe1, 0xe3, 0xdf, 0xf1, 0x0e, 0xf6, 0x8f, 0x0f, 0x96, 0x2f, 0xa1, 0x0d, 0x40, 0xcf, 0x1e,
	0x1f, 0x3f, 0x7f, 0xfc, 0xc8, 0xc2, 0x1d, 0xb4, 0x04, 0x5d, 0x13, 0x68, 0xe0, 0x21, 0x0c, 0x9e,
	0x91, 0xf3, 0x17, 0x21, 0x8d, 0x49, 0x9e, 0xdb, 0xc3, 0xe3, 0x1d, 0x40, 0xe6, 0x9c, 0xe4, 0x32,
	0x07, 0xb0, 0xe0, 0x0b, 0x48, 0x59, 0x60, 0xd9, 0xc4, 0x1f, 0x03, 0x3a, 0x0e, 0xc7, 0xf1, 0xe7,
	0x24, 0xcf, 0xfd, 0x31, 0x51, 0x8b, 0x5d, 0x86, 0xb9, 0x49, 0x3e, 0x96, 0x1a, 0xce, 0x7e, 0xe2,
	0xef, 0xc1, 0xaa, 0x45, 0x27, 0x19, 0x5f, 0x85, 0x4e, 0x1e, 0x8e, 0x63, 0x9f, 0x4e, 0x33, 0x22,
	0x59, 0x17, 0x00, 0x7e, 0x02, 0x6b, 0x5f, 0x91, 0x2c, 0x3c, 0x9d, 0xbd, 0x8f, 0xbd, 0xcd, 0xa7,
	0x51, 0xe6, 0xf3, 0x18, 0xd6, 0x4b, 0x7c, 0xe4, 0xf0, 0x42, 0xab, 0xe4, 0xfe, 0xb5, 0x5d, 0xd1,
	0x30, 0x0e, 0x48, 0xc3, 0x3c, 0x20, 0xf8, 0x4b, 0x40, 0x0f, 0x93, 0x38, 0x26, 0x23, 0x7a, 0x44,
	0x48, 0xa6, 0x26, 0xf3, 0x1d, 0x43, 0x87, 0xba, 0x7b, 0x9b, 0x72, 0x63, 0xcb, 0xa7, 0x4e, 0x2a,
	0x17, 0x82, 0x66, 0x4a, 0xb2, 0x09, 0x67, 0xdc, 0x76, 0xf9, 0x6f, 0xbc, 0x0b, 0xab, 0x16, 0xdb,
	0x42, 0xe6, 0x29, 0x21, 0x99, 0x27, 0x67, 0xd7, 0x72, 0x55, 0x13, 0xdf, 0x81, 0xf5, 0x47, 0x61,
	0x3e, 0xaa, 0x4e, 0x85, 0x7d, 0x32, 0x3d, 0xf1, 0x8a, 0xa3, 0xa3, 0x9a, 0xcc, 0xbd, 0x94, 0x3f,
	0x11, 0xc3, 0xe0, 0x3f, 0x72, 0xa0, 0x79, 0xf0, 0xfc, 0xf0, 0x21, 0x1a, 0x42, 0x3b, 0x8c, 0x47,
	0xc9, 0x84, 0x19, 0x65, 0x21, 0x0e, 0xdd, 0xbe, 0xd0, 0xcf, 0x5e, 0x85, 0x0e, 0xb7, 0xe5, 0xcc,
	0x13, 0x72, 0xfb, 0xd3, 0x73, 0x0b, 0x80, 0x79, 0x61, 0xf2, 0x3a, 0x0d, 0x33, 0xee, 0x66, 0x95,
	0xf3, 0x6c, 0x72, 0x2b, 0x55, 0xed, 0xc0, 0xff, 0xd4, 0x84, 0xfe, 0xfe, 0x88, 0x86, 0xaf, 0x88,
	0xb4, 0x9a, 0x7c, 0x54, 0x0e, 0xc8, 0xf9, 0xc8, 0x16, 0xb3, 0xef, 0x19, 0x99, 0x24, 0x94, 0x78,
	0xd6, 0x36, 0xd9, 0x20, 0xa3, 0x1a, 0x09, 0x46, 0x5e, 0xca, 0xec, 0x2f, 0x9f, 0x5f, 0xc7, 0xb5,
	0x41, 0x26, 0x32, 0x06, 0x30, 0x29, 0xb3, 0x99, 0x35, 0x5d, 0xd5, 0x64, 0xf2, 0x18, 0xf9, 0xa9,
	0x3f, 0x0a, 0xe9, 0x8c, 0x3b, 0xa9, 0x39, 0x57, 0xb7, 0x19, 0xef, 0x28, 0x19, 0xf9, 0x91, 0x77,
	0xe2, 0x47, 0x7e, 0x3c, 0x22, 0xd2, 0xe1, 0xdb, 0x20, 0xfa, 0x18, 0x16, 0xe5, 0x94, 0x14, 0x99,
	0xf0, 0xfb, 0x25, 0x94, 0xc5, 0x06, 0xa3, 0x64, 0x32, 0x09, 0x29, 0x0b, 0x05, 0x06, 0x6d, 0x11,
	0x1b, 0x14, 0x08, 0x5f, 0x89, 0x68, 0x9d, 0x0b, 0x19, 0x76, 0xc4, 0x68, 0x16, 0xc8, 0xb8, 0x9c,
	0x12, 0xe2, 0xa5, 0x24, 0xf3, 0x5e, 0x9e, 0x0f, 0x40, 0x70, 0x29, 0x10, 0xb6, 0x1b, 0xd3, 0x38,
	0x27, 0x94, 0x46, 0x24, 0xd0, 0x13, 0xea, 0x72, 0xb2, 0x6a, 0x07, 0xba, 0x0d, 0xab, 0x22, 0x3a,
	0xc9, 0x7d, 0x9a, 0xe4, 0x67, 0x61, 0xee, 0xe5, 0x24, 0xa6, 0x83, 0x1e, 0xa7, 0xaf, 0xeb, 0x42,
	0x77, 0x61, 0xb3, 0x04, 0x67, 0x64, 0x44, 0xc2, 0x57, 0x24, 0x18, 0xf4, 0xf9, 0x57, 0x17, 0x75,
	0xa3, 0xeb, 0xd0, 0x65, 0x41, 0xd9, 0x34, 0x0d, 0x7c, 0x4a, 0xf2, 0xc1, 0x22, 0xdf, 0x07, 0x13,
	0x42, 0x77, 0xa0, 0x9f, 0x12, 0xe1, 0xfe, 0xce, 0x68, 0x34, 0xca, 0x07, 0x4b, 0xdc, 0xe7, 0x74,
	0xe5, 0x61, 0x63, 0xfa, 0xeb, 0xda, 0x14, 0x78, 0x1d, 0x56, 0x0f, 0xc3, 0x9c, 0x4a, 0x5d, 0xd2,
	0xf6, 0xed, 0x00, 0xd6, 0x6c, 0x58, 0x9e, 0xb6, 0xdb, 0xd0, 0x96, 0x8a, 0x91, 0x0f, 0xba, 0x9c,
	0xf9, 0x9a, 0x64, 0x6e, 0xe9, 0xa4, 0xab, 0xa9, 0xf0, 0x1f, 0x36, 0xa0, 0xc9, 0x4e, 0xd2, 0xc5,
	0xa7, 0xce, 0x3c, 0xc2, 0x0d, 0xeb, 0x08, 0x9b, 0x06, 0x75, 0xce, 0x32, 0xa8, 0x3c, 0x18, 0x9d,
	0x51, 0x22, 0xe5, 0x2d, 0x74, 0xd2, 0x40, 0x8a, 0xfe, 0x8c, 0x8c, 0x5e, 0x71, 0xc5, 0xd4, 0xfd,
	0x0c, 0x61, 0x6a, 0x9b, 0xfb, 0x54, 0x7c, 0x2d, 0xb4, 0x52, 0xb7, 0x55, 0x1f, 0xff, 0x72, 0xa1,
	0xe8, 0xe3, 0xdf, 0x0d, 0x60, 0x21, 0x8c, 0x4f, 0x92, 0x69, 0x1c, 0x70, 0x0d, 0x6c, 0xbb, 0xaa,
	0xc9, 0x0e, 0x79, 0xca, 0x03, 0x8f, 0x70, 0x42, 0xa4, 0xea, 0x15, 0x00, 0x46, 0x2c, 0xc2, 0xc8,
	0xb9, 0x4d, 0xd1, 0x42, 0xfe, 0x04, 0x56, 0x0c, 0x4c, 0x4a, 0xf8, 0x06, 0xb4, 0xd8, 0xea, 0x55,
	0xa8, 0xaa, 0xf6, 0x8e, 0x1b, 0x23, 0xd1, 0x83, 0x97, 0x61, 0xf1, 0x29, 0xa1, 0x9f, 0xc5, 0xa7,
	0x89, 0xe2, 0xf4, 0x9f, 0x0d, 0x58, 0xd2, 0x90, 0x64, 0xb4, 0x05, 0x4b, 0x61, 0x40, 0x62, 0x1a,
	0xd2, 0x99, 0x67, 0x05, 0x32, 0x65, 0x98, 0x99, 0x77, 0x3f, 0x0a, 0xfd, 0x5c, 0x1a, 0x08, 0xd1,
	0x40, 0x7b, 0xb0, 0xc6, 0x74, 0x4b, 0xa9, 0x8b, 0xde, 0x76, 0x11, 0x3f, 0xd5, 0xf6, 0xb1, 0xe3,
	0xc0, 0x70, 0x61, 0x80, 0x8a, 0x4f, 0x84, 0x31, 0xab, 0xeb, 0x62, 0x52, 0x13, 0x9c, 0xd8, 0x92,
	0x5b, 0x9c, 0xae, 0x00, 0x2a, 0x29, 0xc5, 0xbc, 0x88, 0xdd, 0xca, 0x29, 0x85, 0x91, 0x96, 0xb4,
	0x2b, 0x69, 0xc9, 0x16, 0x2c, 0xe5, 0xb3, 0x78, 0x44, 0x02, 0x8f, 0x26, 0x6c, 0xdc, 0x30, 0xe6,
	0xbb, 0xd3, 0x76, 0xcb, 0x30, 0x4f, 0xa0, 0x48, 0x4e, 0x63, 0x42, 0xb9, 0x5d, 0x68, 0xbb, 0xaa,
	0xc9, 0x4c, 0x2c, 0x27, 0x11, 0x4a, 0xdf, 0x71, 0x65, 0x0b, 0xff, 0x8c, 0xbb, 0x3a, 0x9d, 0x23,
	0x7d, 0xc9, 0xcf, 0x21, 0xba, 0x02, 0x1d, 0x31, 0x7e, 0x7e, 0xe6, 0x4b, 0xef, 0xdb, 0xe6, 0xc0,
	0xf1, 0x99, 0xcf, 0x52, 0x00, 0x6b, 0x49, 0x42, 0xe3, 0xbb, 0x1c, 0x3b, 0x10, 0x2b, 0xba, 0x09,
	0x8b, 0x2a, 0xfb, 0xca, 0xbd, 0x88, 0x9c, 0x52, 0x15, 0xb3, 0xc6, 0xd3, 0x09, 0x1b, 0x2e, 0x3f,
	0x24, 0xa7, 0x14, 0x3f, 0x83, 0x15, 0x79, 0xda, 0xbe, 0x48, 0x89, 0x1a, 0xfa, 0x07, 0x65, 0x6b,
	0x2e, 0xdc, 0xed, 0xaa, 0xd4, 0x22, 0x33, 0xd0, 0x2e, 0x99, 0x78, 0xec, 0x02, 0x92, 0xdd, 0x0f,
	0xa3, 0x24, 0x27, 0x92, 0x21, 0x86, 0xde, 0x28, 0x4a, 0xf2, 0x72, 0x34, 0x6e, 0x62, 0x4c, 0x6e,
	0xf9, 0x74, 0x34, 0x62, 0xa7, 0x54, 0x38, 0x6c, 0xd5, 0xc4, 0x04, 0x56, 0x39, 0x33, 0x65, 0x16,
	0x74, 0x90, 0xf7, 0xe1, 0xb3, 0xec, 0x8d, 0xcc, 0xe4, 0x60, 0x0d, 0x5a, 0xa7, 0x49, 0x36, 0x22,
	0x72, 0x20, 0xd1, 0xc0, 0xff, 0xea, 0xc0, 0x0a, 0x1f, 0xe7, 0x98, 0xfa, 0x74, 0x9a, 0xcb, 0xa9,
	0xff, 0x3a, 0xf4, 0xd9, 0x34, 0x89, 0x52, 0x53, 0x39, 0xca, 0x9a, 0x3e, 0x51, 0x1c, 0x15, 0xc4,
	0x07, 0x97, 0x5c, 0x9b, 0x18, 0x7d, 0x0a, 0x3d, 0x33, 0xfd, 0xe5, 0x03, 0x76, 0xf7, 0x2e, 0xab,
	0x29, 0x56, 0x76, 0xfd, 0xe0, 0x92, 0x6b, 0x7d, 0x80, 0xee, 0x03, 0x70, 0x1f, 0xc9, 0xd9, 0xca,
	0x4c, 0xe8, 0xb2, 0xbd, 0x42, 0x43, 0xd0, 0x07, 0x97, 0x5c, 0x83, 0xfc, 0x41, 0x1b, 0xe6, 0x85,
	0x51, 0xc7, 0x4f, 0xa1, 0x6f, 0xcd, 0xd4, 0x8a, 0xa5, 0x7b, 0x22, 0x96, 0xae, 0xe4, 0x38, 0x8d,
	0x9a, 0x1c, 0xe7, 0xdf, 0x1c, 0x40, 0x4c, 0x53, 0x4a, 0x7b, 0xf1, 0x31, 0x2c, 0x52, 0x3f, 0x1b,
	0x13, 0xea, 0xd9, 0x61, 0x54, 0x09, 0xe5, 0xde, 0x27, 0x09, 0xac, 0x58, 0xa2, 0xe7, 0x9a, 0x10,
	0xda, 0x01, 0x64, 0x34, 0x55, 0xe2, 0x2a, 0xec, 0x76, 0x4d, 0x0f, 0x33, 0x30, 0x22, 0x10, 0x50,
	0x29, 0x9b, 0x8c, 0x9d, 0x9a, 0xdc, 0x76, 0xd6, 0xf6, 0x31, 0xd3, 0x9c, 0x4e, 0x59, 0x56, 0xec,
	0x53, 0x15, 0x6d, 0xa8, 0x36, 0xfe, 0x95, 0x03, 0xcb, 0x6c, 0x81, 0x96, 0x12, 0xdc, 0x03, 0xae,
	0x40, 0x1f, 0xa8, 0x03, 0x16, 0xed, 0xff, 0x5c, 0x05, 0xee, 0x42, 0x87, 0x33, 0x4c, 0x52, 0x12,
	0x4b, 0x0d, 0x18, 0xd8, 0x1a, 0x50, 0x1c, 0xdd, 0x83, 0x4b, 0x6e, 0x41, 0x6c, 0xec, 0xff, 0x26,
	0xac, 0xcb, 0x59, 0xda, 0x1b, 0x87, 0xff, 0x18, 0x60, 0xa3, 0xdc, 0xa3, 0xbd, 0xb4, 0x0c, 0x3d,
	0xa2, 0x70, 0x72, 0x92, 0xe8, 0x28, 0xc6, 0x31, 0xa3, 0x12, 0xab, 0x0b, 0x9d, 0xc2, 0xba, 0x32,
	0xe6, 0x6c, 0xfc, 0xc2, 0x74, 0x37, 0xb8, 0x17, 0xba, 0x6d, 0xcb, 0xab, 0x34, 0x9e, 0x82, 0x4d,
	0xed, 0xaa, 0x67, 0x87, 0xc6, 0x30, 0xd0, 0x4e, 0x43, 0x9a, 0x10, 0xc3, 0xb1, 0xb0, 0xa1, 0xbe,
	0xf3, 0xee, 0xa1, 0xf8, 0x91, 0x09, 0x14, 0x7a, 0x21, 0x33, 0xf4, 0x1a, 0xae, 0xa9, 0x3e, 0x6e,
	0x23, 0xaa, 0xc3, 0x35, 0x3f, 0x64, 0x65, 0x4f, 0xd8, 0xb7, 0xf6, 0x98, 0xef, 0xe1, 0x3b, 0xfc,
	0x47, 0x07, 0x16, 0x6d, 0x6e, 0xcc, 0x05, 0xc9, 0x58, 0x56, 0x1d, 0x03, 0xe5, 0x8a, 0x4b, 0x70,
	0x35, 0x1a, 0x6f, 0xd4, 0x45, 0xe3, 0x66, 0xcc, 0x3d, 0xf7, 0xbe, 0x98, 0xbb, 0xf9, 0x61, 0x31,
	0x77, 0xab, 0x2e, 0xe6, 0x1e, 0xfe, 0xb2, 0x01, 0xa8, 0xba, 0xbb, 0xe8, 0x89, 0x48, 0x07, 0x62,
	0x12, 0xc9, 0x03, 0xf5, 0xdd, 0x0f, 0x52, 0x10, 0x05, 0xab, 0x8f, 0x99, 0xa2, 0x9a, 0x07, 0xc6,
	0xf4, 0x89, 0x7d, 0xb7, 0xae, 0x0b, 0x6d, 0xc3, 0x32, 0x77, 0x95, 0xb9, 0x47, 0xc3, 0x28, 0x2a,
	0x4e, 0x56, 0xdf, 0xad, 0xe0, 0xa5, 0x84, 0xa1, 0xf9, 0xfe, 0x84, 0xa1, 0xf5, 0xfe, 0x84, 0x61,
	0xbe, 0x9c, 0x30, 0x0c, 0xdf, 0x40, 0xdf, 0x52, 0x90, 0xff, 0x35, 0xe1, 0x94, 0x5d, 0xaf, 0x50,
	0x05, 0x0b, 0x1b, 0x7e, 0xd3, 0x00, 0x54, 0xd5, 0xd1, 0xff, 0xcb, 0x29, 0x70, 0x85, 0xb3, 0xcc,
	0xcc, 0x9c, 0x54, 0x38, 0xcb, 0xc0, 0x6c, 0xc1, 0xd2, 0xc4, 0xa7, 0xd3, 0x8c, 0x85, 0x9d, 0x56,
	0x8a, 0x5b, 0x86, 0x99, 0x4e, 0x14, 0x3b, 0xe9, 0xa9, 0x5e, 0x19, 0x1b, 0xd6, 0x75, 0xe1, 0x1f,
	0xc0, 0xda, 0x0b, 0x3f, 0x8a, 0x08, 0x7d, 0x20, 0x06, 0x53, 0xae, 0xed, 0x06, 0xf4, 0xce, 0x45,
	0xf5, 0xc6, 0x4b, 0xe2, 0x68, 0x26, 0xd3, 0xe3, 0xae, 0xc4, 0xbe, 0x88, 0xa3, 0x19, 0xbe, 0x03,
	0xeb, 0xa5, 0x4f, 0x8b, 0xb2, 0x82, 0x6d, 0x36, 0x55, 0x93, 0x19, 0x64, 0x29, 0x27, 0x7b, 0x38,
	0xbc, 0x07, 0x1b, 0xe5, 0x8e, 0xf7, 0x32, 0xfb, 0x14, 0xd0, 0x8f, 0xa6, 0x24, 0x9b, 0xf1, 0xd2,
	0xa8, 0x2e, 0x82, 0x6d, 0x96, 0x53, 0xa5, 0xf9, 0x74, 0x7a, 0xf2, 0x43, 0x32, 0x53, 0x15, 0xe5,
	0x86, 0xae, 0x28, 0xe3, 0xfb, 0xb0, 0x6a, 0x31, 0xd0, 0xb5, 0xdd, 0x79, 0x5e, 0x5e, 0x55, 0x69,
	0x84, 0x5d, 0x82, 0x95, 0x7d, 0xf8, 0x2f, 0x1d, 0x98, 0x3b, 0x48, 0x52, 0x33, 0xbb, 0x77, 0xec,
	0xec, 0x5e, 0xda, 0x23, 0x4f, 0x9b, 0x9b, 0x86, 0x3c, 0x22, 0x26, 0xc8, 0xac, 0x89, 0x3f, 0xa1,
	0x2c, 0x90, 0x3e, 0x4d, 0xb2, 0x73, 0x3f, 0x0b, 0xa4, 0x0e, 0x94, 0x50, 0x36, 0xfd, 0xe2, 0x24,
	0xb2, 0x9f, 0x2c, 0xb0, 0xe6, 0x25, 0x0e, 0xb5, 0xbf, 0xb2, 0x85, 0x7f, 0xee, 0x40, 0x8b, 0xcf,
	0x95, 0x29, 0x8e, 0x70, 0x58, 0xfc, 0x96, 0x80, 0x57, 0x50, 0x1c, 0xa1, 0x38, 0x25, 0xb8, 0x74,
	0x77, 0xd0, 0x28, 0xdf, 0x1d, 0xb0, 0x54, 0x43, 0xb4, 0x8a, 0xa2, 0x7c, 0x01, 0xa0, 0x6b, 0xd0,
	0x3c, 0x4b, 0x52, 0xe5, 0x16, 0x40, 0xa5, 0xcc, 0x49, 0xea, 0x72, 0x1c, 0x6f, 0xc3, 0xd2, 0xb3,
	0x24, 0x20, 0x46, 0xd6, 0x75, 0xe1, 0x36, 0xe1, 0xdf, 0x77, 0xa0, 0xad, 0x88, 0xd1, 0x16, 0x34,
	0x99, 0x79, 0x2f, 0x45, 0x1e, 0xba, 0xf0, 0xc5, 0xe8, 0x5c, 0x4e, 0xc1, 0x4e, 0x1b, 0x8f, 0xfb,
	0x0b, 0xdf, 0xab, 0xa2, 0xfe, 0xc2, 0xaf, 0xb1, 0x70, 0x8d, 0xcf, 0xb9, 0xe4, 0x00, 0x4a, 0x28,
	0xfe, 0x85, 0x03, 0x7d, 0x6b, 0x0c, 0x16, 0xc0, 0x45, 0x7e, 0x4e, 0x65, 0xb1, 0x40, 0x0a, 0xd1,
	0x84, 0xcc, 0x0c, 0xbd, 0x61, 0x67, 0xe8, 0x3a, 0x43, 0x9c, 0x33, 0x33, 0xc4, 0xdb, 0xd0, 0x91,
	0xe9, 0x38, 0x51, 0x72, 0x53, 0x37, 0x2b, 0x6c, 0x44, 0x55, 0xd2, 0x2b, 0x88, 0xf0, 0x7d, 0xe8,
	0x1a, 0x3d, 0x6c, 0xc0, 0x98, 0xd0, 0xf3, 0x24, 0x7b, 0xa9, 0x4a, 0x02, 0xb2, 0xa9, 0x2b, 0xce,
	0x8d, 0xa2, 0xe2, 0x8c, 0xff, 0xce, 0x81, 0x3e, 0xd3, 0x89, 0x30, 0x1e, 0x1f, 0x25, 0x51, 0x38,
	0x9a, 0x71, 0xdd, 0x50, 0xdb, 0xef, 0x05, 0x24, 0xa2, 0xbe, 0xd6, 0x0d, 0x1b, 0x66, 0x1e, 0x73,
	0x12, 0xc6, 0xbc, 0xe6, 0x21, 0x35, 0x43, 0xb7, 0x99, 0x8e, 0x33, 0x73, 0x7e, 0xe2, 0xe7, 0xc4,
	0x9b, 0xb0, 0xc0, 0x52, 0x1a, 0x30, 0x0b, 0x64, 0x66, 0x89, 0x01, 0x99, 0x4f, 0x89, 0x37, 0x09,
	0xa3, 0x28, 0x14, 0xb4, 0x42, 0x97, 0xeb, 0xba, 0xf0, 0x3f, 0x34, 0xa0, 0x2b, 0x0d, 0xc2, 0xe3,
	0x60, 0x2c, 0xea, 0x57, 0xd2, 0x8d, 0xeb, 0x83, 0x66, 0x20, 0xaa, 0xdf, 0x72, 0xfc, 0x06, 0x52,
	0xde, 0xc0, 0xb9, 0xea, 0x06, 0xb2, 0x64, 0x3a, 0x09, 0xc8, 0x1d, 0x1e, 0x61, 0x88, 0x0b, 0xba,
	0x02, 0x50, 0xbd, 0x7b, 0xbc, 0xb7, 0x55, 0xf4, 0x72, 0xc0, 0x8a, 0x29, 0xe6, 0x4b, 0x31, 0xc5,
	0x5d, 0xe8, 0x49, 0x36, 0x5c, 0xee, 0xbc, 0x28, 0x52, 0xa8, 0xb2, 0xb5, 0x27, 0xae, 0x45, 0xa9,
	0xbe, 0xdc, 0x53, 0x5f, 0xb6, 0xdf, 0xf7, 0xa5, 0xa2, 0xc4, 0xeb, 0xb0, 0x2a, 0x85, 0xf7, 0x34,
	0xf3, 0xd3, 0x33, 0x65, 0x64, 0x03, 0x7d, 0x5b, 0xc4, 0x61, 0xb4, 0x0d, 0x2d, 0xf6, 0x99, 0xb2,
	0x73, 0xf5, 0xc7, 0x4b, 0x90, 0xa0, 0x2d, 0x68, 0x91, 0x60, 0x4c, 0x54, 0x50, 0x8b, 0xec, 0x50,
	0x9c, 0xed, 0x91, 0x2b, 0x08, 0xd8, 0x61, 0x67, 0x68, 0xe9, 0xb0, 0xdb, 0x36, 0x72, 0x9e, 0x35,
	0x3f, 0x0b, 0xf0, 0x1a, 0xa0, 0x67, 0x42, 0x6b, 0xcd, 0x8a, 0xcc, 0x1f, 0xcc, 0x41, 0xd7, 0x80,
	0xd9, 0xb9, 0x1d, 0xb3, 0x09, 0x7b, 0x41, 0xe8, 0x4f, 0x08, 0x25, 0x99, 0xd4, 0xd4, 0x12, 0xca,
	0x4d, 0xe9, 0xab, 0xb1, 0x97, 0x4c, 0xa9, 0x17, 0x90, 0x71, 0x46, 0x44, 0xa6, 0xeb, 0xb8, 0x25,
	0x94, 0xd1, 0x4d, 0xfc, 0xd7, 0x26, 0x9d, 0xd0, 0x87, 0x12, 0xaa, 0xea, 0x2b, 0x42, 0x46, 0xcd,
	0xa2, 0xbe, 0x22, 0x24, 0x52, 0xb6, 0x38, 0xad, 0x1a, 0x8b, 0xf3, 0x09, 0x6c, 0x08, 0xdb, 0x22,
	0xcf, 0xa6, 0x57, 0x52, 0x93, 0x0b, 0x7a, 0x59, 0xa4, 0xc6, 0xe6, 0xac, 0x14, 0x3c, 0x0f, 0x7f,
	0x26, 0x0a, 0xbb, 0x8e, 0x5b, 0xc1, 0x19, 0x2d, 0x3b, 0x8e, 0x16, 0xad, 0x28, 0xf0, 0x56, 0x70,
	0x4e, 0xeb, 0xbf, 0xb6, 0x69, 0x3b, 0x92, 0xb6, 0x84, 0xe3, 0x3e, 0x74, 0x8f, 0x69, 0x92, 0xaa,
	0x4d, 0x59, 0x84, 0x9e, 0x68, 0xca, 0xa2, 0xfe, 0x15, 0xb8, 0xcc, 0xb5, 0xe8, 0x79, 0x92, 0x26,
	0x51, 0x32, 0x9e, 0x1d, 0x4f, 0x4f, 0xf2, 0x51, 0x16, 0xa6, 0x2c, 0xe0, 0xc4, 0xff, 0xec, 0xc0,
	0xaa, 0xd5, 0x2b, 0x33, 0xca, 0xff, 0x2f, 0x54, 0x5a, 0xd7, 0x61, 0x85, 0xe2, 0xad, 0x18, 0x86,
	0x4f, 0x10, 0x8a, 0xe4, 0xf8, 0x4b, 0x59, 0x9a, 0xdd, 0x87, 0x25, 0x35, 0x33, 0xf5, 0xa1, 0xd0,
	0xc2, 0x41, 0x55, 0x0b, 0xe5, 0xf7, 0x8b, 0xf2, 0x03, 0xc5, 0xe2, 0x37, 0x44, 0x30, 0x46, 0x02,
	0xbe, 0x46, 0x95, 0x2f, 0x0d, 0xd5, 0xf7, 0x66, 0x00, 0xa8, 0x66, 0x30, 0xd2, 0x60, 0x8e, 0xff,
	0xc4, 0x01, 0x28, 0x66, 0xc7, 0x14, 0xa3, 0x30, 0xde, 0x0e, 0xaf, 0x6a, 0x15, 0x00, 0x0b, 0x9d,
	0x74, 0x95, 0xb0, 0xf0, 0x07, 0x5d, 0x85, 0xb1, 0x58, 0xe4, 0x16, 0x2c, 0x8d, 0xa3, 0xe4, 0x84,
	0x7b, 0x57, 0x7e, 0x7f, 0x94, 0xcb, 0xab, 0x8d, 0x45, 0x01, 0x3f, 0x91, 0x68, 0xe1, 0x3c, 0x9a,
	0x86, 0xf3, 0xc0, 0x7f, 0xda, 0xd0, 0xf5, 0xab, 0x62, 0xcd, 0x17, 0x9e, 0x32, 0xb4, 0x57, 0x31,
	0x8e, 0x17, 0xd4, 0x8b, 0x78, 0x12, 0x7d, 0xf4, 0xde, 0x34, 0xe9, 0x3e, 0x2c, 0x66, 0xc2, 0xfa,
	0x28, 0xd3, 0xd4, 0x7c, 0x87, 0x69, 0xea, 0x67, 0x96, 0xdf, 0xf9, 0x7f, 0xb0, 0xec, 0x07, 0xaf,
	0x48, 0x46, 0x43, 0x1e, 0x06, 0x73, 0xf7, 0x2e, 0x0c, 0xea, 0x92, 0x81, 0x73, 0xaf, 0x7b, 0x0b,
	0x96, 0xe4, 0x75, 0x92, 0xa6, 0x94, 0xd7, 0xf3, 0x05, 0xcc, 0x08, 0xf1, 0xdf, 0x38, 0xb2, 0x56,
	0x66, 0xef, 0xe1, 0xc5, 0x12, 0x31, 0x57, 0xd7, 0x28, 0xad, 0xee, 0xdb, 0xb2, 0xf4, 0x15, 0xa8,
	0x58, 0x5b, 0x16, 0x10, 0x05, 0x28, 0xcb, 0x8c, 0xb6, 0x48, 0x9b, 0x1f, 0x22, 0x52, 0xbc, 0x03,
	0x4b, 0xc7, 0x84, 0xee, 0xb3, 0x1d, 0x54, 0x86, 0xf1, 0x0a, 0x74, 0x62, 0x72, 0xee, 0x89, 0x2d,
	0x16, 0x6e, 0xbc, 0x1d, 0x93, 0x73, 0x4e, 0x83, 0x11, 0x2c, 0x17, 0xf4, 0xf2, 0xd4, 0xfd, 0x59,
	0x03, 0x16, 0x3e, 0x8b, 0x5f, 0x25, 0xe1, 0x88, 0x17, 0xb3, 0x26, 0x64, 0x92, 0xa8, 0x8b, 0x61,
	0xf6, 0x9b, 0x45, 0x05, 0xfc, 0xce, 0x23, 0xa5, 0xb2, 0xca, 0xa4, 0x9a, 0xcc, 0x43, 0x66, 0xc5,
	0x2b, 0x04, 0xa1, 0x6d, 0x06, 0xc2, 0xa2, 0xc9, 0xcc, 0x7c, 0x58, 0x21, 0x5b, 0xc5, 0xad, 0x78,
	0xcb, 0xb8, 0x15, 0xe7, 0x65, 0x4b, 0x71, 0x9d, 0xc3, 0xb7, 0xa4, 0xed, 0xaa, 0x26, 0x8f, 0x7a,
	0x33, 0x22, 0xf2, 0x4e, 0xee, 0x6b, 0x17, 0x64, 0xd4, 0x6b, 0x82, 0xcc, 0x1f, 0x8b, 0x0f, 0x04,
	0x8d, 0xb0, 0x57, 0x26, 0xc4, 0xe2, 0x93, 0xf2, 0xdb, 0x8c, 0x8e, 0x50, 0x93, 0x12, 0x8c, 0xbf,
	0x02, 0xb4, 0x1f, 0x04, 0x52, 0x2a, 0x3a, 0x8a, 0x2f, 0xd6, 0xe3, 0x58, 0xeb, 0xa9, 0xe1, 0xdb,
	0xa8, 0xe7, 0xfb, 0x18, 0xba, 0x47, 0xc6, 0xe3, 0x12, 0x2e, 0x40, 0xf5, 0xac, 0x44, 0x0a, 0xdd,
	0x40, 0x8c, 0x01, 0x1b, 0xe6, 0x80, 0xf8, 0xd7, 0x00, 0x1d, 0x86, 0x39, 0xd5, 0xf3, 0xd3, 0xf9,
	0x95, 0xae, 0xf2, 0x18, 0xf9, 0x95, 0xc4, 0x78, 0x7e, 0xb5, 0x2f, 0xae, 0x97, 0xca, 0x0b, 0xdb,
	0x86, 0x76, 0x28, 0x20, 0x65, 0x3f, 0x17, 0xa5, 0xe2, 0x29, 0x4a, 0xdd, 0xcf, 0x02, 0x01, 0x09,
	0x5a, 0xe6, 0xf9, 0xe7, 0x0e, 0x2c, 0xc8, 0xa5, 0x31, 0x37, 0x66, 0x3d, 0xab, 0x11, 0x0b, 0xb3,
	0xb0, 0xfa, 0x97, 0x11, 0xd5, 0x9d, 0x9e, 0xab, 0xdb, 0x69, 0x04, 0xcd, 0xd4, 0xa7, 0x67, 0x3c,
	0xc6, 0xed, 0xb8, 0xfc, 0xb7, 0xca, 0x65, 0x5a, 0x3a, 0x97, 0x51, 0x57, 0x69, 0x72, 0x52, 0xfa,
	0x96, 0xe7, 0x81, 0xb8, 0x4a, 0x2b, 0xe0, 0x42, 0x06, 0x72, 0x82, 0x65, 0x19, 0x48, 0x52, 0x57,
	0xf7, 0xe3, 0x21, 0x0c, 0x1e, 0x91, 0x88, 0x50, 0xb2, 0x1f, 0x45, 0x65, 0xfe, 0x57, 0xe0, 0x72,
	0x4d, 0x9f, 0x3c, 0x6b, 0x4f, 0x60, 0xe5, 0x11, 0x39, 0x99, 0x8e, 0x0f, 0xc9, 0xab, 0xa2, 0xe4,
	0x8b, 0xa0, 0x99, 0x9f, 0x25, 0xe7, 0x72, 0xbf, 0xf8, 0x6f, 0xf4, 0x11, 0x40, 0xc4, 0x68, 0xbc,
	0x3c, 0x25, 0x23, 0xf5, 0x34, 0x80, 0x23, 0xc7, 0x29, 0x19, 0xe1, 0x4f, 0x00, 0x99, 0x7c, 0xe4,
	0x12, 0xd8, 0x09, 0x98, 0x9e, 0x78, 0xf9, 0x2c, 0xa7, 0x64, 0xa2, 0x0e, 0xbf, 0x09, 0xe1, 0x5b,
	0xd0, 0x3b, 0xf2, 0x67, 0x2e, 0xf9, 0x5a, 0xbe, 0x56, 0x62, 0x29, 0x93, 0x3f, 0x63, 0xea, 0xa9,
	0x53, 0x26, 0xde, 0x8d, 0x33, 0x98, 0x17, 0x84, 0x8c, 0x69, 0x40, 0x72, 0x1a, 0xc6, 0xa2, 0xe8,
	0x2a, 0x99, 0x1a, 0x50, 0x65, 0xbb, 0x1b, 0x35, 0xdb, 0x2d, 0x23, 0x1b, 0x75, 0x8b, 0x2a, 0xf7,
	0xd5, 0xc2, 0x98, 0x71, 0x7a, 0x42, 0x88, 0x4b, 0xd2, 0x24, 0xd3, 0xaf, 0xa4, 0xfe, 0xca, 0x81,
	0x65, 0x69, 0xfc, 0x74, 0x1f, 0xba, 0x61, 0x59, 0x4a, 0xa7, 0xae, 0x24, 0x77, 0x13, 0xfa, 0x3c,
	0x57, 0x60, 0x89, 0x00, 0x4f, 0x0c, 0x64, 0xa2, 0x6c, 0x81, 0x6c, 0x6d, 0xaa, 0x72, 0x34, 0x09,
	0x23, 0x39, 0x29, 0x13, 0x62, 0x56, 0x5d, 0xe5, 0x12, 0xdc, 0x88, 0x39, 0xae, 0x6e, 0xe3, 0x23,
	0x58, 0x31, 0xe6, 0x2b, 0xf7, 0xe0, 0x3e, 0xa8, 0x1b, 0x12, 0x91, 0xf7, 0x0a, 0x55, 0xda, 0xb4,
	0xed, 0x78, 0xf1, 0x99, 0x45, 0x8c, 0xff, 0xde, 0xe1, 0x22, 0x90, 0xe1, 0x82, 0x7e, 0x1e, 0x31,
	0x2f, 0x3c, 0xb8, 0x50, 0x90, 0x83, 0x4b, 0xae, 0x6c, 0xa3, 0xef, 0x7f, 0xa0, 0x13, 0xd6, 0x97,
	0x19, 0x17, 0xc8, 0x66, 0xae, 0x4e, 0x36, 0xef, 0x58, 0xf9, 0x83, 0x05, 0x68, 0xe5, 0xa3, 0x24,
	0x25, 0x78, 0x95, 0x8b, 0x40, 0xcd, 0x57, 0x88, 0x60, 0xef, 0x6f, 0xaf, 0x40, 0x47, 0x07, 0xfc,
	0xe8, 0xa7, 0xd0, 0xb7, 0x4a, 0x3a, 0xe8, 0x8a, 0x9c, 0x61, 0x5d, 0x8d, 0x68, 0x78, 0xb5, 0xbe,
	0x53, 0x1e, 0x9f, 0x6b, 0xdf, 0xfc, 0xea, 0xdf, 0x7f, 0xd1, 0x18, 0xa0, 0x8d, 0xdd, 0x57, 0x77,
	0x76, 0x65, 0xcd, 0x66, 0x97, 0x97, 0xa0, 0xc4, 0x8d, 0xe1, 0x4b, 0x58, 0xb4, 0x4b, 0x3e, 0xe8,
	0xaa, 0x2d, 0x8e, 0xd2, 0x68, 0x1f, 0x5d, 0xd0, 0x2b, 0x87, 0xbb, 0xca, 0x87, 0xdb, 0x40, 0x6b,
	0xe6, 0x70, 0x3a, 0x10, 0x27, 0xfc, 0x8e, 0xd7, 0x7c, 0xfb, 0x88, 0x14, 0xbf, 0xfa, 0x37, 0x91,
	0xc3, 0xcb, 0xd5, 0x77, 0x8e, 0xf2, 0x61, 0x24, 0x1e, 0xf0, 0xa1, 0x10, 0x5a, 0x66, 0x43, 0x99,
	0x4f, 0x1f, 0xd1, 0x4f, 0xa0, 0xa3, 0x1f, 0x70, 0xa1, 0x4d, 0xe3, 0xb9, 0x9a, 0xf9, 0x24, 0x6c,
	0x38, 0xa8, 0x76, 0xa8, 0xa0, 0x9a, 0x73, 0x5e, 0xc7, 0x15, 0xce, 0xf7, 0x9c, 0x6d, 0x74, 0x08,
	0xeb, 0xd2, 0x8a, 0x9f, 0x90, 0xff, 0xce, 0x4a, 0x6a, 0x5e, 0x6c, 0xde, 0x76, 0xd0, 0x7d, 0x68,
	0xab, 0x37, 0x6d, 0x68, 0xa3, 0xfe, 0x61, 0xdd, 0x70, 0xb3, 0x82, 0xcb, 0x83, 0xb3, 0x0f, 0x50,
	0x3c, 0xe1, 0x42, 0x83, 0x8b, 0x5e, 0x9a, 0x69, 0x21, 0xd6, 0xbc, 0xf7, 0x1a, 0xf3, 0x17, 0x6c,
	0xf6, 0x0b, 0x31, 0xf4, 0xad, 0x82, 0xbe, 0xf6, 0xed, 0xd8, 0x3b, 0x18, 0xe2, 0x0d, 0x2e, 0xbb,
	0x65, 0xb4, 0xc8, 0x64, 0x17, 0x93, 0x73, 0xf5, 0xda, 0xe1, 0x11, 0x74, 0x8d, 0x67, 0x61, 0x48,
	0x71, 0xa8, 0x3e, 0x29, 0x1b, 0x0e, 0xeb, 0xba, 0xe4, 0x74, 0x7f, 0x0b, 0xfa, 0xd6, 0xfb, 0x2e,
	0x7d, 0x32, 0xea, 0x5e, 0x8f, 0xe9, 0x93, 0x51, 0xff, 0x24, 0xec, 0xc7, 0xd0, 0x35, 0x5e, 0x63,
	0x21, 0xe3, 0x52, 0xac, 0xf4, 0xda, 0x4a, 0xcf, 0xa8, 0xe6, 0xf1, 0x16, 0x5e, 0xe3, 0xeb, 0x5d,
	0xc4, 0x1d, 0xb6, 0x5e, 0x7e, 0xe5, 0xcf, 0x94, 0xe4, 0xa7, 0xb0, 0x68, 0xbf, 0xc2, 0xd2, 0xa7,
	0xaa, 0xf6, 0x3d, 0x97, 0x3e, 0x55, 0x17, 0x3c, 0xdd, 0x92, 0x0a, 0xb9, 0xbd, 0xaa, 0x07, 0xd9,
	0x7d, 0x23, 0x0b, 0x5b, 0x6f, 0xd1, 0x8f, 0x98, 0xe9, 0x90, 0x6f, 0x30, 0x50, 0xf1, 0x2a, 0xcd,
	0x7e, 0xa9, 0xa1, 0xb5, 0xbd, 0xf2, 0x5c, 0x03, 0xaf, 0x70, 0xe6, 0x5d, 0x54, 0xac, 0x00, 0x7d,
	0x0e, 0x0b, 0xf2, 0x2d, 0x06, 0x5a, 0x2f, 0xb4, 0xda, 0x28, 0x0e, 0x0c, 0x37, 0xca, 0xb0, 0x64,
	0xb6, 0xca, 0x99, 0xf5, 0x51, 0x97, 0x31, 0x1b, 0x13, 0x1a, 0x32, 0x1e, 0x11, 0x2c, 0xd9, 0xe5,
	0xf9, 0x5c, 0x8b, 0xa3, 0xf6, 0x62, 0x50, 0x8b, 0xa3, 0xbe, 0xd6, 0x6f, 0x1b, 0x19, 0x65, 0x5c,
	0x76, 0xd5, 0x9d, 0xe7, 0xef, 0x42, 0xcf, 0x7c, 0xf8, 0x83, 0x86, 0xc6, 0xca, 0x4b, 0x8f, 0x84,
	0x86, 0x57, 0x6a, 0xfb, 0xec, 0xad, 0x45, 0x3d, 0x73, 0x18, 0xf4, 0x63, 0x58, 0x32, 0xee, 0x91,
	0x8e, 0x67, 0xf1, 0x48, 0xab, 0x4e, 0xf5, 0x6e, 0x7a, 0x58, 0xe7, 0x5b, 0xf0, 0x26, 0x67, 0xbc,
	0x82, 0x2d, 0xc6, 0x4c, 0x6d, 0x1e, 0x42, 0xd7, 0xbc, 0xa3, 0x7a, 0x07, 0xdf, 0x4d, 0xa3, 0xcb,
	0xbc, 0x2d, 0xbe, 0xed, 0xa0, 0xbf, 0x70, 0xa0, 0x67, 0x3e, 0x59, 0x40, 0x56, 0x7e, 0x5d, 0xe2,
	0x33, 0x30, 0xfb, 0x4c, 0x46, 0xf8, 0x19, 0x9f, 0xe4, 0xc1, 0xf6, 0x13, 0x4b, 0xc8, 0x6f, 0xac,
	0x98, 0x61, 0xc7, 0x7c, 0xaa, 0xfc, 0xb6, 0xdc, 0x69, 0xde, 0xdd, 0xbf, 0xbd, 0xed, 0xa0, 0x7b,
	0xe2, 0x41, 0xba, 0x0a, 0x79, 0x91, 0x61, 0xd6, 0xca, 0xe2, 0x32, 0x5f, 0x79, 0x6f, 0x39, 0xb7,
	0x1d, 0xf4, 0x7b, 0xe2, 0x75, 0xb2, 0xfc, 0x96, 0x4b, 0xfd, 0x43, 0xbf, 0xc7, 0x37, 0xf9, 0x4a,
	0xae, 0xe1, 0xcb, 0xd6, 0x4a, 0xca, 0x76, 0xfd, 0x08, 0xa0, 0xc8, 0x5f, 0x50, 0x29, 0x98, 0xd7,
	0x16, 0xaf, 0x9a, 0xe2, 0xd8, 0xbb, 0xa9, 0x62, 0x7e, 0x61, 0x04, 0x7a, 0x46, 0xe6, 0x90, 0xeb,
	0xed, 0xac, 0xe6, 0x21, 0xc3, 0x61, 0x5d, 0x97, 0xe4, 0xff, 0x6d, 0xce, 0xff, 0x23, 0x74, 0xc5,
	0xe4, 0xbf, 0xfb, 0xc6, 0xcc, 0x5b, 0xde, 0xa2, 0xaf, 0xa0, 0x7f, 0x98, 0x24, 0x2f, 0xa7, 0xa9,
	0x4e, 0x4b, 0xed, 0x48, 0x9c, 0xe5, 0x4e, 0xc3, 0xd2, 0xa2, 0xf0, 0x0d, 0xce, 0xf9, 0x0a, 0xba,
	0x6c, 0x73, 0x2e, 0xb2, 0xa9, 0xb7, 0xc8, 0x87, 0x15, 0xed, 0xed, 0xf4, 0x42, 0x86, 0x36, 0x1f,
	0x33, 0xa9, 0xa9, 0x8c, 0x61, 0xc5, 0x1f, 0x7a, 0x8c, 0x5c, 0xf1, 0xbc, 0xed, 0xa0, 0x23, 0xe8,
	0x3d, 0x22, 0xa3, 0x24, 0x20, 0x32, 0x7a, 0x5e, 0x2d, 0x66, 0xae, 0xa3, 0xee, 0x61, 0xdf, 0x02,
	0x6d, 0x0b, 0x90, 0xfa, 0xb3, 0x8c, 0x7c, 0xbd, 0xfb, 0x46, 0x86, 0xe5, 0x6f, 0x95, 0x05, 0x50,
	0xa9, 0x84, 0x65, 0x01, 0x4a, 0xb9, 0x87, 0x65, 0x01, 0x2a, 0xb9, 0x87, 0x65, 0x01, 0x54, 0x2a,
	0x83, 0x22, 0x96, 0x91, 0x94, 0xd2, 0x15, 0xed, 0x33, 0x2f, 0x4a, 0x72, 0x86, 0xd7, 0x2f, 0x26,
	0xb0, 0x47, 0xdb, 0xb6, 0x47, 0x3b, 0x86, 0xfe, 0x23, 0x22, 0x84, 0x25, 0xea, 0xc5, 0x43, 0xdb,
	0xa4, 0x98, 0xb5, 0xe5, 0xb2, 0xb9, 0xe1, 0x7d, 0xb6, 0x81, 0xe7, 0xc5, 0x5a, 0xf4, 0x13, 0xe8,
	0x3e, 0x25, 0x54, 0x15, 0x88, 0x75, 0xe4, 0x51, 0xaa, 0x18, 0x0f, 0x6b, 0xea, 0xcb, 0xf8, 0x3a,
	0xe7, 0x36, 0x44, 0x03, 0xcd, 0x6d, 0x97, 0x04, 0x63, 0x22, 0x0e, 0xbf, 0x17, 0x06, 0x6f, 0xd1,
	0x6f, 0x73, 0xe6, 0xfa, 0xf6, 0x68, 0xc3, 0xa8, 0x2b, 0x9a, 0xcc, 0x97, 0x4a, 0x78, 0x1d, 0xe7,
	0x38, 0x09, 0x88, 0xe1, 0xea, 0x62, 0xe8, 0x1a, 0x57, 0x85, 0xfa, 0x40, 0x55, 0xef, 0x1f, 0xf5,
	0x81, 0xaa, 0xb9, 0x59, 0xc4, 0x5b, 0x7c, 0x1c, 0x8c, 0xae, 0x17, 0xe3, 0x88, 0xdb, 0xc4, 0x62,
	0xa4, 0xdd, 0x37, 0xfe, 0x84, 0xbe, 0x45, 0x2f, 0xf8, 0x33, 0x45, 0xb3, 0x08, 0x5e, 0x44, 0x3e,
	0xe5, 0x7a, 0xb9, 0x16, 0x96, 0xd1, 0x65, 0x47, 0x43, 0x62, 0x28, 0xee, 0x11, 0xbf, 0x0f, 0x70,
	0x4c, 0x93, 0xf4, 0x91, 0x4f, 0x26, 0x49, 0x5c, 0x58, 0xb2, 0xa2, 0xd0, 0x5b, 0x58, 0x32, 0xa3,
	0xda, 0x8b, 0x5e, 0x18, 0xb1, 0xa7, 0x75, 0x87, 0xa0, 0x94, 0xeb, 0xc2, 0x5a, 0xb0, 0x16, 0x48,
	0x4d, 0x3d, 0x58, 0x85, 0xa1, 0xa2, 0xc8, 0x65, 0x84, 0xa1, 0x56, 0x95, 0xcc, 0x08, 0x43, 0xed,
	0x6a, 0x18, 0x0b, 0x43, 0x8b, 0xcc, 0x5a, 0x87, 0xa1, 0x95, 0xa4, 0x5d, 0xdb, 0xd0, 0x9a, 0x34,
	0xfc, 0x08, 0x3a, 0x45, 0xae, 0xaa, 0x06, 0x2a, 0x67, 0xb6, 0xda, 0x59, 0x55, 0x52, 0x48, 0xbc,
	0xcc, 0xe5, 0x0c, 0xa8, 0xcd, 0xe4, 0xcc, 0xaf, 0x4a, 0x9f, 0x03, 0x88, 0xd5, 0x3d, 0x61, 0x2d,
	0x83, 0xa5, 0x95, 0x29, 0x9a, 0x2c, 0xed, 0x94, 0x4c, 0x45, 0x32, 0x58, 0xb3, 0xbc, 0xe7, 0x6c,
	0x9f, 0xcc, 0xf3, 0xff, 0x5b, 0xfb, 0xde, 0x7f, 0x05, 0x00, 0x00, 0xff, 0xff, 0x99, 0xff, 0x53,
	0x74, 0xe9, 0x36, 0x00, 0x00,
}
