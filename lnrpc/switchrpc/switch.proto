syntax = "proto3";

package switchrpc;

import "lightning.proto";

option go_package = "github.com/lightningnetwork/lnd/lnrpc/switchrpc";

// Switch is a service that offers advanced interaction with the HTLC fowarding
// subsystem of the daemon.
service Switch {
    /*
    SendOnion provides an idempotent API for dispatching a pre-formed onion
    packet, which is the primary entry point for a remote router.

    To safely handle network failures, a client can and should retry this RPC
    after a timeout or disconnection. Retries MUST use the exact same
    attempt_id to allow the server to correctly detect duplicate requests.

    The server communicates outcomes through two channels: the gRPC status
    code and, for application-level failures, a SendOnionFailureDetails
    message attached to the gRPC error's details. The client should evaluate
    these in the following order:

    1. SUCCESS (gRPC code OK): A definitive confirmation that the HTLC has
    been successfully dispatched. The client can proceed to track the
    payment's final result via the TrackOnion RPC.

    2. DUPLICATE ACKNOWLEDGMENT (gRPC code AlreadyExists): A definitive
    acknowledgment that a request with the same attempt_id has already
    been successfully processed. A retrying client should interpret this
    as a success and proceed to tracking the payment's result.

    3. APPLICATION-LEVEL FAILURE (SendOnionFailureDetails present): For any
    other gRPC error, the client should check for a SendOnionFailureDetails
    message in the error's details. If present, the failure_class oneof is
    the authoritative classification. A DefiniteFailure guarantees the HTLC
    was not and will not be dispatched; the client should fail the attempt and
    may retry with a new route. An IndefiniteFailure means the state of the HTLC
    is unknown; the client MUST retry the exact same request to resolve the
    ambiguity.

    4. BARE gRPC ERROR (no SendOnionFailureDetails): If no details payload
    is attached, the error is a transport-level or pre-flight validation
    failure. If the gRPC status code is InvalidArgument or FailedPrecondition,
    the request was rejected before dispatch was attempted and this is a
    definitive failure. For all other codes (Unavailable, DeadlineExceeded,
    etc.), the state is unknown and the client MUST retry the same request.
    */
    rpc SendOnion (SendOnionRequest) returns (SendOnionResponse);

    /*
    TrackOnion allows callers to query whether or not a payment dispatched via
    SendOnion succeeded or failed.

    This RPC is designed to be called after a successful dispatch has been
    explicitly confirmed via the SendOnion RPC. It should not be used to
    determine whether an HTLC dispatch was received in an ambiguous network
    scenario. That ambiguity must be resolved by retrying the idempotent
    SendOnion RPC until a definitive acknowledgement is received from the Switch
    RPC server.

    Once dispatch is confirmed, TrackOnion provides the mechanism to wait for
    the result of the in-flight HTLC. A client must handle three distinct
    categories of outcomes:

    1. PAYMENT SUCCESS (gRPC code OK, preimage set): The payment settled
    successfully. The response contains the payment preimage.

    2. PAYMENT FAILURE (gRPC code OK, failure_details set): The payment failed
    at the application level. The failure_details oneof describes the specific
    failure type: a ForwardingFailure from a remote hop, a LocalFailure
    from the local node, an UnreadableFailure if the error could not be
    decoded, or a SwitchError for other switch-level failures. When
    encrypted_error_data is populated, the client may perform its own
    decryption.

    3. QUERY FAILURE (gRPC error status): The query itself could not be
    completed. NotFound indicates the payment ID is unknown. Unavailable
    signals the switch is shutting down. Canceled or DeadlineExceeded
    reflects client-side timeouts. These are safe to retry.
    */
    rpc TrackOnion (TrackOnionRequest) returns (TrackOnionResponse);

    /*
    BuildOnion attempts to build an onion packet for the specified route.
    */
    rpc BuildOnion (BuildOnionRequest) returns (BuildOnionResponse);
}

message SendOnionRequest {
    // The raw onion packet to be sent across the network.
    bytes onion_blob = 1;

    // The attempt ID uniquely identifying this payment attempt. The caller can
    // expect to track results for the payment via this attempt ID.
    uint64 attempt_id = 2;

    // The first hop's public key where the onion will be sent.
    // The first hop must be specified either by channel ID or public key.
    bytes first_hop_pubkey = 3;

    // The channel id of the channel that must be taken to the first hop.
    // The first hop must be specified either by channel ID or public key.
    uint64 first_hop_chan_id = 4;

    // The total amount in millisatoshis required to complete a payment over
    // this route. This value includes the cumulative fees at each hop. The HTLC
    // extended to the first-hop in the route will need to have at least this
    // many (milli)satoshis.
    int64 amount = 5;

    // The absolute timelock or CLTV value that should be extended to the first
    // hop in the route. All other hops will decrement the time-lock as
    // described by the onion.
    uint32 timelock = 6;

    // The payment hash associated with the HTLC. This is needed for tracking
    // and debugging purposes.
    bytes payment_hash = 7;

    // The optional blinding point to use when constructing the HTLC.
    // If set, this will be used to blind the next hop in the route.
    optional bytes blinding_point = 8;

    // Optional custom TLV records to include in the UpdateAddHTLC message.
    map<uint64, bytes> custom_records = 9;

    // Optional opaque extra data to attach to the UpdateAddHTLC message.
    optional bytes extra_data = 10;
}

// SendOnionResponse is an empty message. A gRPC status of OK or AlreadyExists
// indicates a successful dispatch acknowledgment.
message SendOnionResponse {
}

// SendOnionFailureDetails provides structured details for a dispatch failure
// and is attached to a non-OK gRPC status.
message SendOnionFailureDetails {
    // A human-readable message for logging and debugging.
    string error_message = 1;

    // The server is responsible for classifying all application-level failures
    // into one of two structurally distinct categories. This allows RPC clients
    // to make a safe, top-level decision on how to proceed by simply switching
    // on the type of the failure, rather than interpreting error codes.
    oneof failure_class {
        DefiniteFailure definite_failure = 2;
        IndefiniteFailure indefinite_failure = 3;
    }
}

// DefiniteFailure is a guarantee that the HTLC was not and will not be
// dispatched. The client should fail the payment attempt and may retry with a
// new route.
message DefiniteFailure {
    oneof detail {
        // A failure with a clear, unencrypted reason that occurred at our
        // node before the HTLC was dispatched.
        LocalFailure local_failure = 1;
    }
}

// IndefiniteFailure indicates that the state of the HTLC dispatch is unknown.
// This could be due to a transport-level failure or a server-side issue where
// the idempotency record may or may not have been written. The client MUST
// retry the exact same request to resolve the ambiguity. Clients can optionally
// use this code to implement more nuanced behavior, such as logging or emitting
// more detailed metrics.
message IndefiniteFailure {
    // A stable, machine-readable code for the indefinite failure.
    IndefiniteFailureCode reason = 1;
}

// IndefiniteFailureCode provides the specific reason for an indefinite failure.
enum IndefiniteFailureCode {
    // The reason is unknown. This is the default and is used for failures
    // where the server could not classify the error, such as bare gRPC
    // transport errors observed by the client.
    REASON_UNKNOWN = 0;

    // The server is in the process of shutting down.
    SWITCH_EXITING = 1;

    // A critical failure occurred when the server attempted to write the
    // idempotency record for the payment attempt.
    HTLC_INIT_FAILED = 2;
}

message TrackOnionRequest {
    // The payment hash associated with the HTLC. This is needed for tracking
    // and debugging purposes.
    bytes payment_hash = 1;

    // The attempt ID uniquely identifying this payment attempt. The caller can
    // expect to track results for the payment via this attempt ID.
    uint64 attempt_id = 2;

    // Optional: The session key that was used to construct the onion packet.
    // This is required by the server to decrypt any failure message.
    optional bytes session_key = 3;

    // Optional: The public keys of the nodes in the route, used with the
    // session_key to decrypt any failure message.
    repeated bytes hop_pubkeys = 4;
}

message TrackOnionResponse {
    // The final result of the payment attempt, which is either a preimage
    // (success) or detailed failure information.
    oneof result {
        // The preimage obtained by making the payment. If this field is set,
        // the payment succeeded.
        bytes preimage = 1;

        // The application-level failure for the payment attempt. If this field
        // is set, the payment attempt failed.
        FailureDetails failure_details = 2;
    }
}

// FailureDetails provides structured information about why a payment attempt
// failed on the network. This message is included in a successful
// TrackOnionResponse when the queried attempt ultimately failed.
message FailureDetails {
    // A human-readable error_message for logging or display.
    string error_message = 1;

    // The failure contains specific, structured details about the error.
    // Exactly one variant is set when this message is present.
    oneof failure {
        // local_failure is set when the failure originates at the local
        // node (e.g. unable to forward due to insufficient balance,
        // channel policy violations, or other link-level rejections). The
        // wire message is available in plaintext without onion decryption.
        LocalFailure local_failure = 2;

        // forwarding_failure is set when the HTLC was forwarded into the
        // network and a remote node returned an error. The onion error
        // was successfully decrypted, yielding the failure source index.
        // The wire_message may be empty if the inner failure could not
        // be decoded.
        ForwardingFailure forwarding_failure = 3;

        // encrypted_error_data contains the raw onion-encrypted error
        // blob. This is returned when no decryption keys were provided
        // in the TrackOnionRequest (i.e. no session key or hop public
        // keys), deferring decryption entirely to the client.
        bytes encrypted_error_data = 4;

        // unreadable_failure indicates that decryption keys were provided
        // and decryption was attempted, but failed. The original error
        // cannot be recovered.
        UnreadableFailure unreadable_failure = 5;

        // switch_error indicates an unexpected internal error that does
        // not fall into any of the above categories.
        SwitchError switch_error = 6;
    }
}

// ForwardingFailure represents an HTLC failure that occurred at a remote node
// in the payment route. The onion error was successfully decrypted, revealing
// the failing hop.
message ForwardingFailure {
    // failure_source_index is the 0-based index of the node within the payment
    // route that reported the failure. Index 0 refers to the local node.
    uint32 failure_source_index = 1;

    // The raw, serialized lnwire.FailureMessage reported by the failing node.
    // This field may be empty if the failure message could not be decoded.
    bytes wire_message = 2;
}

// LocalFailure represents a failure that originates at the local node. No
// onion decryption is involved because the failure occurred before the HTLC
// left our node.
message LocalFailure {
    // The raw, serialized `lnwire.FailureMessage`.
    bytes wire_message = 1;
}

// SwitchError indicates that an error occurred within the switch subsystem.
message SwitchError {
}

// UnreadableFailure indicates that decryption keys were provided and
// decryption was attempted, but failed. The original failure information
// cannot be recovered.
message UnreadableFailure {
}

// BuildOnionRequest includes the necessary information to construct a Sphinx
// onion packet.
message BuildOnionRequest {
    // The route for which the onion packet should be built.
    lnrpc.Route route = 1;

    // The payment hash associated with the HTLC.
    bytes payment_hash = 2;

    // A session key for onion packet construction, if not provided, a new one
    // will be generated.
    optional bytes session_key = 3;
}

// BuildOnionResponse contains the constructed onion packet.
message BuildOnionResponse {
    // The constructed onion packet in bytes.
    bytes onion_blob = 1;

    // The session key used for building the onion packet.
    bytes session_key = 2;

    // The serialized public keys of all nodes along the route for the
    // constructed onion.
    repeated bytes hop_pubkeys = 3;
}
