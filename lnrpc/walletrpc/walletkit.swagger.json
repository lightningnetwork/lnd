{
  "swagger": "2.0",
  "info": {
    "title": "walletrpc/walletkit.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "WalletKit"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/v2/wallet/accounts": {
      "get": {
        "summary": "ListAccounts retrieves all accounts belonging to the wallet by default. A\nname and key scope filter can be provided to filter through all of the\nwallet accounts and return only those matching.",
        "operationId": "WalletKit_ListAccounts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcListAccountsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "name",
            "description": "An optional filter to only return accounts matching this name.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "address_type",
            "description": "An optional filter to only return accounts matching this address type.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "UNKNOWN",
              "WITNESS_PUBKEY_HASH",
              "NESTED_WITNESS_PUBKEY_HASH",
              "HYBRID_NESTED_WITNESS_PUBKEY_HASH"
            ],
            "default": "UNKNOWN"
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/accounts/import": {
      "post": {
        "summary": "ImportAccount imports an account backed by an account extended public key.\nThe master key fingerprint denotes the fingerprint of the root key\ncorresponding to the account public key (also known as the key with\nderivation path m/). This may be required by some hardware wallets for\nproper identification and signing.",
        "description": "The address type can usually be inferred from the key's version, but may be\nrequired for certain keys to map them into the proper scope.\n\nFor BIP-0044 keys, an address type must be specified as we intend to not\nsupport importing BIP-0044 keys into the wallet using the legacy\npay-to-pubkey-hash (P2PKH) scheme. A nested witness address type will force\nthe standard BIP-0049 derivation scheme, while a witness address type will\nforce the standard BIP-0084 derivation scheme.\n\nFor BIP-0049 keys, an address type must also be specified to make a\ndistinction between the standard BIP-0049 address schema (nested witness\npubkeys everywhere) and our own BIP-0049Plus address schema (nested pubkeys\nexternally, witness pubkeys internally).\n\nNOTE: Events (deposits/spends) for keys derived from an account will only be\ndetected by lnd if they happen after the import. Rescans to detect past\nevents will be supported later on.",
        "operationId": "WalletKit_ImportAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcImportAccountResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/walletrpcImportAccountRequest"
            }
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/address/next": {
      "post": {
        "summary": "NextAddr returns the next unused address within the wallet.",
        "operationId": "WalletKit_NextAddr",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcAddrResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/walletrpcAddrRequest"
            }
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/bumpfee": {
      "post": {
        "summary": "BumpFee bumps the fee of an arbitrary input within a transaction. This RPC\ntakes a different approach than bitcoind's bumpfee command. lnd has a\ncentral batching engine in which inputs with similar fee rates are batched\ntogether to save on transaction fees. Due to this, we cannot rely on\nbumping the fee on a specific transaction, since transactions can change at\nany point with the addition of new inputs. The list of inputs that\ncurrently exist within lnd's central batching engine can be retrieved\nthrough the PendingSweeps RPC.",
        "description": "When bumping the fee of an input that currently exists within lnd's central\nbatching engine, a higher fee transaction will be created that replaces the\nlower fee transaction through the Replace-By-Fee (RBF) policy. If it\n\nThis RPC also serves useful when wanting to perform a Child-Pays-For-Parent\n(CPFP), where the child transaction pays for its parent's fee. This can be\ndone by specifying an outpoint within the low fee transaction that is under\nthe control of the wallet.\n\nThe fee preference can be expressed either as a specific fee rate or a delta\nof blocks in which the output should be swept on-chain within. If a fee\npreference is not explicitly specified, then an error is returned.\n\nNote that this RPC currently doesn't perform any validation checks on the\nfee preference being provided. For now, the responsibility of ensuring that\nthe new fee preference is sufficient is delegated to the user.",
        "operationId": "WalletKit_BumpFee",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcBumpFeeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/walletrpcBumpFeeRequest"
            }
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/estimatefee/{conf_target}": {
      "get": {
        "summary": "EstimateFee attempts to query the internal fee estimator of the wallet to\ndetermine the fee (in sat/kw) to attach to a transaction in order to\nachieve the confirmation target.",
        "operationId": "WalletKit_EstimateFee",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcEstimateFeeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "conf_target",
            "description": "The number of confirmations to shoot for when estimating the fee.",
            "in": "path",
            "required": true,
            "type": "integer",
            "format": "int32"
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/key": {
      "post": {
        "summary": "DeriveKey attempts to derive an arbitrary key specified by the passed\nKeyLocator.",
        "operationId": "WalletKit_DeriveKey",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/signrpcKeyDescriptor"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/signrpcKeyLocator"
            }
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/key/import": {
      "post": {
        "summary": "ImportPublicKey imports a public key as watch-only into the wallet.",
        "description": "NOTE: Events (deposits/spends) for a key will only be detected by lnd if\nthey happen after the import. Rescans to detect past events will be\nsupported later on.",
        "operationId": "WalletKit_ImportPublicKey",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcImportPublicKeyResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/walletrpcImportPublicKeyRequest"
            }
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/key/next": {
      "post": {
        "summary": "DeriveNextKey attempts to derive the *next* key within the key family\n(account in BIP43) specified. This method should return the next external\nchild within this branch.",
        "operationId": "WalletKit_DeriveNextKey",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/signrpcKeyDescriptor"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/walletrpcKeyReq"
            }
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/psbt/finalize": {
      "post": {
        "summary": "FinalizePsbt expects a partial transaction with all inputs and outputs fully\ndeclared and tries to sign all inputs that belong to the wallet. Lnd must be\nthe last signer of the transaction. That means, if there are any unsigned\nnon-witness inputs or inputs without UTXO information attached or inputs\nwithout witness data that do not belong to lnd's wallet, this method will\nfail. If no error is returned, the PSBT is ready to be extracted and the\nfinal TX within to be broadcast.",
        "description": "NOTE: This method does NOT publish the transaction once finalized. It is the\ncaller's responsibility to either publish the transaction on success or\nunlock/release any locked UTXOs in case of an error in this method.",
        "operationId": "WalletKit_FinalizePsbt",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcFinalizePsbtResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/walletrpcFinalizePsbtRequest"
            }
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/psbt/fund": {
      "post": {
        "summary": "FundPsbt creates a fully populated PSBT that contains enough inputs to fund\nthe outputs specified in the template. There are two ways of specifying a\ntemplate: Either by passing in a PSBT with at least one output declared or\nby passing in a raw TxTemplate message.",
        "description": "If there are no inputs specified in the template, coin selection is\nperformed automatically. If the template does contain any inputs, it is\nassumed that full coin selection happened externally and no additional\ninputs are added. If the specified inputs aren't enough to fund the outputs\nwith the given fee rate, an error is returned.\n\nAfter either selecting or verifying the inputs, all input UTXOs are locked\nwith an internal app ID.\n\nNOTE: If this method returns without an error, it is the caller's\nresponsibility to either spend the locked UTXOs (by finalizing and then\npublishing the transaction) or to unlock/release the locked UTXOs in case of\nan error on the caller's side.",
        "operationId": "WalletKit_FundPsbt",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcFundPsbtResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/walletrpcFundPsbtRequest"
            }
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/psbt/sign": {
      "post": {
        "summary": "SignPsbt expects a partial transaction with all inputs and outputs fully\ndeclared and tries to sign all unsigned inputs that have all required fields\n(UTXO information, BIP32 derivation information, witness or sig scripts)\nset.\nIf no error is returned, the PSBT is ready to be given to the next signer or\nto be finalized if lnd was the last signer.",
        "description": "NOTE: This RPC only signs inputs (and only those it can sign), it does not\nperform any other tasks (such as coin selection, UTXO locking or\ninput/output/fee value validation, PSBT finalization). Any input that is\nincomplete will be skipped.",
        "operationId": "WalletKit_SignPsbt",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcSignPsbtResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/walletrpcSignPsbtRequest"
            }
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/send": {
      "post": {
        "summary": "SendOutputs is similar to the existing sendmany call in Bitcoind, and\nallows the caller to create a transaction that sends to several outputs at\nonce. This is ideal when wanting to batch create a set of transactions.",
        "operationId": "WalletKit_SendOutputs",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcSendOutputsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/walletrpcSendOutputsRequest"
            }
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/sweeps": {
      "get": {
        "summary": "ListSweeps returns a list of the sweep transactions our node has produced.\nNote that these sweeps may not be confirmed yet, as we record sweeps on\nbroadcast, not confirmation.",
        "operationId": "WalletKit_ListSweeps",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcListSweepsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "verbose",
            "description": "Retrieve the full sweep transaction details. If false, only the sweep txids\nwill be returned. Note that some sweeps that LND publishes will have been\nreplaced-by-fee, so will not be included in this output.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/sweeps/pending": {
      "get": {
        "summary": "PendingSweeps returns lists of on-chain outputs that lnd is currently\nattempting to sweep within its central batching engine. Outputs with similar\nfee rates are batched together in order to sweep them within a single\ntransaction.",
        "description": "NOTE: Some of the fields within PendingSweepsRequest are not guaranteed to\nremain supported. This is an advanced API that depends on the internals of\nthe UtxoSweeper, so things may change.",
        "operationId": "WalletKit_PendingSweeps",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcPendingSweepsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/tx": {
      "post": {
        "summary": "PublishTransaction attempts to publish the passed transaction to the\nnetwork. Once this returns without an error, the wallet will continually\nattempt to re-broadcast the transaction on start up, until it enters the\nchain.",
        "operationId": "WalletKit_PublishTransaction",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcPublishResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/walletrpcTransaction"
            }
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/tx/label": {
      "post": {
        "summary": "LabelTransaction adds a label to a transaction. If the transaction already\nhas a label the call will fail unless the overwrite bool is set. This will\noverwrite the exiting transaction label. Labels must not be empty, and\ncannot exceed 500 characters.",
        "operationId": "WalletKit_LabelTransaction",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcLabelTransactionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/walletrpcLabelTransactionRequest"
            }
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/utxos": {
      "post": {
        "summary": "ListUnspent returns a list of all utxos spendable by the wallet with a\nnumber of confirmations between the specified minimum and maximum.",
        "operationId": "WalletKit_ListUnspent",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcListUnspentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/walletrpcListUnspentRequest"
            }
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/utxos/lease": {
      "post": {
        "summary": "LeaseOutput locks an output to the given ID, preventing it from being\navailable for any future coin selection attempts. The absolute time of the\nlock's expiration is returned. The expiration of the lock can be extended by\nsuccessive invocations of this RPC. Outputs can be unlocked before their\nexpiration through `ReleaseOutput`.",
        "operationId": "WalletKit_LeaseOutput",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcLeaseOutputResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/walletrpcLeaseOutputRequest"
            }
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/utxos/leases": {
      "post": {
        "summary": "ListLeases lists all currently locked utxos.",
        "operationId": "WalletKit_ListLeases",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcListLeasesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "WalletKit"
        ]
      }
    },
    "/v2/wallet/utxos/release": {
      "post": {
        "summary": "ReleaseOutput unlocks an output, allowing it to be available for coin\nselection if it remains unspent. The ID should match the one used to\noriginally lock the output.",
        "operationId": "WalletKit_ReleaseOutput",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/walletrpcReleaseOutputResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/walletrpcReleaseOutputRequest"
            }
          }
        ],
        "tags": [
          "WalletKit"
        ]
      }
    }
  },
  "definitions": {
    "ListSweepsResponseTransactionIDs": {
      "type": "object",
      "properties": {
        "transaction_ids": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Reversed, hex-encoded string representing the transaction ids of the\nsweeps that our node has broadcast. Note that these transactions may\nnot have confirmed yet, we record sweeps on broadcast, not confirmation."
        }
      }
    },
    "lnrpcAddressType": {
      "type": "string",
      "enum": [
        "WITNESS_PUBKEY_HASH",
        "NESTED_PUBKEY_HASH",
        "UNUSED_WITNESS_PUBKEY_HASH",
        "UNUSED_NESTED_PUBKEY_HASH"
      ],
      "default": "WITNESS_PUBKEY_HASH",
      "description": "- `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)\n- `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)",
      "title": "`AddressType` has to be one of:"
    },
    "lnrpcOutPoint": {
      "type": "object",
      "properties": {
        "txid_bytes": {
          "type": "string",
          "format": "byte",
          "description": "Raw bytes representing the transaction id."
        },
        "txid_str": {
          "type": "string",
          "description": "Reversed, hex-encoded string representing the transaction id."
        },
        "output_index": {
          "type": "integer",
          "format": "int64",
          "description": "The index of the output on the transaction."
        }
      }
    },
    "lnrpcTransaction": {
      "type": "object",
      "properties": {
        "tx_hash": {
          "type": "string",
          "title": "The transaction hash"
        },
        "amount": {
          "type": "string",
          "format": "int64",
          "title": "The transaction amount, denominated in satoshis"
        },
        "num_confirmations": {
          "type": "integer",
          "format": "int32",
          "title": "The number of confirmations"
        },
        "block_hash": {
          "type": "string",
          "title": "The hash of the block this transaction was included in"
        },
        "block_height": {
          "type": "integer",
          "format": "int32",
          "title": "The height of the block this transaction was included in"
        },
        "time_stamp": {
          "type": "string",
          "format": "int64",
          "title": "Timestamp of this transaction"
        },
        "total_fees": {
          "type": "string",
          "format": "int64",
          "title": "Fees paid for this transaction"
        },
        "dest_addresses": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Addresses that received funds for this transaction"
        },
        "raw_tx_hex": {
          "type": "string",
          "description": "The raw transaction hex."
        },
        "label": {
          "type": "string",
          "description": "A label that was optionally set on transaction broadcast."
        }
      }
    },
    "lnrpcTransactionDetails": {
      "type": "object",
      "properties": {
        "transactions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/lnrpcTransaction"
          },
          "description": "The list of transactions relevant to the wallet."
        }
      }
    },
    "lnrpcUtxo": {
      "type": "object",
      "properties": {
        "address_type": {
          "$ref": "#/definitions/lnrpcAddressType",
          "title": "The type of address"
        },
        "address": {
          "type": "string",
          "title": "The address"
        },
        "amount_sat": {
          "type": "string",
          "format": "int64",
          "title": "The value of the unspent coin in satoshis"
        },
        "pk_script": {
          "type": "string",
          "title": "The pkscript in hex"
        },
        "outpoint": {
          "$ref": "#/definitions/lnrpcOutPoint",
          "title": "The outpoint in format txid:n"
        },
        "confirmations": {
          "type": "string",
          "format": "int64",
          "title": "The number of confirmations for the Utxo"
        }
      }
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string"
        },
        "value": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "signrpcKeyDescriptor": {
      "type": "object",
      "properties": {
        "raw_key_bytes": {
          "type": "string",
          "format": "byte",
          "description": "The raw bytes of the public key in the key pair being identified. Either\nthis or the KeyLocator must be specified."
        },
        "key_loc": {
          "$ref": "#/definitions/signrpcKeyLocator",
          "description": "The key locator that identifies which private key to use for signing.\nEither this or the raw bytes of the target public key must be specified."
        }
      }
    },
    "signrpcKeyLocator": {
      "type": "object",
      "properties": {
        "key_family": {
          "type": "integer",
          "format": "int32",
          "description": "The family of key being identified."
        },
        "key_index": {
          "type": "integer",
          "format": "int32",
          "description": "The precise index of the key being identified."
        }
      }
    },
    "signrpcTxOut": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string",
          "format": "int64",
          "description": "The value of the output being spent."
        },
        "pk_script": {
          "type": "string",
          "format": "byte",
          "description": "The script of the output being spent."
        }
      }
    },
    "walletrpcAccount": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name used to identify the account."
        },
        "address_type": {
          "$ref": "#/definitions/walletrpcAddressType",
          "title": "The type of addresses the account supports.\nAddressType                       | External Branch | Internal Branch\n---------------------------------------------------------------------\nWITNESS_PUBKEY_HASH               | P2WPKH          | P2WPKH\nNESTED_WITNESS_PUBKEY_HASH        | NP2WPKH         | NP2WPKH\nHYBRID_NESTED_WITNESS_PUBKEY_HASH | NP2WPKH         | P2WPKH"
        },
        "extended_public_key": {
          "type": "string",
          "description": "The public key backing the account that all keys are derived from\nrepresented as an extended key. This will always be empty for the default\nimported account in which single public keys are imported into."
        },
        "master_key_fingerprint": {
          "type": "string",
          "format": "byte",
          "description": "The fingerprint of the root key from which the account public key was\nderived from. This will always be zero for the default imported account in\nwhich single public keys are imported into. The bytes are in big-endian\norder."
        },
        "derivation_path": {
          "type": "string",
          "description": "The derivation path corresponding to the account public key. This will\nalways be empty for the default imported account in which single public keys\nare imported into."
        },
        "external_key_count": {
          "type": "integer",
          "format": "int64",
          "description": "The number of keys derived from the external branch of the account public\nkey. This will always be zero for the default imported account in which\nsingle public keys are imported into."
        },
        "internal_key_count": {
          "type": "integer",
          "format": "int64",
          "description": "The number of keys derived from the internal branch of the account public\nkey. This will always be zero for the default imported account in which\nsingle public keys are imported into."
        },
        "watch_only": {
          "type": "boolean",
          "description": "Whether the wallet stores private keys for the account."
        }
      }
    },
    "walletrpcAddrRequest": {
      "type": "object",
      "properties": {
        "account": {
          "type": "string",
          "description": "The name of the account to retrieve the next address of. If empty, the\ndefault wallet account is used."
        },
        "type": {
          "$ref": "#/definitions/walletrpcAddressType",
          "description": "The type of address to derive."
        },
        "change": {
          "type": "boolean",
          "description": "Whether a change address should be derived."
        }
      }
    },
    "walletrpcAddrResponse": {
      "type": "object",
      "properties": {
        "addr": {
          "type": "string",
          "description": "The address encoded using a bech32 format."
        }
      }
    },
    "walletrpcAddressType": {
      "type": "string",
      "enum": [
        "UNKNOWN",
        "WITNESS_PUBKEY_HASH",
        "NESTED_WITNESS_PUBKEY_HASH",
        "HYBRID_NESTED_WITNESS_PUBKEY_HASH"
      ],
      "default": "UNKNOWN"
    },
    "walletrpcBumpFeeRequest": {
      "type": "object",
      "properties": {
        "outpoint": {
          "$ref": "#/definitions/lnrpcOutPoint",
          "description": "The input we're attempting to bump the fee of."
        },
        "target_conf": {
          "type": "integer",
          "format": "int64",
          "description": "The target number of blocks that the input should be spent within."
        },
        "sat_per_byte": {
          "type": "integer",
          "format": "int64",
          "description": "Deprecated, use sat_per_vbyte.\nThe fee rate, expressed in sat/vbyte, that should be used to spend the input\nwith."
        },
        "force": {
          "type": "boolean",
          "description": "Whether this input must be force-swept. This means that it is swept even\nif it has a negative yield."
        },
        "sat_per_vbyte": {
          "type": "string",
          "format": "uint64",
          "description": "The fee rate, expressed in sat/vbyte, that should be used to spend the input\nwith."
        }
      }
    },
    "walletrpcBumpFeeResponse": {
      "type": "object"
    },
    "walletrpcEstimateFeeResponse": {
      "type": "object",
      "properties": {
        "sat_per_kw": {
          "type": "string",
          "format": "int64",
          "description": "The amount of satoshis per kw that should be used in order to reach the\nconfirmation target in the request."
        }
      }
    },
    "walletrpcFinalizePsbtRequest": {
      "type": "object",
      "properties": {
        "funded_psbt": {
          "type": "string",
          "format": "byte",
          "description": "A PSBT that should be signed and finalized. The PSBT must contain all\nrequired inputs, outputs, UTXO data and partial signatures of all other\nsigners."
        },
        "account": {
          "type": "string",
          "description": "The name of the account to finalize the PSBT with. If empty, the default\nwallet account is used."
        }
      }
    },
    "walletrpcFinalizePsbtResponse": {
      "type": "object",
      "properties": {
        "signed_psbt": {
          "type": "string",
          "format": "byte",
          "description": "The fully signed and finalized transaction in PSBT format."
        },
        "raw_final_tx": {
          "type": "string",
          "format": "byte",
          "description": "The fully signed and finalized transaction in the raw wire format."
        }
      }
    },
    "walletrpcFundPsbtRequest": {
      "type": "object",
      "properties": {
        "psbt": {
          "type": "string",
          "format": "byte",
          "description": "Use an existing PSBT packet as the template for the funded PSBT.\n\nThe packet must contain at least one non-dust output. If one or more\ninputs are specified, no coin selection is performed. In that case every\ninput must be an UTXO known to the wallet that has not been locked\nbefore. The sum of all inputs must be sufficiently greater than the sum\nof all outputs to pay a miner fee with the specified fee rate. A change\noutput is added to the PSBT if necessary."
        },
        "raw": {
          "$ref": "#/definitions/walletrpcTxTemplate",
          "description": "Use the outputs and optional inputs from this raw template."
        },
        "target_conf": {
          "type": "integer",
          "format": "int64",
          "description": "The target number of blocks that the transaction should be confirmed in."
        },
        "sat_per_vbyte": {
          "type": "string",
          "format": "uint64",
          "description": "The fee rate, expressed in sat/vbyte, that should be used to spend the\ninput with."
        },
        "account": {
          "type": "string",
          "description": "The name of the account to fund the PSBT with. If empty, the default wallet\naccount is used."
        },
        "min_confs": {
          "type": "integer",
          "format": "int32",
          "description": "The minimum number of confirmations each one of your outputs used for\nthe transaction must satisfy."
        },
        "spend_unconfirmed": {
          "type": "boolean",
          "description": "Whether unconfirmed outputs should be used as inputs for the transaction."
        }
      }
    },
    "walletrpcFundPsbtResponse": {
      "type": "object",
      "properties": {
        "funded_psbt": {
          "type": "string",
          "format": "byte",
          "description": "The funded but not yet signed PSBT packet."
        },
        "change_output_index": {
          "type": "integer",
          "format": "int32",
          "description": "The index of the added change output or -1 if no change was left over."
        },
        "locked_utxos": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/walletrpcUtxoLease"
          },
          "description": "The list of lock leases that were acquired for the inputs in the funded PSBT\npacket."
        }
      }
    },
    "walletrpcImportAccountRequest": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "A name to identify the account with."
        },
        "extended_public_key": {
          "type": "string",
          "description": "A public key that corresponds to a wallet account represented as an extended\nkey. It must conform to a derivation path of the form\nm/purpose'/coin_type'/account'."
        },
        "master_key_fingerprint": {
          "type": "string",
          "format": "byte",
          "description": "The fingerprint of the root key (also known as the key with derivation path\nm/) from which the account public key was derived from. This may be required\nby some hardware wallets for proper identification and signing. The bytes\nmust be in big-endian order."
        },
        "address_type": {
          "$ref": "#/definitions/walletrpcAddressType",
          "description": "An address type is only required when the extended account public key has a\nlegacy version (xpub, tpub, etc.), such that the wallet cannot detect what\naddress scheme it belongs to."
        },
        "dry_run": {
          "type": "boolean",
          "description": "Whether a dry run should be attempted when importing the account. This\nserves as a way to confirm whether the account is being imported correctly\nby returning the first N addresses for the external and internal branches of\nthe account. If these addresses match as expected, then it should be safe to\nimport the account as is."
        }
      }
    },
    "walletrpcImportAccountResponse": {
      "type": "object",
      "properties": {
        "account": {
          "$ref": "#/definitions/walletrpcAccount",
          "description": "The details of the imported account."
        },
        "dry_run_external_addrs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The first N addresses that belong to the external branch of the account.\nThe external branch is typically used for external non-change addresses.\nThese are only returned if a dry run was specified within the request."
        },
        "dry_run_internal_addrs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The first N addresses that belong to the internal branch of the account.\nThe internal branch is typically used for change addresses. These are only\nreturned if a dry run was specified within the request."
        }
      }
    },
    "walletrpcImportPublicKeyRequest": {
      "type": "object",
      "properties": {
        "public_key": {
          "type": "string",
          "format": "byte",
          "description": "A compressed public key represented as raw bytes."
        },
        "address_type": {
          "$ref": "#/definitions/walletrpcAddressType",
          "description": "The type of address that will be generated from the public key."
        }
      }
    },
    "walletrpcImportPublicKeyResponse": {
      "type": "object"
    },
    "walletrpcKeyReq": {
      "type": "object",
      "properties": {
        "key_finger_print": {
          "type": "integer",
          "format": "int32",
          "description": "Is the key finger print of the root pubkey that this request is targeting.\nThis allows the WalletKit to possibly serve out keys for multiple HD chains\nvia public derivation."
        },
        "key_family": {
          "type": "integer",
          "format": "int32",
          "description": "The target key family to derive a key from. In other contexts, this is\nknown as the \"account\"."
        }
      }
    },
    "walletrpcLabelTransactionRequest": {
      "type": "object",
      "properties": {
        "txid": {
          "type": "string",
          "format": "byte",
          "description": "The txid of the transaction to label."
        },
        "label": {
          "type": "string",
          "description": "The label to add to the transaction, limited to 500 characters."
        },
        "overwrite": {
          "type": "boolean",
          "description": "Whether to overwrite the existing label, if it is present."
        }
      }
    },
    "walletrpcLabelTransactionResponse": {
      "type": "object"
    },
    "walletrpcLeaseOutputRequest": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "byte",
          "description": "An ID of 32 random bytes that must be unique for each distinct application\nusing this RPC which will be used to bound the output lease to."
        },
        "outpoint": {
          "$ref": "#/definitions/lnrpcOutPoint",
          "description": "The identifying outpoint of the output being leased."
        },
        "expiration_seconds": {
          "type": "string",
          "format": "uint64",
          "description": "The time in seconds before the lock expires. If set to zero, the default\nlock duration is used."
        }
      }
    },
    "walletrpcLeaseOutputResponse": {
      "type": "object",
      "properties": {
        "expiration": {
          "type": "string",
          "format": "uint64",
          "description": "The absolute expiration of the output lease represented as a unix timestamp."
        }
      }
    },
    "walletrpcListAccountsResponse": {
      "type": "object",
      "properties": {
        "accounts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/walletrpcAccount"
          }
        }
      }
    },
    "walletrpcListLeasesResponse": {
      "type": "object",
      "properties": {
        "locked_utxos": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/walletrpcUtxoLease"
          },
          "description": "The list of currently leased utxos."
        }
      }
    },
    "walletrpcListSweepsResponse": {
      "type": "object",
      "properties": {
        "transaction_details": {
          "$ref": "#/definitions/lnrpcTransactionDetails"
        },
        "transaction_ids": {
          "$ref": "#/definitions/ListSweepsResponseTransactionIDs"
        }
      }
    },
    "walletrpcListUnspentRequest": {
      "type": "object",
      "properties": {
        "min_confs": {
          "type": "integer",
          "format": "int32",
          "description": "The minimum number of confirmations to be included."
        },
        "max_confs": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum number of confirmations to be included."
        },
        "account": {
          "type": "string",
          "description": "An optional filter to only include outputs belonging to an account."
        }
      }
    },
    "walletrpcListUnspentResponse": {
      "type": "object",
      "properties": {
        "utxos": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/lnrpcUtxo"
          },
          "description": "A list of utxos satisfying the specified number of confirmations."
        }
      }
    },
    "walletrpcPendingSweep": {
      "type": "object",
      "properties": {
        "outpoint": {
          "$ref": "#/definitions/lnrpcOutPoint",
          "description": "The outpoint of the output we're attempting to sweep."
        },
        "witness_type": {
          "$ref": "#/definitions/walletrpcWitnessType",
          "description": "The witness type of the output we're attempting to sweep."
        },
        "amount_sat": {
          "type": "integer",
          "format": "int64",
          "description": "The value of the output we're attempting to sweep."
        },
        "sat_per_byte": {
          "type": "integer",
          "format": "int64",
          "description": "Deprecated, use sat_per_vbyte.\nThe fee rate we'll use to sweep the output, expressed in sat/vbyte. The fee\nrate is only determined once a sweeping transaction for the output is\ncreated, so it's possible for this to be 0 before this."
        },
        "broadcast_attempts": {
          "type": "integer",
          "format": "int64",
          "description": "The number of broadcast attempts we've made to sweep the output."
        },
        "next_broadcast_height": {
          "type": "integer",
          "format": "int64",
          "description": "The next height of the chain at which we'll attempt to broadcast the\nsweep transaction of the output."
        },
        "requested_conf_target": {
          "type": "integer",
          "format": "int64",
          "description": "The requested confirmation target for this output."
        },
        "requested_sat_per_byte": {
          "type": "integer",
          "format": "int64",
          "description": "Deprecated, use requested_sat_per_vbyte.\nThe requested fee rate, expressed in sat/vbyte, for this output."
        },
        "sat_per_vbyte": {
          "type": "string",
          "format": "uint64",
          "description": "The fee rate we'll use to sweep the output, expressed in sat/vbyte. The fee\nrate is only determined once a sweeping transaction for the output is\ncreated, so it's possible for this to be 0 before this."
        },
        "requested_sat_per_vbyte": {
          "type": "string",
          "format": "uint64",
          "description": "The requested fee rate, expressed in sat/vbyte, for this output."
        },
        "force": {
          "type": "boolean",
          "description": "Whether this input must be force-swept. This means that it is swept even\nif it has a negative yield."
        }
      }
    },
    "walletrpcPendingSweepsResponse": {
      "type": "object",
      "properties": {
        "pending_sweeps": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/walletrpcPendingSweep"
          },
          "description": "The set of outputs currently being swept by lnd's central batching engine."
        }
      }
    },
    "walletrpcPublishResponse": {
      "type": "object",
      "properties": {
        "publish_error": {
          "type": "string",
          "description": "If blank, then no error occurred and the transaction was successfully\npublished. If not the empty string, then a string representation of the\nbroadcast error.\n\nTODO(roasbeef): map to a proper enum type"
        }
      }
    },
    "walletrpcReleaseOutputRequest": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "byte",
          "description": "The unique ID that was used to lock the output."
        },
        "outpoint": {
          "$ref": "#/definitions/lnrpcOutPoint",
          "description": "The identifying outpoint of the output being released."
        }
      }
    },
    "walletrpcReleaseOutputResponse": {
      "type": "object"
    },
    "walletrpcSendOutputsRequest": {
      "type": "object",
      "properties": {
        "sat_per_kw": {
          "type": "string",
          "format": "int64",
          "description": "The number of satoshis per kilo weight that should be used when crafting\nthis transaction."
        },
        "outputs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/signrpcTxOut"
          },
          "description": "A slice of the outputs that should be created in the transaction produced."
        },
        "label": {
          "type": "string",
          "description": "An optional label for the transaction, limited to 500 characters."
        },
        "min_confs": {
          "type": "integer",
          "format": "int32",
          "description": "The minimum number of confirmations each one of your outputs used for\nthe transaction must satisfy."
        },
        "spend_unconfirmed": {
          "type": "boolean",
          "description": "Whether unconfirmed outputs should be used as inputs for the transaction."
        }
      }
    },
    "walletrpcSendOutputsResponse": {
      "type": "object",
      "properties": {
        "raw_tx": {
          "type": "string",
          "format": "byte",
          "description": "The serialized transaction sent out on the network."
        }
      }
    },
    "walletrpcSignPsbtRequest": {
      "type": "object",
      "properties": {
        "funded_psbt": {
          "type": "string",
          "format": "byte",
          "description": "The PSBT that should be signed. The PSBT must contain all required inputs,\noutputs, UTXO data and custom fields required to identify the signing key."
        }
      }
    },
    "walletrpcSignPsbtResponse": {
      "type": "object",
      "properties": {
        "signed_psbt": {
          "type": "string",
          "format": "byte",
          "description": "The signed transaction in PSBT format."
        }
      }
    },
    "walletrpcTransaction": {
      "type": "object",
      "properties": {
        "tx_hex": {
          "type": "string",
          "format": "byte",
          "description": "The raw serialized transaction."
        },
        "label": {
          "type": "string",
          "description": "An optional label to save with the transaction. Limited to 500 characters."
        }
      }
    },
    "walletrpcTxTemplate": {
      "type": "object",
      "properties": {
        "inputs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/lnrpcOutPoint"
          },
          "description": "An optional list of inputs to use. Every input must be an UTXO known to the\nwallet that has not been locked before. The sum of all inputs must be\nsufficiently greater than the sum of all outputs to pay a miner fee with the\nfee rate specified in the parent message.\n\nIf no inputs are specified, coin selection will be performed instead and\ninputs of sufficient value will be added to the resulting PSBT."
        },
        "outputs": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "uint64"
          },
          "description": "A map of all addresses and the amounts to send to in the funded PSBT."
        }
      }
    },
    "walletrpcUtxoLease": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "byte",
          "description": "A 32 byte random ID that identifies the lease."
        },
        "outpoint": {
          "$ref": "#/definitions/lnrpcOutPoint",
          "description": "The identifying outpoint of the output being leased."
        },
        "expiration": {
          "type": "string",
          "format": "uint64",
          "description": "The absolute expiration of the output lease represented as a unix timestamp."
        }
      }
    },
    "walletrpcWitnessType": {
      "type": "string",
      "enum": [
        "UNKNOWN_WITNESS",
        "COMMITMENT_TIME_LOCK",
        "COMMITMENT_NO_DELAY",
        "COMMITMENT_REVOKE",
        "HTLC_OFFERED_REVOKE",
        "HTLC_ACCEPTED_REVOKE",
        "HTLC_OFFERED_TIMEOUT_SECOND_LEVEL",
        "HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL",
        "HTLC_OFFERED_REMOTE_TIMEOUT",
        "HTLC_ACCEPTED_REMOTE_SUCCESS",
        "HTLC_SECOND_LEVEL_REVOKE",
        "WITNESS_KEY_HASH",
        "NESTED_WITNESS_KEY_HASH",
        "COMMITMENT_ANCHOR"
      ],
      "default": "UNKNOWN_WITNESS",
      "description": " - COMMITMENT_TIME_LOCK: A witness that allows us to spend the output of a commitment transaction\nafter a relative lock-time lockout.\n - COMMITMENT_NO_DELAY: A witness that allows us to spend a settled no-delay output immediately on a\ncounterparty's commitment transaction.\n - COMMITMENT_REVOKE: A witness that allows us to sweep the settled output of a malicious\ncounterparty's who broadcasts a revoked commitment transaction.\n - HTLC_OFFERED_REVOKE: A witness that allows us to sweep an HTLC which we offered to the remote\nparty in the case that they broadcast a revoked commitment state.\n - HTLC_ACCEPTED_REVOKE: A witness that allows us to sweep an HTLC output sent to us in the case that\nthe remote party broadcasts a revoked commitment state.\n - HTLC_OFFERED_TIMEOUT_SECOND_LEVEL: A witness that allows us to sweep an HTLC output that we extended to a\nparty, but was never fulfilled.  This HTLC output isn't directly on the\ncommitment transaction, but is the result of a confirmed second-level HTLC\ntransaction. As a result, we can only spend this after a CSV delay.\n - HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL: A witness that allows us to sweep an HTLC output that was offered to us, and\nfor which we have a payment preimage. This HTLC output isn't directly on our\ncommitment transaction, but is the result of confirmed second-level HTLC\ntransaction. As a result, we can only spend this after a CSV delay.\n - HTLC_OFFERED_REMOTE_TIMEOUT: A witness that allows us to sweep an HTLC that we offered to the remote\nparty which lies in the commitment transaction of the remote party. We can\nspend this output after the absolute CLTV timeout of the HTLC as passed.\n - HTLC_ACCEPTED_REMOTE_SUCCESS: A witness that allows us to sweep an HTLC that was offered to us by the\nremote party. We use this witness in the case that the remote party goes to\nchain, and we know the pre-image to the HTLC. We can sweep this without any\nadditional timeout.\n - HTLC_SECOND_LEVEL_REVOKE: A witness that allows us to sweep an HTLC from the remote party's commitment\ntransaction in the case that the broadcast a revoked commitment, but then\nalso immediately attempt to go to the second level to claim the HTLC.\n - WITNESS_KEY_HASH: A witness type that allows us to spend a regular p2wkh output that's sent to\nan output which is under complete control of the backing wallet.\n - NESTED_WITNESS_KEY_HASH: A witness type that allows us to sweep an output that sends to a nested P2SH\nscript that pays to a key solely under our control.\n - COMMITMENT_ANCHOR: A witness type that allows us to spend our anchor on the commitment\ntransaction."
    }
  }
}
