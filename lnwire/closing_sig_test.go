package lnwire

import (
	"bytes"
	"testing"

	"github.com/stretchr/testify/require"
)

// TestClosingSigEncodeDecode tests that a raw byte stream can be
// decoded, then re-encoded to the same exact byte stream.
func TestClosingSigEncodeDecode(t *testing.T) {
	t.Parallel()

	// Create a sample ClosingSig message.
	var rawBytes []byte

	// ChannelID
	rawBytes = append(rawBytes, make([]byte, 32)...)

	// CloserScript
	rawBytes = append(rawBytes, []byte{0, 1, 0xaa}...)

	// CloseeScript
	rawBytes = append(rawBytes, []byte{0, 1, 0xbb}...)

	// FeeSatoshis
	rawBytes = append(rawBytes, []byte{0, 0, 0, 0, 0, 0, 0, 1}...)

	// LockTime
	rawBytes = append(rawBytes, []byte{0, 0, 0, 2}...)

	// Add TLV data, including known and unknown records.
	tlvData := []byte{
		// CloserNoClosee (known, type 1)
		1,  // type
		64, // length
		// 64 bytes of dummy signature data
		0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
		0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
		0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
		0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
		0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
		0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
		0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
		0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,

		// NoCloserClosee (known, type 2)
		2,  // type
		64, // length
		// 64 bytes of dummy signature data
		0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
		0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
		0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
		0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
		0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
		0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
		0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
		0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,

		// CloserAndClosee (known, type 3)
		3,  // type
		64, // length
		// 64 bytes of dummy signature data
		0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,

		// Unknown odd-type TLV record.
		0x5,        // type
		0x2,        // length
		0xab, 0xcd, // value

		// Another unknown odd-type TLV record at the end.
		0x6f,       // type
		0x2,        // length
		0x79, 0x79, // value
	}
	rawBytes = append(rawBytes, tlvData...)

	// Now, create a new empty message and decode the raw bytes into it.
	msg := &ClosingSig{}
	r := bytes.NewReader(rawBytes)
	err := msg.Decode(r, 0)
	require.NoError(t, err)

	// Next, encode the message back into a new byte buffer.
	var b bytes.Buffer
	err = msg.Encode(&b, 0)
	require.NoError(t, err)

	// The re-encoded bytes should be exactly the same as the original raw
	// bytes.
	require.Equal(t, rawBytes, b.Bytes())
}
