// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: graph.sql

package sqlc

import (
	"context"
	"database/sql"
)

const addSourceNode = `-- name: AddSourceNode :exec
/* ─────────────────────────────────────────────
   source_nodes table queries
   ─────────────────────────────────────────────
*/

INSERT INTO source_nodes (node_id)
VALUES ($1)
ON CONFLICT (node_id) DO NOTHING
`

func (q *Queries) AddSourceNode(ctx context.Context, nodeID int64) error {
	_, err := q.db.ExecContext(ctx, addSourceNode, nodeID)
	return err
}

const addV1ChannelProof = `-- name: AddV1ChannelProof :execresult
UPDATE channels
SET node_1_signature = $2,
    node_2_signature = $3,
    bitcoin_1_signature = $4,
    bitcoin_2_signature = $5
WHERE scid = $1
  AND version = 1
`

type AddV1ChannelProofParams struct {
	Scid              []byte
	Node1Signature    []byte
	Node2Signature    []byte
	Bitcoin1Signature []byte
	Bitcoin2Signature []byte
}

func (q *Queries) AddV1ChannelProof(ctx context.Context, arg AddV1ChannelProofParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, addV1ChannelProof,
		arg.Scid,
		arg.Node1Signature,
		arg.Node2Signature,
		arg.Bitcoin1Signature,
		arg.Bitcoin2Signature,
	)
}

const countZombieChannels = `-- name: CountZombieChannels :one
SELECT COUNT(*)
FROM zombie_channels
WHERE version = $1
`

func (q *Queries) CountZombieChannels(ctx context.Context, version int16) (int64, error) {
	row := q.db.QueryRowContext(ctx, countZombieChannels, version)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChannel = `-- name: CreateChannel :one
/* ─────────────────────────────────────────────
   channels table queries
   ─────────────────────────────────────────────
*/

INSERT INTO channels (
    version, scid, node_id_1, node_id_2,
    outpoint, capacity, bitcoin_key_1, bitcoin_key_2,
    node_1_signature, node_2_signature, bitcoin_1_signature,
    bitcoin_2_signature
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id
`

type CreateChannelParams struct {
	Version           int16
	Scid              []byte
	NodeID1           int64
	NodeID2           int64
	Outpoint          string
	Capacity          sql.NullInt64
	BitcoinKey1       []byte
	BitcoinKey2       []byte
	Node1Signature    []byte
	Node2Signature    []byte
	Bitcoin1Signature []byte
	Bitcoin2Signature []byte
}

func (q *Queries) CreateChannel(ctx context.Context, arg CreateChannelParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createChannel,
		arg.Version,
		arg.Scid,
		arg.NodeID1,
		arg.NodeID2,
		arg.Outpoint,
		arg.Capacity,
		arg.BitcoinKey1,
		arg.BitcoinKey2,
		arg.Node1Signature,
		arg.Node2Signature,
		arg.Bitcoin1Signature,
		arg.Bitcoin2Signature,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createChannelExtraType = `-- name: CreateChannelExtraType :exec
/* ─────────────────────────────────────────────
   channel_extra_types table queries
   ─────────────────────────────────────────────
*/

INSERT INTO channel_extra_types (
    channel_id, type, value
)
VALUES ($1, $2, $3)
`

type CreateChannelExtraTypeParams struct {
	ChannelID int64
	Type      int64
	Value     []byte
}

func (q *Queries) CreateChannelExtraType(ctx context.Context, arg CreateChannelExtraTypeParams) error {
	_, err := q.db.ExecContext(ctx, createChannelExtraType, arg.ChannelID, arg.Type, arg.Value)
	return err
}

const deleteChannel = `-- name: DeleteChannel :exec
DELETE FROM channels WHERE id = $1
`

func (q *Queries) DeleteChannel(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteChannel, id)
	return err
}

const deleteChannelPolicyExtraTypes = `-- name: DeleteChannelPolicyExtraTypes :exec
DELETE FROM channel_policy_extra_types
WHERE channel_policy_id = $1
`

func (q *Queries) DeleteChannelPolicyExtraTypes(ctx context.Context, channelPolicyID int64) error {
	_, err := q.db.ExecContext(ctx, deleteChannelPolicyExtraTypes, channelPolicyID)
	return err
}

const deleteExtraNodeType = `-- name: DeleteExtraNodeType :exec
DELETE FROM node_extra_types
WHERE node_id = $1
  AND type = $2
`

type DeleteExtraNodeTypeParams struct {
	NodeID int64
	Type   int64
}

func (q *Queries) DeleteExtraNodeType(ctx context.Context, arg DeleteExtraNodeTypeParams) error {
	_, err := q.db.ExecContext(ctx, deleteExtraNodeType, arg.NodeID, arg.Type)
	return err
}

const deleteNode = `-- name: DeleteNode :exec
DELETE FROM nodes
WHERE id = $1
`

func (q *Queries) DeleteNode(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteNode, id)
	return err
}

const deleteNodeAddresses = `-- name: DeleteNodeAddresses :exec
DELETE FROM node_addresses
WHERE node_id = $1
`

func (q *Queries) DeleteNodeAddresses(ctx context.Context, nodeID int64) error {
	_, err := q.db.ExecContext(ctx, deleteNodeAddresses, nodeID)
	return err
}

const deleteNodeByPubKey = `-- name: DeleteNodeByPubKey :execresult
DELETE FROM nodes
WHERE pub_key = $1
  AND version = $2
`

type DeleteNodeByPubKeyParams struct {
	PubKey  []byte
	Version int16
}

func (q *Queries) DeleteNodeByPubKey(ctx context.Context, arg DeleteNodeByPubKeyParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteNodeByPubKey, arg.PubKey, arg.Version)
}

const deleteNodeFeature = `-- name: DeleteNodeFeature :exec
DELETE FROM node_features
WHERE node_id = $1
  AND feature_bit = $2
`

type DeleteNodeFeatureParams struct {
	NodeID     int64
	FeatureBit int32
}

func (q *Queries) DeleteNodeFeature(ctx context.Context, arg DeleteNodeFeatureParams) error {
	_, err := q.db.ExecContext(ctx, deleteNodeFeature, arg.NodeID, arg.FeatureBit)
	return err
}

const deletePruneLogEntriesInRange = `-- name: DeletePruneLogEntriesInRange :exec
DELETE FROM prune_log
WHERE block_height >= $1
  AND block_height <= $2
`

type DeletePruneLogEntriesInRangeParams struct {
	StartHeight int64
	EndHeight   int64
}

func (q *Queries) DeletePruneLogEntriesInRange(ctx context.Context, arg DeletePruneLogEntriesInRangeParams) error {
	_, err := q.db.ExecContext(ctx, deletePruneLogEntriesInRange, arg.StartHeight, arg.EndHeight)
	return err
}

const deleteUnconnectedNodes = `-- name: DeleteUnconnectedNodes :many
DELETE FROM nodes
WHERE
    -- Ignore any of our source nodes.
    NOT EXISTS (
        SELECT 1
        FROM source_nodes sn
        WHERE sn.node_id = nodes.id
    )
    -- Select all nodes that do not have any channels.
    AND NOT EXISTS (
        SELECT 1
        FROM channels c
        WHERE c.node_id_1 = nodes.id OR c.node_id_2 = nodes.id
) RETURNING pub_key
`

func (q *Queries) DeleteUnconnectedNodes(ctx context.Context) ([][]byte, error) {
	rows, err := q.db.QueryContext(ctx, deleteUnconnectedNodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var pub_key []byte
		if err := rows.Scan(&pub_key); err != nil {
			return nil, err
		}
		items = append(items, pub_key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteZombieChannel = `-- name: DeleteZombieChannel :execresult
DELETE FROM zombie_channels
WHERE scid = $1
AND version = $2
`

type DeleteZombieChannelParams struct {
	Scid    []byte
	Version int16
}

func (q *Queries) DeleteZombieChannel(ctx context.Context, arg DeleteZombieChannelParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteZombieChannel, arg.Scid, arg.Version)
}

const getChannelAndNodesBySCID = `-- name: GetChannelAndNodesBySCID :one
SELECT
    c.id, c.version, c.scid, c.node_id_1, c.node_id_2, c.outpoint, c.capacity, c.bitcoin_key_1, c.bitcoin_key_2, c.node_1_signature, c.node_2_signature, c.bitcoin_1_signature, c.bitcoin_2_signature,
    n1.pub_key AS node1_pub_key,
    n2.pub_key AS node2_pub_key
FROM channels c
    JOIN nodes n1 ON c.node_id_1 = n1.id
    JOIN nodes n2 ON c.node_id_2 = n2.id
WHERE c.scid = $1
  AND c.version = $2
`

type GetChannelAndNodesBySCIDParams struct {
	Scid    []byte
	Version int16
}

type GetChannelAndNodesBySCIDRow struct {
	ID                int64
	Version           int16
	Scid              []byte
	NodeID1           int64
	NodeID2           int64
	Outpoint          string
	Capacity          sql.NullInt64
	BitcoinKey1       []byte
	BitcoinKey2       []byte
	Node1Signature    []byte
	Node2Signature    []byte
	Bitcoin1Signature []byte
	Bitcoin2Signature []byte
	Node1PubKey       []byte
	Node2PubKey       []byte
}

func (q *Queries) GetChannelAndNodesBySCID(ctx context.Context, arg GetChannelAndNodesBySCIDParams) (GetChannelAndNodesBySCIDRow, error) {
	row := q.db.QueryRowContext(ctx, getChannelAndNodesBySCID, arg.Scid, arg.Version)
	var i GetChannelAndNodesBySCIDRow
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.Scid,
		&i.NodeID1,
		&i.NodeID2,
		&i.Outpoint,
		&i.Capacity,
		&i.BitcoinKey1,
		&i.BitcoinKey2,
		&i.Node1Signature,
		&i.Node2Signature,
		&i.Bitcoin1Signature,
		&i.Bitcoin2Signature,
		&i.Node1PubKey,
		&i.Node2PubKey,
	)
	return i, err
}

const getChannelByOutpoint = `-- name: GetChannelByOutpoint :one
SELECT
    c.id, c.version, c.scid, c.node_id_1, c.node_id_2, c.outpoint, c.capacity, c.bitcoin_key_1, c.bitcoin_key_2, c.node_1_signature, c.node_2_signature, c.bitcoin_1_signature, c.bitcoin_2_signature,
    n1.pub_key AS node1_pubkey,
    n2.pub_key AS node2_pubkey
FROM channels c
    JOIN nodes n1 ON c.node_id_1 = n1.id
    JOIN nodes n2 ON c.node_id_2 = n2.id
WHERE c.outpoint = $1
`

type GetChannelByOutpointRow struct {
	Channel     Channel
	Node1Pubkey []byte
	Node2Pubkey []byte
}

func (q *Queries) GetChannelByOutpoint(ctx context.Context, outpoint string) (GetChannelByOutpointRow, error) {
	row := q.db.QueryRowContext(ctx, getChannelByOutpoint, outpoint)
	var i GetChannelByOutpointRow
	err := row.Scan(
		&i.Channel.ID,
		&i.Channel.Version,
		&i.Channel.Scid,
		&i.Channel.NodeID1,
		&i.Channel.NodeID2,
		&i.Channel.Outpoint,
		&i.Channel.Capacity,
		&i.Channel.BitcoinKey1,
		&i.Channel.BitcoinKey2,
		&i.Channel.Node1Signature,
		&i.Channel.Node2Signature,
		&i.Channel.Bitcoin1Signature,
		&i.Channel.Bitcoin2Signature,
		&i.Node1Pubkey,
		&i.Node2Pubkey,
	)
	return i, err
}

const getChannelByOutpointWithPolicies = `-- name: GetChannelByOutpointWithPolicies :one
SELECT
    c.id, c.version, c.scid, c.node_id_1, c.node_id_2, c.outpoint, c.capacity, c.bitcoin_key_1, c.bitcoin_key_2, c.node_1_signature, c.node_2_signature, c.bitcoin_1_signature, c.bitcoin_2_signature,

    n1.pub_key AS node1_pubkey,
    n2.pub_key AS node2_pubkey,

    -- Node 1 policy
    cp1.id AS policy_1_id,
    cp1.node_id AS policy_1_node_id,
    cp1.version AS policy_1_version,
    cp1.timelock AS policy_1_timelock,
    cp1.fee_ppm AS policy_1_fee_ppm,
    cp1.base_fee_msat AS policy_1_base_fee_msat,
    cp1.min_htlc_msat AS policy_1_min_htlc_msat,
    cp1.max_htlc_msat AS policy_1_max_htlc_msat,
    cp1.last_update AS policy_1_last_update,
    cp1.disabled AS policy_1_disabled,
    cp1.inbound_base_fee_msat AS policy1_inbound_base_fee_msat,
    cp1.inbound_fee_rate_milli_msat AS policy1_inbound_fee_rate_milli_msat,
    cp1.signature AS policy_1_signature,

    -- Node 2 policy
    cp2.id AS policy_2_id,
    cp2.node_id AS policy_2_node_id,
    cp2.version AS policy_2_version,
    cp2.timelock AS policy_2_timelock,
    cp2.fee_ppm AS policy_2_fee_ppm,
    cp2.base_fee_msat AS policy_2_base_fee_msat,
    cp2.min_htlc_msat AS policy_2_min_htlc_msat,
    cp2.max_htlc_msat AS policy_2_max_htlc_msat,
    cp2.last_update AS policy_2_last_update,
    cp2.disabled AS policy_2_disabled,
    cp2.inbound_base_fee_msat AS policy2_inbound_base_fee_msat,
    cp2.inbound_fee_rate_milli_msat AS policy2_inbound_fee_rate_milli_msat,
    cp2.signature AS policy_2_signature
FROM channels c
    JOIN nodes n1 ON c.node_id_1 = n1.id
    JOIN nodes n2 ON c.node_id_2 = n2.id
    LEFT JOIN channel_policies cp1
        ON cp1.channel_id = c.id AND cp1.node_id = c.node_id_1 AND cp1.version = c.version
    LEFT JOIN channel_policies cp2
        ON cp2.channel_id = c.id AND cp2.node_id = c.node_id_2 AND cp2.version = c.version
WHERE c.outpoint = $1 AND c.version = $2
`

type GetChannelByOutpointWithPoliciesParams struct {
	Outpoint string
	Version  int16
}

type GetChannelByOutpointWithPoliciesRow struct {
	Channel                        Channel
	Node1Pubkey                    []byte
	Node2Pubkey                    []byte
	Policy1ID                      sql.NullInt64
	Policy1NodeID                  sql.NullInt64
	Policy1Version                 sql.NullInt16
	Policy1Timelock                sql.NullInt32
	Policy1FeePpm                  sql.NullInt64
	Policy1BaseFeeMsat             sql.NullInt64
	Policy1MinHtlcMsat             sql.NullInt64
	Policy1MaxHtlcMsat             sql.NullInt64
	Policy1LastUpdate              sql.NullInt64
	Policy1Disabled                sql.NullBool
	Policy1InboundBaseFeeMsat      sql.NullInt64
	Policy1InboundFeeRateMilliMsat sql.NullInt64
	Policy1Signature               []byte
	Policy2ID                      sql.NullInt64
	Policy2NodeID                  sql.NullInt64
	Policy2Version                 sql.NullInt16
	Policy2Timelock                sql.NullInt32
	Policy2FeePpm                  sql.NullInt64
	Policy2BaseFeeMsat             sql.NullInt64
	Policy2MinHtlcMsat             sql.NullInt64
	Policy2MaxHtlcMsat             sql.NullInt64
	Policy2LastUpdate              sql.NullInt64
	Policy2Disabled                sql.NullBool
	Policy2InboundBaseFeeMsat      sql.NullInt64
	Policy2InboundFeeRateMilliMsat sql.NullInt64
	Policy2Signature               []byte
}

func (q *Queries) GetChannelByOutpointWithPolicies(ctx context.Context, arg GetChannelByOutpointWithPoliciesParams) (GetChannelByOutpointWithPoliciesRow, error) {
	row := q.db.QueryRowContext(ctx, getChannelByOutpointWithPolicies, arg.Outpoint, arg.Version)
	var i GetChannelByOutpointWithPoliciesRow
	err := row.Scan(
		&i.Channel.ID,
		&i.Channel.Version,
		&i.Channel.Scid,
		&i.Channel.NodeID1,
		&i.Channel.NodeID2,
		&i.Channel.Outpoint,
		&i.Channel.Capacity,
		&i.Channel.BitcoinKey1,
		&i.Channel.BitcoinKey2,
		&i.Channel.Node1Signature,
		&i.Channel.Node2Signature,
		&i.Channel.Bitcoin1Signature,
		&i.Channel.Bitcoin2Signature,
		&i.Node1Pubkey,
		&i.Node2Pubkey,
		&i.Policy1ID,
		&i.Policy1NodeID,
		&i.Policy1Version,
		&i.Policy1Timelock,
		&i.Policy1FeePpm,
		&i.Policy1BaseFeeMsat,
		&i.Policy1MinHtlcMsat,
		&i.Policy1MaxHtlcMsat,
		&i.Policy1LastUpdate,
		&i.Policy1Disabled,
		&i.Policy1InboundBaseFeeMsat,
		&i.Policy1InboundFeeRateMilliMsat,
		&i.Policy1Signature,
		&i.Policy2ID,
		&i.Policy2NodeID,
		&i.Policy2Version,
		&i.Policy2Timelock,
		&i.Policy2FeePpm,
		&i.Policy2BaseFeeMsat,
		&i.Policy2MinHtlcMsat,
		&i.Policy2MaxHtlcMsat,
		&i.Policy2LastUpdate,
		&i.Policy2Disabled,
		&i.Policy2InboundBaseFeeMsat,
		&i.Policy2InboundFeeRateMilliMsat,
		&i.Policy2Signature,
	)
	return i, err
}

const getChannelBySCID = `-- name: GetChannelBySCID :one
SELECT id, version, scid, node_id_1, node_id_2, outpoint, capacity, bitcoin_key_1, bitcoin_key_2, node_1_signature, node_2_signature, bitcoin_1_signature, bitcoin_2_signature FROM channels
WHERE scid = $1 AND version = $2
`

type GetChannelBySCIDParams struct {
	Scid    []byte
	Version int16
}

func (q *Queries) GetChannelBySCID(ctx context.Context, arg GetChannelBySCIDParams) (Channel, error) {
	row := q.db.QueryRowContext(ctx, getChannelBySCID, arg.Scid, arg.Version)
	var i Channel
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.Scid,
		&i.NodeID1,
		&i.NodeID2,
		&i.Outpoint,
		&i.Capacity,
		&i.BitcoinKey1,
		&i.BitcoinKey2,
		&i.Node1Signature,
		&i.Node2Signature,
		&i.Bitcoin1Signature,
		&i.Bitcoin2Signature,
	)
	return i, err
}

const getChannelBySCIDWithPolicies = `-- name: GetChannelBySCIDWithPolicies :one
SELECT
    c.id, c.version, c.scid, c.node_id_1, c.node_id_2, c.outpoint, c.capacity, c.bitcoin_key_1, c.bitcoin_key_2, c.node_1_signature, c.node_2_signature, c.bitcoin_1_signature, c.bitcoin_2_signature,
    n1.id, n1.version, n1.pub_key, n1.alias, n1.last_update, n1.color, n1.signature,
    n2.id, n2.version, n2.pub_key, n2.alias, n2.last_update, n2.color, n2.signature,

    -- Policy 1
    cp1.id AS policy1_id,
    cp1.node_id AS policy1_node_id,
    cp1.version AS policy1_version,
    cp1.timelock AS policy1_timelock,
    cp1.fee_ppm AS policy1_fee_ppm,
    cp1.base_fee_msat AS policy1_base_fee_msat,
    cp1.min_htlc_msat AS policy1_min_htlc_msat,
    cp1.max_htlc_msat AS policy1_max_htlc_msat,
    cp1.last_update AS policy1_last_update,
    cp1.disabled AS policy1_disabled,
    cp1.inbound_base_fee_msat AS policy1_inbound_base_fee_msat,
    cp1.inbound_fee_rate_milli_msat AS policy1_inbound_fee_rate_milli_msat,
    cp1.signature AS policy1_signature,

    -- Policy 2
    cp2.id AS policy2_id,
    cp2.node_id AS policy2_node_id,
    cp2.version AS policy2_version,
    cp2.timelock AS policy2_timelock,
    cp2.fee_ppm AS policy2_fee_ppm,
    cp2.base_fee_msat AS policy2_base_fee_msat,
    cp2.min_htlc_msat AS policy2_min_htlc_msat,
    cp2.max_htlc_msat AS policy2_max_htlc_msat,
    cp2.last_update AS policy2_last_update,
    cp2.disabled AS policy2_disabled,
    cp2.inbound_base_fee_msat AS policy2_inbound_base_fee_msat,
    cp2.inbound_fee_rate_milli_msat AS policy2_inbound_fee_rate_milli_msat,
    cp2.signature AS policy2_signature

FROM channels c
    JOIN nodes n1 ON c.node_id_1 = n1.id
    JOIN nodes n2 ON c.node_id_2 = n2.id
    LEFT JOIN channel_policies cp1
        ON cp1.channel_id = c.id AND cp1.node_id = c.node_id_1 AND cp1.version = c.version
    LEFT JOIN channel_policies cp2
        ON cp2.channel_id = c.id AND cp2.node_id = c.node_id_2 AND cp2.version = c.version
WHERE c.scid = $1
  AND c.version = $2
`

type GetChannelBySCIDWithPoliciesParams struct {
	Scid    []byte
	Version int16
}

type GetChannelBySCIDWithPoliciesRow struct {
	Channel                        Channel
	Node                           Node
	Node_2                         Node
	Policy1ID                      sql.NullInt64
	Policy1NodeID                  sql.NullInt64
	Policy1Version                 sql.NullInt16
	Policy1Timelock                sql.NullInt32
	Policy1FeePpm                  sql.NullInt64
	Policy1BaseFeeMsat             sql.NullInt64
	Policy1MinHtlcMsat             sql.NullInt64
	Policy1MaxHtlcMsat             sql.NullInt64
	Policy1LastUpdate              sql.NullInt64
	Policy1Disabled                sql.NullBool
	Policy1InboundBaseFeeMsat      sql.NullInt64
	Policy1InboundFeeRateMilliMsat sql.NullInt64
	Policy1Signature               []byte
	Policy2ID                      sql.NullInt64
	Policy2NodeID                  sql.NullInt64
	Policy2Version                 sql.NullInt16
	Policy2Timelock                sql.NullInt32
	Policy2FeePpm                  sql.NullInt64
	Policy2BaseFeeMsat             sql.NullInt64
	Policy2MinHtlcMsat             sql.NullInt64
	Policy2MaxHtlcMsat             sql.NullInt64
	Policy2LastUpdate              sql.NullInt64
	Policy2Disabled                sql.NullBool
	Policy2InboundBaseFeeMsat      sql.NullInt64
	Policy2InboundFeeRateMilliMsat sql.NullInt64
	Policy2Signature               []byte
}

func (q *Queries) GetChannelBySCIDWithPolicies(ctx context.Context, arg GetChannelBySCIDWithPoliciesParams) (GetChannelBySCIDWithPoliciesRow, error) {
	row := q.db.QueryRowContext(ctx, getChannelBySCIDWithPolicies, arg.Scid, arg.Version)
	var i GetChannelBySCIDWithPoliciesRow
	err := row.Scan(
		&i.Channel.ID,
		&i.Channel.Version,
		&i.Channel.Scid,
		&i.Channel.NodeID1,
		&i.Channel.NodeID2,
		&i.Channel.Outpoint,
		&i.Channel.Capacity,
		&i.Channel.BitcoinKey1,
		&i.Channel.BitcoinKey2,
		&i.Channel.Node1Signature,
		&i.Channel.Node2Signature,
		&i.Channel.Bitcoin1Signature,
		&i.Channel.Bitcoin2Signature,
		&i.Node.ID,
		&i.Node.Version,
		&i.Node.PubKey,
		&i.Node.Alias,
		&i.Node.LastUpdate,
		&i.Node.Color,
		&i.Node.Signature,
		&i.Node_2.ID,
		&i.Node_2.Version,
		&i.Node_2.PubKey,
		&i.Node_2.Alias,
		&i.Node_2.LastUpdate,
		&i.Node_2.Color,
		&i.Node_2.Signature,
		&i.Policy1ID,
		&i.Policy1NodeID,
		&i.Policy1Version,
		&i.Policy1Timelock,
		&i.Policy1FeePpm,
		&i.Policy1BaseFeeMsat,
		&i.Policy1MinHtlcMsat,
		&i.Policy1MaxHtlcMsat,
		&i.Policy1LastUpdate,
		&i.Policy1Disabled,
		&i.Policy1InboundBaseFeeMsat,
		&i.Policy1InboundFeeRateMilliMsat,
		&i.Policy1Signature,
		&i.Policy2ID,
		&i.Policy2NodeID,
		&i.Policy2Version,
		&i.Policy2Timelock,
		&i.Policy2FeePpm,
		&i.Policy2BaseFeeMsat,
		&i.Policy2MinHtlcMsat,
		&i.Policy2MaxHtlcMsat,
		&i.Policy2LastUpdate,
		&i.Policy2Disabled,
		&i.Policy2InboundBaseFeeMsat,
		&i.Policy2InboundFeeRateMilliMsat,
		&i.Policy2Signature,
	)
	return i, err
}

const getChannelFeaturesAndExtras = `-- name: GetChannelFeaturesAndExtras :many
SELECT
    cf.channel_id,
    true AS is_feature,
    cf.feature_bit AS feature_bit,
    NULL AS extra_key,
    NULL AS value
FROM channel_features cf
WHERE cf.channel_id = $1

UNION ALL

SELECT
    cet.channel_id,
    false AS is_feature,
    0 AS feature_bit,
    cet.type AS extra_key,
    cet.value AS value
FROM channel_extra_types cet
WHERE cet.channel_id = $1
`

type GetChannelFeaturesAndExtrasRow struct {
	ChannelID  int64
	IsFeature  bool
	FeatureBit int32
	ExtraKey   interface{}
	Value      interface{}
}

func (q *Queries) GetChannelFeaturesAndExtras(ctx context.Context, channelID int64) ([]GetChannelFeaturesAndExtrasRow, error) {
	rows, err := q.db.QueryContext(ctx, getChannelFeaturesAndExtras, channelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChannelFeaturesAndExtrasRow
	for rows.Next() {
		var i GetChannelFeaturesAndExtrasRow
		if err := rows.Scan(
			&i.ChannelID,
			&i.IsFeature,
			&i.FeatureBit,
			&i.ExtraKey,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChannelPolicyByChannelAndNode = `-- name: GetChannelPolicyByChannelAndNode :one
SELECT id, version, channel_id, node_id, timelock, fee_ppm, base_fee_msat, min_htlc_msat, max_htlc_msat, last_update, disabled, inbound_base_fee_msat, inbound_fee_rate_milli_msat, signature
FROM channel_policies
WHERE channel_id = $1
  AND node_id = $2
  AND version = $3
`

type GetChannelPolicyByChannelAndNodeParams struct {
	ChannelID int64
	NodeID    int64
	Version   int16
}

func (q *Queries) GetChannelPolicyByChannelAndNode(ctx context.Context, arg GetChannelPolicyByChannelAndNodeParams) (ChannelPolicy, error) {
	row := q.db.QueryRowContext(ctx, getChannelPolicyByChannelAndNode, arg.ChannelID, arg.NodeID, arg.Version)
	var i ChannelPolicy
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ChannelID,
		&i.NodeID,
		&i.Timelock,
		&i.FeePpm,
		&i.BaseFeeMsat,
		&i.MinHtlcMsat,
		&i.MaxHtlcMsat,
		&i.LastUpdate,
		&i.Disabled,
		&i.InboundBaseFeeMsat,
		&i.InboundFeeRateMilliMsat,
		&i.Signature,
	)
	return i, err
}

const getChannelPolicyExtraTypes = `-- name: GetChannelPolicyExtraTypes :many
SELECT
    cp.id AS policy_id,
    cp.channel_id,
    cp.node_id,
    cpet.type,
    cpet.value
FROM channel_policies cp
JOIN channel_policy_extra_types cpet
ON cp.id = cpet.channel_policy_id
WHERE cp.id = $1 OR cp.id = $2
`

type GetChannelPolicyExtraTypesParams struct {
	ID   int64
	ID_2 int64
}

type GetChannelPolicyExtraTypesRow struct {
	PolicyID  int64
	ChannelID int64
	NodeID    int64
	Type      int64
	Value     []byte
}

func (q *Queries) GetChannelPolicyExtraTypes(ctx context.Context, arg GetChannelPolicyExtraTypesParams) ([]GetChannelPolicyExtraTypesRow, error) {
	rows, err := q.db.QueryContext(ctx, getChannelPolicyExtraTypes, arg.ID, arg.ID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChannelPolicyExtraTypesRow
	for rows.Next() {
		var i GetChannelPolicyExtraTypesRow
		if err := rows.Scan(
			&i.PolicyID,
			&i.ChannelID,
			&i.NodeID,
			&i.Type,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChannelsByPolicyLastUpdateRange = `-- name: GetChannelsByPolicyLastUpdateRange :many
SELECT
    c.id, c.version, c.scid, c.node_id_1, c.node_id_2, c.outpoint, c.capacity, c.bitcoin_key_1, c.bitcoin_key_2, c.node_1_signature, c.node_2_signature, c.bitcoin_1_signature, c.bitcoin_2_signature,
    n1.id, n1.version, n1.pub_key, n1.alias, n1.last_update, n1.color, n1.signature,
    n2.id, n2.version, n2.pub_key, n2.alias, n2.last_update, n2.color, n2.signature,

    -- Policy 1 (node_id_1)
    cp1.id AS policy1_id,
    cp1.node_id AS policy1_node_id,
    cp1.version AS policy1_version,
    cp1.timelock AS policy1_timelock,
    cp1.fee_ppm AS policy1_fee_ppm,
    cp1.base_fee_msat AS policy1_base_fee_msat,
    cp1.min_htlc_msat AS policy1_min_htlc_msat,
    cp1.max_htlc_msat AS policy1_max_htlc_msat,
    cp1.last_update AS policy1_last_update,
    cp1.disabled AS policy1_disabled,
    cp1.inbound_base_fee_msat AS policy1_inbound_base_fee_msat,
    cp1.inbound_fee_rate_milli_msat AS policy1_inbound_fee_rate_milli_msat,
    cp1.signature AS policy1_signature,

    -- Policy 2 (node_id_2)
    cp2.id AS policy2_id,
    cp2.node_id AS policy2_node_id,
    cp2.version AS policy2_version,
    cp2.timelock AS policy2_timelock,
    cp2.fee_ppm AS policy2_fee_ppm,
    cp2.base_fee_msat AS policy2_base_fee_msat,
    cp2.min_htlc_msat AS policy2_min_htlc_msat,
    cp2.max_htlc_msat AS policy2_max_htlc_msat,
    cp2.last_update AS policy2_last_update,
    cp2.disabled AS policy2_disabled,
    cp2.inbound_base_fee_msat AS policy2_inbound_base_fee_msat,
    cp2.inbound_fee_rate_milli_msat AS policy2_inbound_fee_rate_milli_msat,
    cp2.signature AS policy2_signature

FROM channels c
    JOIN nodes n1 ON c.node_id_1 = n1.id
    JOIN nodes n2 ON c.node_id_2 = n2.id
    LEFT JOIN channel_policies cp1
        ON cp1.channel_id = c.id AND cp1.node_id = c.node_id_1 AND cp1.version = c.version
    LEFT JOIN channel_policies cp2
        ON cp2.channel_id = c.id AND cp2.node_id = c.node_id_2 AND cp2.version = c.version
WHERE c.version = $1
  AND (
       (cp1.last_update >= $2 AND cp1.last_update < $3)
       OR
       (cp2.last_update >= $2 AND cp2.last_update < $3)
  )
ORDER BY
    CASE
        WHEN COALESCE(cp1.last_update, 0) >= COALESCE(cp2.last_update, 0)
            THEN COALESCE(cp1.last_update, 0)
        ELSE COALESCE(cp2.last_update, 0)
        END ASC
`

type GetChannelsByPolicyLastUpdateRangeParams struct {
	Version   int16
	StartTime sql.NullInt64
	EndTime   sql.NullInt64
}

type GetChannelsByPolicyLastUpdateRangeRow struct {
	Channel                        Channel
	Node                           Node
	Node_2                         Node
	Policy1ID                      sql.NullInt64
	Policy1NodeID                  sql.NullInt64
	Policy1Version                 sql.NullInt16
	Policy1Timelock                sql.NullInt32
	Policy1FeePpm                  sql.NullInt64
	Policy1BaseFeeMsat             sql.NullInt64
	Policy1MinHtlcMsat             sql.NullInt64
	Policy1MaxHtlcMsat             sql.NullInt64
	Policy1LastUpdate              sql.NullInt64
	Policy1Disabled                sql.NullBool
	Policy1InboundBaseFeeMsat      sql.NullInt64
	Policy1InboundFeeRateMilliMsat sql.NullInt64
	Policy1Signature               []byte
	Policy2ID                      sql.NullInt64
	Policy2NodeID                  sql.NullInt64
	Policy2Version                 sql.NullInt16
	Policy2Timelock                sql.NullInt32
	Policy2FeePpm                  sql.NullInt64
	Policy2BaseFeeMsat             sql.NullInt64
	Policy2MinHtlcMsat             sql.NullInt64
	Policy2MaxHtlcMsat             sql.NullInt64
	Policy2LastUpdate              sql.NullInt64
	Policy2Disabled                sql.NullBool
	Policy2InboundBaseFeeMsat      sql.NullInt64
	Policy2InboundFeeRateMilliMsat sql.NullInt64
	Policy2Signature               []byte
}

func (q *Queries) GetChannelsByPolicyLastUpdateRange(ctx context.Context, arg GetChannelsByPolicyLastUpdateRangeParams) ([]GetChannelsByPolicyLastUpdateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getChannelsByPolicyLastUpdateRange, arg.Version, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChannelsByPolicyLastUpdateRangeRow
	for rows.Next() {
		var i GetChannelsByPolicyLastUpdateRangeRow
		if err := rows.Scan(
			&i.Channel.ID,
			&i.Channel.Version,
			&i.Channel.Scid,
			&i.Channel.NodeID1,
			&i.Channel.NodeID2,
			&i.Channel.Outpoint,
			&i.Channel.Capacity,
			&i.Channel.BitcoinKey1,
			&i.Channel.BitcoinKey2,
			&i.Channel.Node1Signature,
			&i.Channel.Node2Signature,
			&i.Channel.Bitcoin1Signature,
			&i.Channel.Bitcoin2Signature,
			&i.Node.ID,
			&i.Node.Version,
			&i.Node.PubKey,
			&i.Node.Alias,
			&i.Node.LastUpdate,
			&i.Node.Color,
			&i.Node.Signature,
			&i.Node_2.ID,
			&i.Node_2.Version,
			&i.Node_2.PubKey,
			&i.Node_2.Alias,
			&i.Node_2.LastUpdate,
			&i.Node_2.Color,
			&i.Node_2.Signature,
			&i.Policy1ID,
			&i.Policy1NodeID,
			&i.Policy1Version,
			&i.Policy1Timelock,
			&i.Policy1FeePpm,
			&i.Policy1BaseFeeMsat,
			&i.Policy1MinHtlcMsat,
			&i.Policy1MaxHtlcMsat,
			&i.Policy1LastUpdate,
			&i.Policy1Disabled,
			&i.Policy1InboundBaseFeeMsat,
			&i.Policy1InboundFeeRateMilliMsat,
			&i.Policy1Signature,
			&i.Policy2ID,
			&i.Policy2NodeID,
			&i.Policy2Version,
			&i.Policy2Timelock,
			&i.Policy2FeePpm,
			&i.Policy2BaseFeeMsat,
			&i.Policy2MinHtlcMsat,
			&i.Policy2MaxHtlcMsat,
			&i.Policy2LastUpdate,
			&i.Policy2Disabled,
			&i.Policy2InboundBaseFeeMsat,
			&i.Policy2InboundFeeRateMilliMsat,
			&i.Policy2Signature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChannelsBySCIDRange = `-- name: GetChannelsBySCIDRange :many
SELECT c.id, c.version, c.scid, c.node_id_1, c.node_id_2, c.outpoint, c.capacity, c.bitcoin_key_1, c.bitcoin_key_2, c.node_1_signature, c.node_2_signature, c.bitcoin_1_signature, c.bitcoin_2_signature,
    n1.pub_key AS node1_pub_key,
    n2.pub_key AS node2_pub_key
FROM channels c
    JOIN nodes n1 ON c.node_id_1 = n1.id
    JOIN nodes n2 ON c.node_id_2 = n2.id
WHERE scid >= $1
  AND scid < $2
`

type GetChannelsBySCIDRangeParams struct {
	StartScid []byte
	EndScid   []byte
}

type GetChannelsBySCIDRangeRow struct {
	Channel     Channel
	Node1PubKey []byte
	Node2PubKey []byte
}

func (q *Queries) GetChannelsBySCIDRange(ctx context.Context, arg GetChannelsBySCIDRangeParams) ([]GetChannelsBySCIDRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getChannelsBySCIDRange, arg.StartScid, arg.EndScid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChannelsBySCIDRangeRow
	for rows.Next() {
		var i GetChannelsBySCIDRangeRow
		if err := rows.Scan(
			&i.Channel.ID,
			&i.Channel.Version,
			&i.Channel.Scid,
			&i.Channel.NodeID1,
			&i.Channel.NodeID2,
			&i.Channel.Outpoint,
			&i.Channel.Capacity,
			&i.Channel.BitcoinKey1,
			&i.Channel.BitcoinKey2,
			&i.Channel.Node1Signature,
			&i.Channel.Node2Signature,
			&i.Channel.Bitcoin1Signature,
			&i.Channel.Bitcoin2Signature,
			&i.Node1PubKey,
			&i.Node2PubKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExtraNodeTypes = `-- name: GetExtraNodeTypes :many
SELECT node_id, type, value
FROM node_extra_types
WHERE node_id = $1
`

func (q *Queries) GetExtraNodeTypes(ctx context.Context, nodeID int64) ([]NodeExtraType, error) {
	rows, err := q.db.QueryContext(ctx, getExtraNodeTypes, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NodeExtraType
	for rows.Next() {
		var i NodeExtraType
		if err := rows.Scan(&i.NodeID, &i.Type, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeAddressesByPubKey = `-- name: GetNodeAddressesByPubKey :many
SELECT a.type, a.address
FROM nodes n
LEFT JOIN node_addresses a ON a.node_id = n.id
WHERE n.pub_key = $1 AND n.version = $2
ORDER BY a.type ASC, a.position ASC
`

type GetNodeAddressesByPubKeyParams struct {
	PubKey  []byte
	Version int16
}

type GetNodeAddressesByPubKeyRow struct {
	Type    sql.NullInt16
	Address sql.NullString
}

func (q *Queries) GetNodeAddressesByPubKey(ctx context.Context, arg GetNodeAddressesByPubKeyParams) ([]GetNodeAddressesByPubKeyRow, error) {
	rows, err := q.db.QueryContext(ctx, getNodeAddressesByPubKey, arg.PubKey, arg.Version)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNodeAddressesByPubKeyRow
	for rows.Next() {
		var i GetNodeAddressesByPubKeyRow
		if err := rows.Scan(&i.Type, &i.Address); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeByPubKey = `-- name: GetNodeByPubKey :one
SELECT id, version, pub_key, alias, last_update, color, signature
FROM nodes
WHERE pub_key = $1
  AND version = $2
`

type GetNodeByPubKeyParams struct {
	PubKey  []byte
	Version int16
}

func (q *Queries) GetNodeByPubKey(ctx context.Context, arg GetNodeByPubKeyParams) (Node, error) {
	row := q.db.QueryRowContext(ctx, getNodeByPubKey, arg.PubKey, arg.Version)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.PubKey,
		&i.Alias,
		&i.LastUpdate,
		&i.Color,
		&i.Signature,
	)
	return i, err
}

const getNodeFeatures = `-- name: GetNodeFeatures :many
SELECT node_id, feature_bit
FROM node_features
WHERE node_id = $1
`

func (q *Queries) GetNodeFeatures(ctx context.Context, nodeID int64) ([]NodeFeature, error) {
	rows, err := q.db.QueryContext(ctx, getNodeFeatures, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NodeFeature
	for rows.Next() {
		var i NodeFeature
		if err := rows.Scan(&i.NodeID, &i.FeatureBit); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeFeaturesByPubKey = `-- name: GetNodeFeaturesByPubKey :many
SELECT f.feature_bit
FROM nodes n
    JOIN node_features f ON f.node_id = n.id
WHERE n.pub_key = $1
  AND n.version = $2
`

type GetNodeFeaturesByPubKeyParams struct {
	PubKey  []byte
	Version int16
}

func (q *Queries) GetNodeFeaturesByPubKey(ctx context.Context, arg GetNodeFeaturesByPubKeyParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getNodeFeaturesByPubKey, arg.PubKey, arg.Version)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var feature_bit int32
		if err := rows.Scan(&feature_bit); err != nil {
			return nil, err
		}
		items = append(items, feature_bit)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeIDByPubKey = `-- name: GetNodeIDByPubKey :one
SELECT id
FROM nodes
WHERE pub_key = $1
  AND version = $2
`

type GetNodeIDByPubKeyParams struct {
	PubKey  []byte
	Version int16
}

func (q *Queries) GetNodeIDByPubKey(ctx context.Context, arg GetNodeIDByPubKeyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNodeIDByPubKey, arg.PubKey, arg.Version)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getNodesByLastUpdateRange = `-- name: GetNodesByLastUpdateRange :many
SELECT id, version, pub_key, alias, last_update, color, signature
FROM nodes
WHERE last_update >= $1
  AND last_update < $2
`

type GetNodesByLastUpdateRangeParams struct {
	StartTime sql.NullInt64
	EndTime   sql.NullInt64
}

func (q *Queries) GetNodesByLastUpdateRange(ctx context.Context, arg GetNodesByLastUpdateRangeParams) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getNodesByLastUpdateRange, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Node
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.PubKey,
			&i.Alias,
			&i.LastUpdate,
			&i.Color,
			&i.Signature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPruneTip = `-- name: GetPruneTip :one
SELECT block_height, block_hash
FROM prune_log
ORDER BY block_height DESC
LIMIT 1
`

func (q *Queries) GetPruneTip(ctx context.Context) (PruneLog, error) {
	row := q.db.QueryRowContext(ctx, getPruneTip)
	var i PruneLog
	err := row.Scan(&i.BlockHeight, &i.BlockHash)
	return i, err
}

const getPublicV1ChannelsBySCID = `-- name: GetPublicV1ChannelsBySCID :many
SELECT id, version, scid, node_id_1, node_id_2, outpoint, capacity, bitcoin_key_1, bitcoin_key_2, node_1_signature, node_2_signature, bitcoin_1_signature, bitcoin_2_signature
FROM channels
WHERE node_1_signature IS NOT NULL
  AND scid >= $1
  AND scid < $2
`

type GetPublicV1ChannelsBySCIDParams struct {
	StartScid []byte
	EndScid   []byte
}

func (q *Queries) GetPublicV1ChannelsBySCID(ctx context.Context, arg GetPublicV1ChannelsBySCIDParams) ([]Channel, error) {
	rows, err := q.db.QueryContext(ctx, getPublicV1ChannelsBySCID, arg.StartScid, arg.EndScid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Channel
	for rows.Next() {
		var i Channel
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Scid,
			&i.NodeID1,
			&i.NodeID2,
			&i.Outpoint,
			&i.Capacity,
			&i.BitcoinKey1,
			&i.BitcoinKey2,
			&i.Node1Signature,
			&i.Node2Signature,
			&i.Bitcoin1Signature,
			&i.Bitcoin2Signature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSCIDByOutpoint = `-- name: GetSCIDByOutpoint :one
SELECT scid from channels
WHERE outpoint = $1 AND version = $2
`

type GetSCIDByOutpointParams struct {
	Outpoint string
	Version  int16
}

func (q *Queries) GetSCIDByOutpoint(ctx context.Context, arg GetSCIDByOutpointParams) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, getSCIDByOutpoint, arg.Outpoint, arg.Version)
	var scid []byte
	err := row.Scan(&scid)
	return scid, err
}

const getSourceNodesByVersion = `-- name: GetSourceNodesByVersion :many
SELECT sn.node_id, n.pub_key
FROM source_nodes sn
    JOIN nodes n ON sn.node_id = n.id
WHERE n.version = $1
`

type GetSourceNodesByVersionRow struct {
	NodeID int64
	PubKey []byte
}

func (q *Queries) GetSourceNodesByVersion(ctx context.Context, version int16) ([]GetSourceNodesByVersionRow, error) {
	rows, err := q.db.QueryContext(ctx, getSourceNodesByVersion, version)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSourceNodesByVersionRow
	for rows.Next() {
		var i GetSourceNodesByVersionRow
		if err := rows.Scan(&i.NodeID, &i.PubKey); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getV1DisabledSCIDs = `-- name: GetV1DisabledSCIDs :many
SELECT c.scid
FROM channels c
    JOIN channel_policies cp ON cp.channel_id = c.id
WHERE cp.disabled = true
AND c.version = 1
GROUP BY c.scid
HAVING COUNT(*) > 1
`

// NOTE: this is V1 specific since for V1, disabled is a
// simple, single boolean. The proposed V2 policy
// structure will have a more complex disabled bit vector
// and so the query for V2 may differ.
func (q *Queries) GetV1DisabledSCIDs(ctx context.Context) ([][]byte, error) {
	rows, err := q.db.QueryContext(ctx, getV1DisabledSCIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var scid []byte
		if err := rows.Scan(&scid); err != nil {
			return nil, err
		}
		items = append(items, scid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZombieChannel = `-- name: GetZombieChannel :one
SELECT scid, version, node_key_1, node_key_2
FROM zombie_channels
WHERE scid = $1
AND version = $2
`

type GetZombieChannelParams struct {
	Scid    []byte
	Version int16
}

func (q *Queries) GetZombieChannel(ctx context.Context, arg GetZombieChannelParams) (ZombieChannel, error) {
	row := q.db.QueryRowContext(ctx, getZombieChannel, arg.Scid, arg.Version)
	var i ZombieChannel
	err := row.Scan(
		&i.Scid,
		&i.Version,
		&i.NodeKey1,
		&i.NodeKey2,
	)
	return i, err
}

const highestSCID = `-- name: HighestSCID :one
SELECT scid
FROM channels
WHERE version = $1
ORDER BY scid DESC
LIMIT 1
`

func (q *Queries) HighestSCID(ctx context.Context, version int16) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, highestSCID, version)
	var scid []byte
	err := row.Scan(&scid)
	return scid, err
}

const insertChanPolicyExtraType = `-- name: InsertChanPolicyExtraType :exec
/* ─────────────────────────────────────────────
   channel_policy_extra_types table queries
   ─────────────────────────────────────────────
*/

INSERT INTO channel_policy_extra_types (
    channel_policy_id, type, value
)
VALUES ($1, $2, $3)
`

type InsertChanPolicyExtraTypeParams struct {
	ChannelPolicyID int64
	Type            int64
	Value           []byte
}

func (q *Queries) InsertChanPolicyExtraType(ctx context.Context, arg InsertChanPolicyExtraTypeParams) error {
	_, err := q.db.ExecContext(ctx, insertChanPolicyExtraType, arg.ChannelPolicyID, arg.Type, arg.Value)
	return err
}

const insertChannelFeature = `-- name: InsertChannelFeature :exec
/* ─────────────────────────────────────────────
   channel_features table queries
   ─────────────────────────────────────────────
*/

INSERT INTO channel_features (
    channel_id, feature_bit
) VALUES (
    $1, $2
)
`

type InsertChannelFeatureParams struct {
	ChannelID  int64
	FeatureBit int32
}

func (q *Queries) InsertChannelFeature(ctx context.Context, arg InsertChannelFeatureParams) error {
	_, err := q.db.ExecContext(ctx, insertChannelFeature, arg.ChannelID, arg.FeatureBit)
	return err
}

const insertClosedChannel = `-- name: InsertClosedChannel :exec
/* ─────────────────────────────────────────────
   closed_scid table queries
   ────────────────────────────────────────────-
*/

INSERT INTO closed_scids (scid)
VALUES ($1)
ON CONFLICT (scid) DO NOTHING
`

func (q *Queries) InsertClosedChannel(ctx context.Context, scid []byte) error {
	_, err := q.db.ExecContext(ctx, insertClosedChannel, scid)
	return err
}

const insertNodeAddress = `-- name: InsertNodeAddress :exec
/* ─────────────────────────────────────────────
   node_addresses table queries
   ─────────────────────────────────────────────
*/

INSERT INTO node_addresses (
    node_id,
    type,
    address,
    position
) VALUES (
    $1, $2, $3, $4
 )
`

type InsertNodeAddressParams struct {
	NodeID   int64
	Type     int16
	Address  string
	Position int32
}

func (q *Queries) InsertNodeAddress(ctx context.Context, arg InsertNodeAddressParams) error {
	_, err := q.db.ExecContext(ctx, insertNodeAddress,
		arg.NodeID,
		arg.Type,
		arg.Address,
		arg.Position,
	)
	return err
}

const insertNodeFeature = `-- name: InsertNodeFeature :exec
/* ─────────────────────────────────────────────
   node_features table queries
   ─────────────────────────────────────────────
*/

INSERT INTO node_features (
    node_id, feature_bit
) VALUES (
    $1, $2
)
`

type InsertNodeFeatureParams struct {
	NodeID     int64
	FeatureBit int32
}

func (q *Queries) InsertNodeFeature(ctx context.Context, arg InsertNodeFeatureParams) error {
	_, err := q.db.ExecContext(ctx, insertNodeFeature, arg.NodeID, arg.FeatureBit)
	return err
}

const isClosedChannel = `-- name: IsClosedChannel :one
SELECT EXISTS (
    SELECT 1
    FROM closed_scids
    WHERE scid = $1
)
`

func (q *Queries) IsClosedChannel(ctx context.Context, scid []byte) (bool, error) {
	row := q.db.QueryRowContext(ctx, isClosedChannel, scid)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isPublicV1Node = `-- name: IsPublicV1Node :one
SELECT EXISTS (
    SELECT 1
    FROM channels c
    JOIN nodes n ON n.id = c.node_id_1 OR n.id = c.node_id_2
    -- NOTE: we hard-code the version here since the clauses
    -- here that determine if a node is public is specific
    -- to the V1 gossip protocol. In V1, a node is public
    -- if it has a public channel and a public channel is one
    -- where we have the set of signatures of the channel
    -- announcement. It is enough to just check that we have
    -- one of the signatures since we only ever set them
    -- together.
    WHERE c.version = 1
      AND c.bitcoin_1_signature IS NOT NULL
      AND n.pub_key = $1
)
`

func (q *Queries) IsPublicV1Node(ctx context.Context, pubKey []byte) (bool, error) {
	row := q.db.QueryRowContext(ctx, isPublicV1Node, pubKey)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isZombieChannel = `-- name: IsZombieChannel :one
SELECT EXISTS (
    SELECT 1
    FROM zombie_channels
    WHERE scid = $1
    AND version = $2
) AS is_zombie
`

type IsZombieChannelParams struct {
	Scid    []byte
	Version int16
}

func (q *Queries) IsZombieChannel(ctx context.Context, arg IsZombieChannelParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isZombieChannel, arg.Scid, arg.Version)
	var is_zombie bool
	err := row.Scan(&is_zombie)
	return is_zombie, err
}

const listChannelsByNodeID = `-- name: ListChannelsByNodeID :many
SELECT c.id, c.version, c.scid, c.node_id_1, c.node_id_2, c.outpoint, c.capacity, c.bitcoin_key_1, c.bitcoin_key_2, c.node_1_signature, c.node_2_signature, c.bitcoin_1_signature, c.bitcoin_2_signature,
    n1.pub_key AS node1_pubkey,
    n2.pub_key AS node2_pubkey,

    -- Policy 1
    -- TODO(elle): use sqlc.embed to embed policy structs
    --  once this issue is resolved:
    --  https://github.com/sqlc-dev/sqlc/issues/2997
    cp1.id AS policy1_id,
    cp1.node_id AS policy1_node_id,
    cp1.version AS policy1_version,
    cp1.timelock AS policy1_timelock,
    cp1.fee_ppm AS policy1_fee_ppm,
    cp1.base_fee_msat AS policy1_base_fee_msat,
    cp1.min_htlc_msat AS policy1_min_htlc_msat,
    cp1.max_htlc_msat AS policy1_max_htlc_msat,
    cp1.last_update AS policy1_last_update,
    cp1.disabled AS policy1_disabled,
    cp1.inbound_base_fee_msat AS policy1_inbound_base_fee_msat,
    cp1.inbound_fee_rate_milli_msat AS policy1_inbound_fee_rate_milli_msat,
    cp1.signature AS policy1_signature,

       -- Policy 2
    cp2.id AS policy2_id,
    cp2.node_id AS policy2_node_id,
    cp2.version AS policy2_version,
    cp2.timelock AS policy2_timelock,
    cp2.fee_ppm AS policy2_fee_ppm,
    cp2.base_fee_msat AS policy2_base_fee_msat,
    cp2.min_htlc_msat AS policy2_min_htlc_msat,
    cp2.max_htlc_msat AS policy2_max_htlc_msat,
    cp2.last_update AS policy2_last_update,
    cp2.disabled AS policy2_disabled,
    cp2.inbound_base_fee_msat AS policy2_inbound_base_fee_msat,
    cp2.inbound_fee_rate_milli_msat AS policy2_inbound_fee_rate_milli_msat,
    cp2.signature AS policy2_signature

FROM channels c
    JOIN nodes n1 ON c.node_id_1 = n1.id
    JOIN nodes n2 ON c.node_id_2 = n2.id
    LEFT JOIN channel_policies cp1
    ON cp1.channel_id = c.id AND cp1.node_id = c.node_id_1 AND cp1.version = c.version
    LEFT JOIN channel_policies cp2
    ON cp2.channel_id = c.id AND cp2.node_id = c.node_id_2 AND cp2.version = c.version
WHERE c.version = $1
  AND (c.node_id_1 = $2 OR c.node_id_2 = $2)
`

type ListChannelsByNodeIDParams struct {
	Version int16
	NodeID1 int64
}

type ListChannelsByNodeIDRow struct {
	Channel                        Channel
	Node1Pubkey                    []byte
	Node2Pubkey                    []byte
	Policy1ID                      sql.NullInt64
	Policy1NodeID                  sql.NullInt64
	Policy1Version                 sql.NullInt16
	Policy1Timelock                sql.NullInt32
	Policy1FeePpm                  sql.NullInt64
	Policy1BaseFeeMsat             sql.NullInt64
	Policy1MinHtlcMsat             sql.NullInt64
	Policy1MaxHtlcMsat             sql.NullInt64
	Policy1LastUpdate              sql.NullInt64
	Policy1Disabled                sql.NullBool
	Policy1InboundBaseFeeMsat      sql.NullInt64
	Policy1InboundFeeRateMilliMsat sql.NullInt64
	Policy1Signature               []byte
	Policy2ID                      sql.NullInt64
	Policy2NodeID                  sql.NullInt64
	Policy2Version                 sql.NullInt16
	Policy2Timelock                sql.NullInt32
	Policy2FeePpm                  sql.NullInt64
	Policy2BaseFeeMsat             sql.NullInt64
	Policy2MinHtlcMsat             sql.NullInt64
	Policy2MaxHtlcMsat             sql.NullInt64
	Policy2LastUpdate              sql.NullInt64
	Policy2Disabled                sql.NullBool
	Policy2InboundBaseFeeMsat      sql.NullInt64
	Policy2InboundFeeRateMilliMsat sql.NullInt64
	Policy2Signature               []byte
}

func (q *Queries) ListChannelsByNodeID(ctx context.Context, arg ListChannelsByNodeIDParams) ([]ListChannelsByNodeIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listChannelsByNodeID, arg.Version, arg.NodeID1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChannelsByNodeIDRow
	for rows.Next() {
		var i ListChannelsByNodeIDRow
		if err := rows.Scan(
			&i.Channel.ID,
			&i.Channel.Version,
			&i.Channel.Scid,
			&i.Channel.NodeID1,
			&i.Channel.NodeID2,
			&i.Channel.Outpoint,
			&i.Channel.Capacity,
			&i.Channel.BitcoinKey1,
			&i.Channel.BitcoinKey2,
			&i.Channel.Node1Signature,
			&i.Channel.Node2Signature,
			&i.Channel.Bitcoin1Signature,
			&i.Channel.Bitcoin2Signature,
			&i.Node1Pubkey,
			&i.Node2Pubkey,
			&i.Policy1ID,
			&i.Policy1NodeID,
			&i.Policy1Version,
			&i.Policy1Timelock,
			&i.Policy1FeePpm,
			&i.Policy1BaseFeeMsat,
			&i.Policy1MinHtlcMsat,
			&i.Policy1MaxHtlcMsat,
			&i.Policy1LastUpdate,
			&i.Policy1Disabled,
			&i.Policy1InboundBaseFeeMsat,
			&i.Policy1InboundFeeRateMilliMsat,
			&i.Policy1Signature,
			&i.Policy2ID,
			&i.Policy2NodeID,
			&i.Policy2Version,
			&i.Policy2Timelock,
			&i.Policy2FeePpm,
			&i.Policy2BaseFeeMsat,
			&i.Policy2MinHtlcMsat,
			&i.Policy2MaxHtlcMsat,
			&i.Policy2LastUpdate,
			&i.Policy2Disabled,
			&i.Policy2InboundBaseFeeMsat,
			&i.Policy2InboundFeeRateMilliMsat,
			&i.Policy2Signature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChannelsPaginated = `-- name: ListChannelsPaginated :many
SELECT id, bitcoin_key_1, bitcoin_key_2, outpoint
FROM channels c
WHERE c.version = $1 AND c.id > $2
ORDER BY c.id
LIMIT $3
`

type ListChannelsPaginatedParams struct {
	Version int16
	ID      int64
	Limit   int32
}

type ListChannelsPaginatedRow struct {
	ID          int64
	BitcoinKey1 []byte
	BitcoinKey2 []byte
	Outpoint    string
}

func (q *Queries) ListChannelsPaginated(ctx context.Context, arg ListChannelsPaginatedParams) ([]ListChannelsPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, listChannelsPaginated, arg.Version, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChannelsPaginatedRow
	for rows.Next() {
		var i ListChannelsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.BitcoinKey1,
			&i.BitcoinKey2,
			&i.Outpoint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChannelsWithPoliciesPaginated = `-- name: ListChannelsWithPoliciesPaginated :many
SELECT
    c.id, c.version, c.scid, c.node_id_1, c.node_id_2, c.outpoint, c.capacity, c.bitcoin_key_1, c.bitcoin_key_2, c.node_1_signature, c.node_2_signature, c.bitcoin_1_signature, c.bitcoin_2_signature,

    -- Join node pubkeys
    n1.pub_key AS node1_pubkey,
    n2.pub_key AS node2_pubkey,

    -- Node 1 policy
    cp1.id AS policy_1_id,
    cp1.node_id AS policy_1_node_id,
    cp1.version AS policy_1_version,
    cp1.timelock AS policy_1_timelock,
    cp1.fee_ppm AS policy_1_fee_ppm,
    cp1.base_fee_msat AS policy_1_base_fee_msat,
    cp1.min_htlc_msat AS policy_1_min_htlc_msat,
    cp1.max_htlc_msat AS policy_1_max_htlc_msat,
    cp1.last_update AS policy_1_last_update,
    cp1.disabled AS policy_1_disabled,
    cp1.inbound_base_fee_msat AS policy1_inbound_base_fee_msat,
    cp1.inbound_fee_rate_milli_msat AS policy1_inbound_fee_rate_milli_msat,
    cp1.signature AS policy_1_signature,

    -- Node 2 policy
    cp2.id AS policy_2_id,
    cp2.node_id AS policy_2_node_id,
    cp2.version AS policy_2_version,
    cp2.timelock AS policy_2_timelock,
    cp2.fee_ppm AS policy_2_fee_ppm,
    cp2.base_fee_msat AS policy_2_base_fee_msat,
    cp2.min_htlc_msat AS policy_2_min_htlc_msat,
    cp2.max_htlc_msat AS policy_2_max_htlc_msat,
    cp2.last_update AS policy_2_last_update,
    cp2.disabled AS policy_2_disabled,
    cp2.inbound_base_fee_msat AS policy2_inbound_base_fee_msat,
    cp2.inbound_fee_rate_milli_msat AS policy2_inbound_fee_rate_milli_msat,
    cp2.signature AS policy_2_signature

FROM channels c
JOIN nodes n1 ON c.node_id_1 = n1.id
JOIN nodes n2 ON c.node_id_2 = n2.id
LEFT JOIN channel_policies cp1
    ON cp1.channel_id = c.id AND cp1.node_id = c.node_id_1 AND cp1.version = c.version
LEFT JOIN channel_policies cp2
    ON cp2.channel_id = c.id AND cp2.node_id = c.node_id_2 AND cp2.version = c.version
WHERE c.version = $1 AND c.id > $2
ORDER BY c.id
LIMIT $3
`

type ListChannelsWithPoliciesPaginatedParams struct {
	Version int16
	ID      int64
	Limit   int32
}

type ListChannelsWithPoliciesPaginatedRow struct {
	Channel                        Channel
	Node1Pubkey                    []byte
	Node2Pubkey                    []byte
	Policy1ID                      sql.NullInt64
	Policy1NodeID                  sql.NullInt64
	Policy1Version                 sql.NullInt16
	Policy1Timelock                sql.NullInt32
	Policy1FeePpm                  sql.NullInt64
	Policy1BaseFeeMsat             sql.NullInt64
	Policy1MinHtlcMsat             sql.NullInt64
	Policy1MaxHtlcMsat             sql.NullInt64
	Policy1LastUpdate              sql.NullInt64
	Policy1Disabled                sql.NullBool
	Policy1InboundBaseFeeMsat      sql.NullInt64
	Policy1InboundFeeRateMilliMsat sql.NullInt64
	Policy1Signature               []byte
	Policy2ID                      sql.NullInt64
	Policy2NodeID                  sql.NullInt64
	Policy2Version                 sql.NullInt16
	Policy2Timelock                sql.NullInt32
	Policy2FeePpm                  sql.NullInt64
	Policy2BaseFeeMsat             sql.NullInt64
	Policy2MinHtlcMsat             sql.NullInt64
	Policy2MaxHtlcMsat             sql.NullInt64
	Policy2LastUpdate              sql.NullInt64
	Policy2Disabled                sql.NullBool
	Policy2InboundBaseFeeMsat      sql.NullInt64
	Policy2InboundFeeRateMilliMsat sql.NullInt64
	Policy2Signature               []byte
}

func (q *Queries) ListChannelsWithPoliciesPaginated(ctx context.Context, arg ListChannelsWithPoliciesPaginatedParams) ([]ListChannelsWithPoliciesPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, listChannelsWithPoliciesPaginated, arg.Version, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChannelsWithPoliciesPaginatedRow
	for rows.Next() {
		var i ListChannelsWithPoliciesPaginatedRow
		if err := rows.Scan(
			&i.Channel.ID,
			&i.Channel.Version,
			&i.Channel.Scid,
			&i.Channel.NodeID1,
			&i.Channel.NodeID2,
			&i.Channel.Outpoint,
			&i.Channel.Capacity,
			&i.Channel.BitcoinKey1,
			&i.Channel.BitcoinKey2,
			&i.Channel.Node1Signature,
			&i.Channel.Node2Signature,
			&i.Channel.Bitcoin1Signature,
			&i.Channel.Bitcoin2Signature,
			&i.Node1Pubkey,
			&i.Node2Pubkey,
			&i.Policy1ID,
			&i.Policy1NodeID,
			&i.Policy1Version,
			&i.Policy1Timelock,
			&i.Policy1FeePpm,
			&i.Policy1BaseFeeMsat,
			&i.Policy1MinHtlcMsat,
			&i.Policy1MaxHtlcMsat,
			&i.Policy1LastUpdate,
			&i.Policy1Disabled,
			&i.Policy1InboundBaseFeeMsat,
			&i.Policy1InboundFeeRateMilliMsat,
			&i.Policy1Signature,
			&i.Policy2ID,
			&i.Policy2NodeID,
			&i.Policy2Version,
			&i.Policy2Timelock,
			&i.Policy2FeePpm,
			&i.Policy2BaseFeeMsat,
			&i.Policy2MinHtlcMsat,
			&i.Policy2MaxHtlcMsat,
			&i.Policy2LastUpdate,
			&i.Policy2Disabled,
			&i.Policy2InboundBaseFeeMsat,
			&i.Policy2InboundFeeRateMilliMsat,
			&i.Policy2Signature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodeIDsAndPubKeys = `-- name: ListNodeIDsAndPubKeys :many
SELECT id, pub_key
FROM nodes
WHERE version = $1  AND id > $2
ORDER BY id
LIMIT $3
`

type ListNodeIDsAndPubKeysParams struct {
	Version int16
	ID      int64
	Limit   int32
}

type ListNodeIDsAndPubKeysRow struct {
	ID     int64
	PubKey []byte
}

func (q *Queries) ListNodeIDsAndPubKeys(ctx context.Context, arg ListNodeIDsAndPubKeysParams) ([]ListNodeIDsAndPubKeysRow, error) {
	rows, err := q.db.QueryContext(ctx, listNodeIDsAndPubKeys, arg.Version, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNodeIDsAndPubKeysRow
	for rows.Next() {
		var i ListNodeIDsAndPubKeysRow
		if err := rows.Scan(&i.ID, &i.PubKey); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodesPaginated = `-- name: ListNodesPaginated :many
SELECT id, version, pub_key, alias, last_update, color, signature
FROM nodes
WHERE version = $1 AND id > $2
ORDER BY id
LIMIT $3
`

type ListNodesPaginatedParams struct {
	Version int16
	ID      int64
	Limit   int32
}

func (q *Queries) ListNodesPaginated(ctx context.Context, arg ListNodesPaginatedParams) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, listNodesPaginated, arg.Version, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Node
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.PubKey,
			&i.Alias,
			&i.LastUpdate,
			&i.Color,
			&i.Signature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertEdgePolicy = `-- name: UpsertEdgePolicy :one
/* ─────────────────────────────────────────────
   channel_policies table queries
   ─────────────────────────────────────────────
*/

INSERT INTO channel_policies (
    version, channel_id, node_id, timelock, fee_ppm,
    base_fee_msat, min_htlc_msat, last_update, disabled,
    max_htlc_msat, inbound_base_fee_msat,
    inbound_fee_rate_milli_msat, signature
) VALUES  (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
ON CONFLICT (channel_id, node_id, version)
    -- Update the following fields if a conflict occurs on channel_id,
    -- node_id, and version.
    DO UPDATE SET
        timelock = EXCLUDED.timelock,
        fee_ppm = EXCLUDED.fee_ppm,
        base_fee_msat = EXCLUDED.base_fee_msat,
        min_htlc_msat = EXCLUDED.min_htlc_msat,
        last_update = EXCLUDED.last_update,
        disabled = EXCLUDED.disabled,
        max_htlc_msat = EXCLUDED.max_htlc_msat,
        inbound_base_fee_msat = EXCLUDED.inbound_base_fee_msat,
        inbound_fee_rate_milli_msat = EXCLUDED.inbound_fee_rate_milli_msat,
        signature = EXCLUDED.signature
WHERE EXCLUDED.last_update > channel_policies.last_update
RETURNING id
`

type UpsertEdgePolicyParams struct {
	Version                 int16
	ChannelID               int64
	NodeID                  int64
	Timelock                int32
	FeePpm                  int64
	BaseFeeMsat             int64
	MinHtlcMsat             int64
	LastUpdate              sql.NullInt64
	Disabled                sql.NullBool
	MaxHtlcMsat             sql.NullInt64
	InboundBaseFeeMsat      sql.NullInt64
	InboundFeeRateMilliMsat sql.NullInt64
	Signature               []byte
}

func (q *Queries) UpsertEdgePolicy(ctx context.Context, arg UpsertEdgePolicyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertEdgePolicy,
		arg.Version,
		arg.ChannelID,
		arg.NodeID,
		arg.Timelock,
		arg.FeePpm,
		arg.BaseFeeMsat,
		arg.MinHtlcMsat,
		arg.LastUpdate,
		arg.Disabled,
		arg.MaxHtlcMsat,
		arg.InboundBaseFeeMsat,
		arg.InboundFeeRateMilliMsat,
		arg.Signature,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertNode = `-- name: UpsertNode :one
/* ─────────────────────────────────────────────
   nodes table queries
   ─────────────────────────────────────────────
*/

INSERT INTO nodes (
    version, pub_key, alias, last_update, color, signature
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (pub_key, version)
    -- Update the following fields if a conflict occurs on pub_key
    -- and version.
    DO UPDATE SET
        alias = EXCLUDED.alias,
        last_update = EXCLUDED.last_update,
        color = EXCLUDED.color,
        signature = EXCLUDED.signature
WHERE nodes.last_update IS NULL
    OR EXCLUDED.last_update > nodes.last_update
RETURNING id
`

type UpsertNodeParams struct {
	Version    int16
	PubKey     []byte
	Alias      sql.NullString
	LastUpdate sql.NullInt64
	Color      sql.NullString
	Signature  []byte
}

func (q *Queries) UpsertNode(ctx context.Context, arg UpsertNodeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertNode,
		arg.Version,
		arg.PubKey,
		arg.Alias,
		arg.LastUpdate,
		arg.Color,
		arg.Signature,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertNodeExtraType = `-- name: UpsertNodeExtraType :exec
/* ─────────────────────────────────────────────
   node_extra_types table queries
   ─────────────────────────────────────────────
*/

INSERT INTO node_extra_types (
    node_id, type, value
)
VALUES ($1, $2, $3)
ON CONFLICT (type, node_id)
    -- Update the value if a conflict occurs on type
    -- and node_id.
    DO UPDATE SET value = EXCLUDED.value
`

type UpsertNodeExtraTypeParams struct {
	NodeID int64
	Type   int64
	Value  []byte
}

func (q *Queries) UpsertNodeExtraType(ctx context.Context, arg UpsertNodeExtraTypeParams) error {
	_, err := q.db.ExecContext(ctx, upsertNodeExtraType, arg.NodeID, arg.Type, arg.Value)
	return err
}

const upsertPruneLogEntry = `-- name: UpsertPruneLogEntry :exec
/* ─────────────────────────────────────────────
    prune_log table queries
    ─────────────────────────────────────────────
*/

INSERT INTO prune_log (
    block_height, block_hash
) VALUES (
    $1, $2
)
ON CONFLICT(block_height) DO UPDATE SET
    block_hash = EXCLUDED.block_hash
`

type UpsertPruneLogEntryParams struct {
	BlockHeight int64
	BlockHash   []byte
}

func (q *Queries) UpsertPruneLogEntry(ctx context.Context, arg UpsertPruneLogEntryParams) error {
	_, err := q.db.ExecContext(ctx, upsertPruneLogEntry, arg.BlockHeight, arg.BlockHash)
	return err
}

const upsertZombieChannel = `-- name: UpsertZombieChannel :exec
/* ─────────────────────────────────────────────
   zombie_channels table queries
   ─────────────────────────────────────────────
*/

INSERT INTO zombie_channels (scid, version, node_key_1, node_key_2)
VALUES ($1, $2, $3, $4)
ON CONFLICT (scid, version)
DO UPDATE SET
    -- If a conflict exists for the SCID and version pair, then we
    -- update the node keys.
    node_key_1 = COALESCE(EXCLUDED.node_key_1, zombie_channels.node_key_1),
    node_key_2 = COALESCE(EXCLUDED.node_key_2, zombie_channels.node_key_2)
`

type UpsertZombieChannelParams struct {
	Scid     []byte
	Version  int16
	NodeKey1 []byte
	NodeKey2 []byte
}

func (q *Queries) UpsertZombieChannel(ctx context.Context, arg UpsertZombieChannelParams) error {
	_, err := q.db.ExecContext(ctx, upsertZombieChannel,
		arg.Scid,
		arg.Version,
		arg.NodeKey1,
		arg.NodeKey2,
	)
	return err
}
