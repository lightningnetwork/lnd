// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: payments.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const deleteFailedAttempts = `-- name: DeleteFailedAttempts :exec
DELETE FROM payment_htlc_attempts WHERE payment_id = $1 AND htlc_fail_reason IS NOT NULL
`

func (q *Queries) DeleteFailedAttempts(ctx context.Context, paymentID int64) error {
	_, err := q.db.ExecContext(ctx, deleteFailedAttempts, paymentID)
	return err
}

const deleteHTLCAttempt = `-- name: DeleteHTLCAttempt :exec
DELETE FROM payment_htlc_attempts WHERE attempt_index = $1
`

// Delete a single HTLC attempt by its index.
func (q *Queries) DeleteHTLCAttempt(ctx context.Context, attemptIndex int64) error {
	_, err := q.db.ExecContext(ctx, deleteHTLCAttempt, attemptIndex)
	return err
}

const deletePayment = `-- name: DeletePayment :exec
/* ─────────────────────────────────────────────
   delete queries
   ─────────────────────────────────────────────
*/

DELETE FROM payments WHERE payment_hash = $1
`

func (q *Queries) DeletePayment(ctx context.Context, paymentHash []byte) error {
	_, err := q.db.ExecContext(ctx, deletePayment, paymentHash)
	return err
}

const deletePaymentByID = `-- name: DeletePaymentByID :exec
DELETE FROM payments WHERE id = $1
`

func (q *Queries) DeletePaymentByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePaymentByID, id)
	return err
}

const fetchCustomRecordsForHop = `-- name: FetchCustomRecordsForHop :many
SELECT id, key, value, hop_id FROM payment_route_hop_custom_records WHERE hop_id = $1
`

func (q *Queries) FetchCustomRecordsForHop(ctx context.Context, hopID int64) ([]PaymentRouteHopCustomRecord, error) {
	rows, err := q.db.QueryContext(ctx, fetchCustomRecordsForHop, hopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentRouteHopCustomRecord
	for rows.Next() {
		var i PaymentRouteHopCustomRecord
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.Value,
			&i.HopID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchDuplicateHopCustomRecordsForHop = `-- name: FetchDuplicateHopCustomRecordsForHop :many
SELECT id, key, value, hop_id FROM duplicate_payment_route_hop_custom_records WHERE hop_id = $1
`

func (q *Queries) FetchDuplicateHopCustomRecordsForHop(ctx context.Context, hopID int64) ([]DuplicatePaymentRouteHopCustomRecord, error) {
	rows, err := q.db.QueryContext(ctx, fetchDuplicateHopCustomRecordsForHop, hopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DuplicatePaymentRouteHopCustomRecord
	for rows.Next() {
		var i DuplicatePaymentRouteHopCustomRecord
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.Value,
			&i.HopID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchDuplicateHopsForAttempt = `-- name: FetchDuplicateHopsForAttempt :many
SELECT id, htlc_attempt_index, hop_index, pub_key, chan_id, outgoing_time_lock, amt_to_forward, meta_data FROM duplicate_payment_route_hops h
WHERE h.htlc_attempt_index = $1
ORDER BY h.hop_index ASC
`

func (q *Queries) FetchDuplicateHopsForAttempt(ctx context.Context, htlcAttemptIndex int64) ([]DuplicatePaymentRouteHop, error) {
	rows, err := q.db.QueryContext(ctx, fetchDuplicateHopsForAttempt, htlcAttemptIndex)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DuplicatePaymentRouteHop
	for rows.Next() {
		var i DuplicatePaymentRouteHop
		if err := rows.Scan(
			&i.ID,
			&i.HtlcAttemptIndex,
			&i.HopIndex,
			&i.PubKey,
			&i.ChanID,
			&i.OutgoingTimeLock,
			&i.AmtToForward,
			&i.MetaData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchDuplicateHtlcAttempts = `-- name: FetchDuplicateHtlcAttempts :many
SELECT id, attempt_index, duplicate_payment_id, session_key, attempt_time, payment_hash, route_total_timelock, route_total_amount, route_source_key, failure_source_index, htlc_fail_reason, failure_msg, fail_time, settle_preimage, settle_time FROM duplicate_payment_htlc_attempts ha
WHERE ha.duplicate_payment_id = $1 
    AND (
        ($2 = true AND ha.settle_preimage IS NULL AND ha.htlc_fail_reason IS NULL)
        OR
        ($2 = false OR $2 IS NULL)
    )
ORDER BY 
    CASE WHEN $3 = false OR $3 IS NULL THEN ha.attempt_time END ASC,
    CASE WHEN $3 = true THEN ha.attempt_time END DESC
`

type FetchDuplicateHtlcAttemptsParams struct {
	DuplicatePaymentID int64
	InFlightOnly       interface{}
	Reverse            interface{}
}

// Fetch HTLC attempts for duplicate payments
func (q *Queries) FetchDuplicateHtlcAttempts(ctx context.Context, arg FetchDuplicateHtlcAttemptsParams) ([]DuplicatePaymentHtlcAttempt, error) {
	rows, err := q.db.QueryContext(ctx, fetchDuplicateHtlcAttempts, arg.DuplicatePaymentID, arg.InFlightOnly, arg.Reverse)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DuplicatePaymentHtlcAttempt
	for rows.Next() {
		var i DuplicatePaymentHtlcAttempt
		if err := rows.Scan(
			&i.ID,
			&i.AttemptIndex,
			&i.DuplicatePaymentID,
			&i.SessionKey,
			&i.AttemptTime,
			&i.PaymentHash,
			&i.RouteTotalTimelock,
			&i.RouteTotalAmount,
			&i.RouteSourceKey,
			&i.FailureSourceIndex,
			&i.HtlcFailReason,
			&i.FailureMsg,
			&i.FailTime,
			&i.SettlePreimage,
			&i.SettleTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchDuplicatePayments = `-- name: FetchDuplicatePayments :many
SELECT id, payment_id, payment_hash, payment_request, amount_msat, created_at, fail_reason FROM duplicate_payments
WHERE payment_hash = $1
ORDER BY created_at ASC
`

func (q *Queries) FetchDuplicatePayments(ctx context.Context, paymentHash []byte) ([]DuplicatePayment, error) {
	rows, err := q.db.QueryContext(ctx, fetchDuplicatePayments, paymentHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DuplicatePayment
	for rows.Next() {
		var i DuplicatePayment
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.PaymentHash,
			&i.PaymentRequest,
			&i.AmountMsat,
			&i.CreatedAt,
			&i.FailReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchFirstHopCustomRecords = `-- name: FetchFirstHopCustomRecords :many
SELECT id, key, value, payment_id FROM payment_first_hop_custom_records WHERE payment_id = $1
`

func (q *Queries) FetchFirstHopCustomRecords(ctx context.Context, paymentID int64) ([]PaymentFirstHopCustomRecord, error) {
	rows, err := q.db.QueryContext(ctx, fetchFirstHopCustomRecords, paymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentFirstHopCustomRecord
	for rows.Next() {
		var i PaymentFirstHopCustomRecord
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.Value,
			&i.PaymentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchHopsForAttempt = `-- name: FetchHopsForAttempt :many
SELECT id, htlc_attempt_index, hop_index, pub_key, chan_id, outgoing_time_lock, amt_to_forward, meta_data, legacy_payload, mpp_payment_addr, mpp_total_msat, amp_root_share, amp_set_id, amp_child_index, encrypted_data, blinding_point, blinded_path_total_amt FROM payment_route_hops h
WHERE h.htlc_attempt_index = $1
ORDER BY h.hop_index ASC
`

func (q *Queries) FetchHopsForAttempt(ctx context.Context, htlcAttemptIndex int64) ([]PaymentRouteHop, error) {
	rows, err := q.db.QueryContext(ctx, fetchHopsForAttempt, htlcAttemptIndex)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentRouteHop
	for rows.Next() {
		var i PaymentRouteHop
		if err := rows.Scan(
			&i.ID,
			&i.HtlcAttemptIndex,
			&i.HopIndex,
			&i.PubKey,
			&i.ChanID,
			&i.OutgoingTimeLock,
			&i.AmtToForward,
			&i.MetaData,
			&i.LegacyPayload,
			&i.MppPaymentAddr,
			&i.MppTotalMsat,
			&i.AmpRootShare,
			&i.AmpSetID,
			&i.AmpChildIndex,
			&i.EncryptedData,
			&i.BlindingPoint,
			&i.BlindedPathTotalAmt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchHtlcAttempts = `-- name: FetchHtlcAttempts :many
SELECT id, attempt_index, payment_id, session_key, attempt_time, payment_hash, route_total_timelock, route_total_amount, route_first_hop_amount, route_source_key, failure_source_index, htlc_fail_reason, failure_msg, fail_time, settle_preimage, settle_time FROM payment_htlc_attempts ha
WHERE ha.payment_id = $1 
    AND (
        ($2 = true AND ha.settle_preimage IS NULL AND ha.htlc_fail_reason IS NULL)
        OR
        ($2 = false OR $2 IS NULL)
    )
ORDER BY 
    CASE WHEN $3 = false OR $3 IS NULL THEN ha.attempt_time END ASC,
    CASE WHEN $3 = true THEN ha.attempt_time END DESC
`

type FetchHtlcAttemptsParams struct {
	PaymentID    int64
	InFlightOnly interface{}
	Reverse      interface{}
}

// This will not include the hops for the htlc attempts which can be fetched
// with the FetchHopsForAttempt query.
func (q *Queries) FetchHtlcAttempts(ctx context.Context, arg FetchHtlcAttemptsParams) ([]PaymentHtlcAttempt, error) {
	rows, err := q.db.QueryContext(ctx, fetchHtlcAttempts, arg.PaymentID, arg.InFlightOnly, arg.Reverse)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentHtlcAttempt
	for rows.Next() {
		var i PaymentHtlcAttempt
		if err := rows.Scan(
			&i.ID,
			&i.AttemptIndex,
			&i.PaymentID,
			&i.SessionKey,
			&i.AttemptTime,
			&i.PaymentHash,
			&i.RouteTotalTimelock,
			&i.RouteTotalAmount,
			&i.RouteFirstHopAmount,
			&i.RouteSourceKey,
			&i.FailureSourceIndex,
			&i.HtlcFailReason,
			&i.FailureMsg,
			&i.FailTime,
			&i.SettlePreimage,
			&i.SettleTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchInflightHTLCAttempts = `-- name: FetchInflightHTLCAttempts :many
SELECT id, attempt_index, payment_id, session_key, attempt_time, payment_hash, route_total_timelock, route_total_amount, route_first_hop_amount, route_source_key, failure_source_index, htlc_fail_reason, failure_msg, fail_time, settle_preimage, settle_time FROM payment_htlc_attempts WHERE  settle_preimage IS NULL AND htlc_fail_reason IS NULL
`

func (q *Queries) FetchInflightHTLCAttempts(ctx context.Context) ([]PaymentHtlcAttempt, error) {
	rows, err := q.db.QueryContext(ctx, fetchInflightHTLCAttempts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentHtlcAttempt
	for rows.Next() {
		var i PaymentHtlcAttempt
		if err := rows.Scan(
			&i.ID,
			&i.AttemptIndex,
			&i.PaymentID,
			&i.SessionKey,
			&i.AttemptTime,
			&i.PaymentHash,
			&i.RouteTotalTimelock,
			&i.RouteTotalAmount,
			&i.RouteFirstHopAmount,
			&i.RouteSourceKey,
			&i.FailureSourceIndex,
			&i.HtlcFailReason,
			&i.FailureMsg,
			&i.FailTime,
			&i.SettlePreimage,
			&i.SettleTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPayment = `-- name: FetchPayment :one
SELECT id, payment_type, payment_request, amount_msat, created_at, payment_hash, fail_reason, has_duplicate_payment FROM payments WHERE payment_hash = $1
`

func (q *Queries) FetchPayment(ctx context.Context, paymentHash []byte) (Payment, error) {
	row := q.db.QueryRowContext(ctx, fetchPayment, paymentHash)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PaymentType,
		&i.PaymentRequest,
		&i.AmountMsat,
		&i.CreatedAt,
		&i.PaymentHash,
		&i.FailReason,
		&i.HasDuplicatePayment,
	)
	return i, err
}

const filterPayments = `-- name: FilterPayments :many
/* ─────────────────────────────────────────────
   fetch queries
   ─────────────────────────────────────────────
*/

SELECT id, payment_type, payment_request, amount_msat, created_at, payment_hash, fail_reason, has_duplicate_payment FROM payments
WHERE (
    -- This will include payments which have the failed reason set. This means
    -- that they are not settled however they are still not necessarily failed
    -- because they are still in flight but we know for sure that if they are
    -- currently in flight that they will transition to failed. This helps us
    -- to not fetch payments that we know are failed or will transition to 
    -- failed.
    ($1 = true AND fail_reason IS NULL) OR
    $1 = false OR $1 IS NULL
) AND (
    -- Optional cursor-based pagination.
    $2 IS NULL OR
    id >= $2
) AND (
    id <= $3 OR
    $3 IS NULL
) AND (
    -- Optional date filters.
    ($4 IS NULL) OR
    ($4 IS NOT NULL AND created_at >= $4)
) AND (
    created_at < $5 OR
    $5 IS NULL
)
ORDER BY 
    CASE WHEN $6 = false OR $6 IS NULL THEN id END ASC,
    CASE WHEN $6 = true THEN id END DESC
LIMIT $8 OFFSET $7
`

type FilterPaymentsParams struct {
	ExcludeFailed  interface{}
	IndexOffsetGet interface{}
	IndexOffsetLet sql.NullInt64
	CreatedAfter   interface{}
	CreatedBefore  sql.NullTime
	Reverse        interface{}
	NumOffset      int32
	NumLimit       int32
}

func (q *Queries) FilterPayments(ctx context.Context, arg FilterPaymentsParams) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, filterPayments,
		arg.ExcludeFailed,
		arg.IndexOffsetGet,
		arg.IndexOffsetLet,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.Reverse,
		arg.NumOffset,
		arg.NumLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PaymentType,
			&i.PaymentRequest,
			&i.AmountMsat,
			&i.CreatedAt,
			&i.PaymentHash,
			&i.FailReason,
			&i.HasDuplicatePayment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDuplicateHop = `-- name: InsertDuplicateHop :one
INSERT INTO duplicate_payment_route_hops (
    htlc_attempt_index,
    hop_index,
    pub_key,
    chan_id,
    outgoing_time_lock,
    amt_to_forward,
    meta_data
) VALUES ($1, $2, $3, $4,
 $5, $6, $7) RETURNING id
`

type InsertDuplicateHopParams struct {
	HtlcAttemptIndex int64
	HopIndex         int32
	PubKey           []byte
	ChanID           string
	OutgoingTimeLock int32
	AmtToForward     int64
	MetaData         []byte
}

func (q *Queries) InsertDuplicateHop(ctx context.Context, arg InsertDuplicateHopParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertDuplicateHop,
		arg.HtlcAttemptIndex,
		arg.HopIndex,
		arg.PubKey,
		arg.ChanID,
		arg.OutgoingTimeLock,
		arg.AmtToForward,
		arg.MetaData,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertDuplicateHopCustomRecord = `-- name: InsertDuplicateHopCustomRecord :exec
INSERT INTO duplicate_payment_route_hop_custom_records (
    hop_id,
    key,
    value
) VALUES ($1, $2, $3)
`

type InsertDuplicateHopCustomRecordParams struct {
	HopID int64
	Key   int64
	Value []byte
}

func (q *Queries) InsertDuplicateHopCustomRecord(ctx context.Context, arg InsertDuplicateHopCustomRecordParams) error {
	_, err := q.db.ExecContext(ctx, insertDuplicateHopCustomRecord, arg.HopID, arg.Key, arg.Value)
	return err
}

const insertDuplicateHtlcAttempt = `-- name: InsertDuplicateHtlcAttempt :one
INSERT INTO duplicate_payment_htlc_attempts (
    attempt_index,
    duplicate_payment_id,
    payment_hash,
    attempt_time,
    session_key,
    route_total_timeLock,
    route_total_amount,
    route_source_key
) VALUES ($1, $2, $3, $4, 
$5, $6, $7, 
$8) RETURNING id
`

type InsertDuplicateHtlcAttemptParams struct {
	AttemptIndex       int64
	DuplicatePaymentID int64
	PaymentHash        []byte
	AttemptTime        time.Time
	SessionKey         []byte
	RouteTotalTimelock int32
	RouteTotalAmount   int64
	RouteSourceKey     []byte
}

func (q *Queries) InsertDuplicateHtlcAttempt(ctx context.Context, arg InsertDuplicateHtlcAttemptParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertDuplicateHtlcAttempt,
		arg.AttemptIndex,
		arg.DuplicatePaymentID,
		arg.PaymentHash,
		arg.AttemptTime,
		arg.SessionKey,
		arg.RouteTotalTimelock,
		arg.RouteTotalAmount,
		arg.RouteSourceKey,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertDuplicatePayment = `-- name: InsertDuplicatePayment :one
INSERT INTO duplicate_payments (
    payment_hash,
    payment_request,
    amount_msat,
    created_at,
    fail_reason
) VALUES (
    $1, $2,
    $3, $4, $5
) RETURNING id
`

type InsertDuplicatePaymentParams struct {
	PaymentHash    []byte
	PaymentRequest []byte
	AmountMsat     int64
	CreatedAt      time.Time
	FailReason     sql.NullInt32
}

func (q *Queries) InsertDuplicatePayment(ctx context.Context, arg InsertDuplicatePaymentParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertDuplicatePayment,
		arg.PaymentHash,
		arg.PaymentRequest,
		arg.AmountMsat,
		arg.CreatedAt,
		arg.FailReason,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertFirstHopCustomRecord = `-- name: InsertFirstHopCustomRecord :exec
INSERT INTO payment_first_hop_custom_records (
    payment_id,
    key,
    value
) VALUES ($1, $2, $3)
`

type InsertFirstHopCustomRecordParams struct {
	PaymentID int64
	Key       int64
	Value     []byte
}

func (q *Queries) InsertFirstHopCustomRecord(ctx context.Context, arg InsertFirstHopCustomRecordParams) error {
	_, err := q.db.ExecContext(ctx, insertFirstHopCustomRecord, arg.PaymentID, arg.Key, arg.Value)
	return err
}

const insertHop = `-- name: InsertHop :one
INSERT INTO payment_route_hops (
    htlc_attempt_index,
    hop_index,
    pub_key,
    chan_id,
    outgoing_time_lock,
    amt_to_forward,
    meta_data,
    legacy_payload,
    mpp_payment_addr,
    mpp_total_msat,
    amp_root_share,
    amp_set_id,
    amp_child_index,
    encrypted_data,
    blinding_point,
    blinded_path_total_amt
) VALUES ($1, $2, $3, $4,
 $5, $6, $7, $8,
$9, $10, $11, $12,
$13, $14, $15, 
$16) RETURNING id
`

type InsertHopParams struct {
	HtlcAttemptIndex    int64
	HopIndex            int32
	PubKey              []byte
	ChanID              string
	OutgoingTimeLock    int32
	AmtToForward        int64
	MetaData            []byte
	LegacyPayload       bool
	MppPaymentAddr      []byte
	MppTotalMsat        sql.NullInt64
	AmpRootShare        []byte
	AmpSetID            []byte
	AmpChildIndex       sql.NullInt32
	EncryptedData       []byte
	BlindingPoint       []byte
	BlindedPathTotalAmt sql.NullInt64
}

func (q *Queries) InsertHop(ctx context.Context, arg InsertHopParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertHop,
		arg.HtlcAttemptIndex,
		arg.HopIndex,
		arg.PubKey,
		arg.ChanID,
		arg.OutgoingTimeLock,
		arg.AmtToForward,
		arg.MetaData,
		arg.LegacyPayload,
		arg.MppPaymentAddr,
		arg.MppTotalMsat,
		arg.AmpRootShare,
		arg.AmpSetID,
		arg.AmpChildIndex,
		arg.EncryptedData,
		arg.BlindingPoint,
		arg.BlindedPathTotalAmt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertHopCustomRecord = `-- name: InsertHopCustomRecord :exec
INSERT INTO payment_route_hop_custom_records (
    hop_id,
    key,
    value
) VALUES ($1, $2, $3)
`

type InsertHopCustomRecordParams struct {
	HopID int64
	Key   int64
	Value []byte
}

func (q *Queries) InsertHopCustomRecord(ctx context.Context, arg InsertHopCustomRecordParams) error {
	_, err := q.db.ExecContext(ctx, insertHopCustomRecord, arg.HopID, arg.Key, arg.Value)
	return err
}

const insertHtlcAttempt = `-- name: InsertHtlcAttempt :one
INSERT INTO payment_htlc_attempts (
    attempt_index,
    payment_id,
    payment_hash,
    attempt_time,
    session_key,
    route_total_timeLock,
    route_total_amount,
    route_first_hop_amount,
    route_source_key
) VALUES ($1, $2, $3, $4, 
$5, $6, $7, 
$8, $9) RETURNING id
`

type InsertHtlcAttemptParams struct {
	AttemptIndex        int64
	PaymentID           int64
	PaymentHash         []byte
	AttemptTime         time.Time
	SessionKey          []byte
	RouteTotalTimelock  int32
	RouteTotalAmount    int64
	RouteFirstHopAmount sql.NullInt64
	RouteSourceKey      []byte
}

func (q *Queries) InsertHtlcAttempt(ctx context.Context, arg InsertHtlcAttemptParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertHtlcAttempt,
		arg.AttemptIndex,
		arg.PaymentID,
		arg.PaymentHash,
		arg.AttemptTime,
		arg.SessionKey,
		arg.RouteTotalTimelock,
		arg.RouteTotalAmount,
		arg.RouteFirstHopAmount,
		arg.RouteSourceKey,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertPayment = `-- name: InsertPayment :one
/* ─────────────────────────────────────────────
   insert queries
   ─────────────────────────────────────────────
*/

INSERT INTO payments (
    payment_type, 
    payment_request, 
    amount_msat, 
    created_at,
    payment_hash
) VALUES (
    $1, $2, 
    $3, $4, $5
) RETURNING id
`

type InsertPaymentParams struct {
	PaymentType    sql.NullInt32
	PaymentRequest []byte
	AmountMsat     int64
	CreatedAt      time.Time
	PaymentHash    []byte
}

func (q *Queries) InsertPayment(ctx context.Context, arg InsertPaymentParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertPayment,
		arg.PaymentType,
		arg.PaymentRequest,
		arg.AmountMsat,
		arg.CreatedAt,
		arg.PaymentHash,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const nextHtlcAttemptIndex = `-- name: NextHtlcAttemptIndex :one
/* ─────────────────────────────────────────────
   sequence number queries
   ─────────────────────────────────────────────
*/

UPDATE payment_sequences 
SET current_value = current_value + 1 
WHERE name = 'htlc_attempt_index' 
RETURNING current_value
`

func (q *Queries) NextHtlcAttemptIndex(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, nextHtlcAttemptIndex)
	var current_value int64
	err := row.Scan(&current_value)
	return current_value, err
}

const updateHtlcAttemptFailInfo = `-- name: UpdateHtlcAttemptFailInfo :one
UPDATE payment_htlc_attempts 
SET failure_source_index = $1, 
htlc_fail_reason = $2, failure_msg = $3,
 fail_time = $4
WHERE attempt_index = $5
RETURNING id
`

type UpdateHtlcAttemptFailInfoParams struct {
	FailureSourceIndex sql.NullInt32
	HtlcFailReason     sql.NullInt32
	FailureMsg         []byte
	FailTime           sql.NullTime
	AttemptIndex       int64
}

func (q *Queries) UpdateHtlcAttemptFailInfo(ctx context.Context, arg UpdateHtlcAttemptFailInfoParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateHtlcAttemptFailInfo,
		arg.FailureSourceIndex,
		arg.HtlcFailReason,
		arg.FailureMsg,
		arg.FailTime,
		arg.AttemptIndex,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateHtlcAttemptSettleInfo = `-- name: UpdateHtlcAttemptSettleInfo :one
/* ─────────────────────────────────────────────
   update queries
   ─────────────────────────────────────────────
*/

UPDATE payment_htlc_attempts 
SET settle_preimage = $1, settle_time = $2 
WHERE attempt_index = $3
RETURNING id
`

type UpdateHtlcAttemptSettleInfoParams struct {
	SettlePreimage []byte
	SettleTime     sql.NullTime
	AttemptIndex   int64
}

func (q *Queries) UpdateHtlcAttemptSettleInfo(ctx context.Context, arg UpdateHtlcAttemptSettleInfoParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateHtlcAttemptSettleInfo, arg.SettlePreimage, arg.SettleTime, arg.AttemptIndex)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updatePaymentFailReason = `-- name: UpdatePaymentFailReason :one
UPDATE payments 
SET fail_reason = $1
WHERE payment_hash = $2
RETURNING id
`

type UpdatePaymentFailReasonParams struct {
	FailReason  sql.NullInt32
	PaymentHash []byte
}

func (q *Queries) UpdatePaymentFailReason(ctx context.Context, arg UpdatePaymentFailReasonParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updatePaymentFailReason, arg.FailReason, arg.PaymentHash)
	var id int64
	err := row.Scan(&id)
	return id, err
}
