// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: payments.sql

package sqlc

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const countPayments = `-- name: CountPayments :one
SELECT COUNT(*) FROM payments
`

func (q *Queries) CountPayments(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPayments)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteFailedAttempts = `-- name: DeleteFailedAttempts :exec
DELETE FROM payment_htlc_attempts WHERE payment_id = $1 AND attempt_index IN (
    SELECT attempt_index FROM payment_htlc_attempt_resolutions WHERE resolution_type = 2
)
`

func (q *Queries) DeleteFailedAttempts(ctx context.Context, paymentID int64) error {
	_, err := q.db.ExecContext(ctx, deleteFailedAttempts, paymentID)
	return err
}

const deletePayment = `-- name: DeletePayment :exec
DELETE FROM payments WHERE id = $1
`

func (q *Queries) DeletePayment(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePayment, id)
	return err
}

const fetchAllInflightAttempts = `-- name: FetchAllInflightAttempts :many
SELECT
    ha.id,
    ha.attempt_index,
    ha.payment_id,
    ha.session_key,
    ha.attempt_time,
    ha.payment_hash,
    ha.first_hop_amount_msat,
    ha.route_total_time_lock,
    ha.route_total_amount,
    ha.route_source_key
FROM payment_htlc_attempts ha
WHERE NOT EXISTS (
    SELECT 1 FROM payment_htlc_attempt_resolutions hr 
    WHERE hr.attempt_index = ha.attempt_index
)
`

// Fetch all inflight attempts across all payments
func (q *Queries) FetchAllInflightAttempts(ctx context.Context) ([]PaymentHtlcAttempt, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllInflightAttempts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentHtlcAttempt
	for rows.Next() {
		var i PaymentHtlcAttempt
		if err := rows.Scan(
			&i.ID,
			&i.AttemptIndex,
			&i.PaymentID,
			&i.SessionKey,
			&i.AttemptTime,
			&i.PaymentHash,
			&i.FirstHopAmountMsat,
			&i.RouteTotalTimeLock,
			&i.RouteTotalAmount,
			&i.RouteSourceKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchHopLevelCustomRecords = `-- name: FetchHopLevelCustomRecords :many
SELECT
    l.id,
    l.hop_id,
    l.key,
    l.value
FROM payment_hop_custom_records l
WHERE l.hop_id IN (/*SLICE:hop_ids*/?)
`

func (q *Queries) FetchHopLevelCustomRecords(ctx context.Context, hopIds []int64) ([]PaymentHopCustomRecord, error) {
	query := fetchHopLevelCustomRecords
	var queryParams []interface{}
	if len(hopIds) > 0 {
		for _, v := range hopIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:hop_ids*/?", makeQueryParams(len(queryParams), len(hopIds)), 1)
	} else {
		query = strings.Replace(query, "/*SLICE:hop_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentHopCustomRecord
	for rows.Next() {
		var i PaymentHopCustomRecord
		if err := rows.Scan(
			&i.ID,
			&i.HopID,
			&i.Key,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchHopsForAttempt = `-- name: FetchHopsForAttempt :many
SELECT
    h.id,
    h.htlc_attempt_index,
    h.hop_index,
    h.pub_key,
    h.scid,
    h.outgoing_time_lock,
    h.amt_to_forward,
    h.meta_data,
    m.payment_addr AS mpp_payment_addr,
    m.total_msat AS mpp_total_msat,
    a.root_share AS amp_root_share,
    a.set_id AS amp_set_id,
    a.child_index AS amp_child_index,
    b.encrypted_data,
    b.blinding_point,
    b.blinded_path_total_amt
FROM payment_route_hops h
LEFT JOIN payment_route_hop_mpp m ON m.hop_id = h.id
LEFT JOIN payment_route_hop_amp a ON a.hop_id = h.id
LEFT JOIN payment_route_hop_blinded b ON b.hop_id = h.id
WHERE h.htlc_attempt_index = $1
ORDER BY h.hop_index ASC
`

type FetchHopsForAttemptRow struct {
	ID                  int64
	HtlcAttemptIndex    int64
	HopIndex            int32
	PubKey              []byte
	Scid                string
	OutgoingTimeLock    int32
	AmtToForward        int64
	MetaData            []byte
	MppPaymentAddr      []byte
	MppTotalMsat        sql.NullInt64
	AmpRootShare        []byte
	AmpSetID            []byte
	AmpChildIndex       sql.NullInt32
	EncryptedData       []byte
	BlindingPoint       []byte
	BlindedPathTotalAmt sql.NullInt64
}

func (q *Queries) FetchHopsForAttempt(ctx context.Context, htlcAttemptIndex int64) ([]FetchHopsForAttemptRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchHopsForAttempt, htlcAttemptIndex)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchHopsForAttemptRow
	for rows.Next() {
		var i FetchHopsForAttemptRow
		if err := rows.Scan(
			&i.ID,
			&i.HtlcAttemptIndex,
			&i.HopIndex,
			&i.PubKey,
			&i.Scid,
			&i.OutgoingTimeLock,
			&i.AmtToForward,
			&i.MetaData,
			&i.MppPaymentAddr,
			&i.MppTotalMsat,
			&i.AmpRootShare,
			&i.AmpSetID,
			&i.AmpChildIndex,
			&i.EncryptedData,
			&i.BlindingPoint,
			&i.BlindedPathTotalAmt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchHopsForAttempts = `-- name: FetchHopsForAttempts :many
SELECT
    h.id,
    h.htlc_attempt_index,
    h.hop_index,
    h.pub_key,
    h.scid,
    h.outgoing_time_lock,
    h.amt_to_forward,
    h.meta_data,
    m.payment_addr AS mpp_payment_addr,
    m.total_msat AS mpp_total_msat,
    a.root_share AS amp_root_share,
    a.set_id AS amp_set_id,
    a.child_index AS amp_child_index,
    b.encrypted_data,
    b.blinding_point,
    b.blinded_path_total_amt
FROM payment_route_hops h
LEFT JOIN payment_route_hop_mpp m ON m.hop_id = h.id
LEFT JOIN payment_route_hop_amp a ON a.hop_id = h.id
LEFT JOIN payment_route_hop_blinded b ON b.hop_id = h.id
WHERE h.htlc_attempt_index IN (/*SLICE:htlc_attempt_indices*/?)
`

type FetchHopsForAttemptsRow struct {
	ID                  int64
	HtlcAttemptIndex    int64
	HopIndex            int32
	PubKey              []byte
	Scid                string
	OutgoingTimeLock    int32
	AmtToForward        int64
	MetaData            []byte
	MppPaymentAddr      []byte
	MppTotalMsat        sql.NullInt64
	AmpRootShare        []byte
	AmpSetID            []byte
	AmpChildIndex       sql.NullInt32
	EncryptedData       []byte
	BlindingPoint       []byte
	BlindedPathTotalAmt sql.NullInt64
}

func (q *Queries) FetchHopsForAttempts(ctx context.Context, htlcAttemptIndices []int64) ([]FetchHopsForAttemptsRow, error) {
	query := fetchHopsForAttempts
	var queryParams []interface{}
	if len(htlcAttemptIndices) > 0 {
		for _, v := range htlcAttemptIndices {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:htlc_attempt_indices*/?", makeQueryParams(len(queryParams), len(htlcAttemptIndices)), 1)
	} else {
		query = strings.Replace(query, "/*SLICE:htlc_attempt_indices*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchHopsForAttemptsRow
	for rows.Next() {
		var i FetchHopsForAttemptsRow
		if err := rows.Scan(
			&i.ID,
			&i.HtlcAttemptIndex,
			&i.HopIndex,
			&i.PubKey,
			&i.Scid,
			&i.OutgoingTimeLock,
			&i.AmtToForward,
			&i.MetaData,
			&i.MppPaymentAddr,
			&i.MppTotalMsat,
			&i.AmpRootShare,
			&i.AmpSetID,
			&i.AmpChildIndex,
			&i.EncryptedData,
			&i.BlindingPoint,
			&i.BlindedPathTotalAmt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchHtlcAttemptsForPayment = `-- name: FetchHtlcAttemptsForPayment :many
SELECT
    ha.id,
    ha.attempt_index,
    ha.payment_id,
    ha.session_key,
    ha.attempt_time,
    ha.payment_hash,
    ha.first_hop_amount_msat,
    ha.route_total_time_lock,
    ha.route_total_amount,
    ha.route_source_key,
    hr.resolution_type,
    hr.resolution_time,
    hr.failure_source_index,
    hr.htlc_fail_reason,
    hr.failure_msg,
    hr.settle_preimage
FROM payment_htlc_attempts ha
LEFT JOIN payment_htlc_attempt_resolutions hr ON hr.attempt_index = ha.attempt_index
WHERE ha.payment_id = $1
ORDER BY ha.attempt_time ASC
`

type FetchHtlcAttemptsForPaymentRow struct {
	ID                 int64
	AttemptIndex       int64
	PaymentID          int64
	SessionKey         []byte
	AttemptTime        time.Time
	PaymentHash        []byte
	FirstHopAmountMsat int64
	RouteTotalTimeLock int32
	RouteTotalAmount   int64
	RouteSourceKey     []byte
	ResolutionType     sql.NullInt32
	ResolutionTime     sql.NullTime
	FailureSourceIndex sql.NullInt32
	HtlcFailReason     sql.NullInt32
	FailureMsg         []byte
	SettlePreimage     []byte
}

// This fetches all htlc attempts for a payment.
func (q *Queries) FetchHtlcAttemptsForPayment(ctx context.Context, paymentID int64) ([]FetchHtlcAttemptsForPaymentRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchHtlcAttemptsForPayment, paymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchHtlcAttemptsForPaymentRow
	for rows.Next() {
		var i FetchHtlcAttemptsForPaymentRow
		if err := rows.Scan(
			&i.ID,
			&i.AttemptIndex,
			&i.PaymentID,
			&i.SessionKey,
			&i.AttemptTime,
			&i.PaymentHash,
			&i.FirstHopAmountMsat,
			&i.RouteTotalTimeLock,
			&i.RouteTotalAmount,
			&i.RouteSourceKey,
			&i.ResolutionType,
			&i.ResolutionTime,
			&i.FailureSourceIndex,
			&i.HtlcFailReason,
			&i.FailureMsg,
			&i.SettlePreimage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPayment = `-- name: FetchPayment :one
SELECT
    p.id, p.intent_id, p.amount_msat, p.created_at, p.payment_identifier, p.fail_reason,
    i.intent_type AS "intent_type",
    i.intent_payload AS "intent_payload"
FROM payments p
LEFT JOIN payment_intents i ON i.id = p.intent_id
WHERE p.payment_identifier = $1
`

type FetchPaymentRow struct {
	Payment       Payment
	IntentType    sql.NullInt16
	IntentPayload []byte
}

func (q *Queries) FetchPayment(ctx context.Context, paymentIdentifier []byte) (FetchPaymentRow, error) {
	row := q.db.QueryRowContext(ctx, fetchPayment, paymentIdentifier)
	var i FetchPaymentRow
	err := row.Scan(
		&i.Payment.ID,
		&i.Payment.IntentID,
		&i.Payment.AmountMsat,
		&i.Payment.CreatedAt,
		&i.Payment.PaymentIdentifier,
		&i.Payment.FailReason,
		&i.IntentType,
		&i.IntentPayload,
	)
	return i, err
}

const fetchPaymentLevelFirstHopCustomRecords = `-- name: FetchPaymentLevelFirstHopCustomRecords :many
SELECT
    l.id,
    l.payment_id,
    l.key,
    l.value
FROM payment_first_hop_custom_records l
WHERE l.payment_id = $1
`

func (q *Queries) FetchPaymentLevelFirstHopCustomRecords(ctx context.Context, paymentID int64) ([]PaymentFirstHopCustomRecord, error) {
	rows, err := q.db.QueryContext(ctx, fetchPaymentLevelFirstHopCustomRecords, paymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentFirstHopCustomRecord
	for rows.Next() {
		var i PaymentFirstHopCustomRecord
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.Key,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPaymentsByIDs = `-- name: FetchPaymentsByIDs :many
SELECT
    p.id, p.intent_id, p.amount_msat, p.created_at, p.payment_identifier, p.fail_reason,
    i.intent_type AS "intent_type",
    i.intent_payload AS "intent_payload"
FROM payments p
LEFT JOIN payment_intents i ON i.id = p.intent_id
WHERE p.id IN (/*SLICE:payment_ids*/?)
`

type FetchPaymentsByIDsRow struct {
	Payment       Payment
	IntentType    sql.NullInt16
	IntentPayload []byte
}

func (q *Queries) FetchPaymentsByIDs(ctx context.Context, paymentIds []int64) ([]FetchPaymentsByIDsRow, error) {
	query := fetchPaymentsByIDs
	var queryParams []interface{}
	if len(paymentIds) > 0 {
		for _, v := range paymentIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:payment_ids*/?", makeQueryParams(len(queryParams), len(paymentIds)), 1)
	} else {
		query = strings.Replace(query, "/*SLICE:payment_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchPaymentsByIDsRow
	for rows.Next() {
		var i FetchPaymentsByIDsRow
		if err := rows.Scan(
			&i.Payment.ID,
			&i.Payment.IntentID,
			&i.Payment.AmountMsat,
			&i.Payment.CreatedAt,
			&i.Payment.PaymentIdentifier,
			&i.Payment.FailReason,
			&i.IntentType,
			&i.IntentPayload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchRouteLevelFirstHopCustomRecords = `-- name: FetchRouteLevelFirstHopCustomRecords :many
SELECT
    l.id,
    l.htlc_attempt_index,
    l.key,
    l.value
FROM payment_attempt_first_hop_custom_records l
WHERE l.htlc_attempt_index IN (/*SLICE:htlc_attempt_indices*/?)
`

func (q *Queries) FetchRouteLevelFirstHopCustomRecords(ctx context.Context, htlcAttemptIndices []int64) ([]PaymentAttemptFirstHopCustomRecord, error) {
	query := fetchRouteLevelFirstHopCustomRecords
	var queryParams []interface{}
	if len(htlcAttemptIndices) > 0 {
		for _, v := range htlcAttemptIndices {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:htlc_attempt_indices*/?", makeQueryParams(len(queryParams), len(htlcAttemptIndices)), 1)
	} else {
		query = strings.Replace(query, "/*SLICE:htlc_attempt_indices*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentAttemptFirstHopCustomRecord
	for rows.Next() {
		var i PaymentAttemptFirstHopCustomRecord
		if err := rows.Scan(
			&i.ID,
			&i.HtlcAttemptIndex,
			&i.Key,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const filterPayments = `-- name: FilterPayments :many
/* ─────────────────────────────────────────────
   fetch queries
   ─────────────────────────────────────────────
*/

SELECT
    p.id, p.intent_id, p.amount_msat, p.created_at, p.payment_identifier, p.fail_reason,
    i.intent_type AS "intent_type",
    i.intent_payload AS "intent_payload"
FROM payments p
LEFT JOIN payment_intents i ON i.id = p.intent_id
WHERE (
    p.id > $1 OR
    $1 IS NULL
) AND (
    p.id < $2 OR
    $2 IS NULL
) AND (
    p.created_at >= $3 OR
    $3 IS NULL
) AND (
    p.created_at <= $4 OR
    $4 IS NULL
) AND (
    i.intent_type = $5 OR
    $5 IS NULL OR i.intent_type IS NULL
)
ORDER BY
    CASE WHEN $6 = false OR $6 IS NULL THEN p.id END ASC,
    CASE WHEN $6 = true THEN p.id END DESC
LIMIT $7
`

type FilterPaymentsParams struct {
	IndexOffsetGet sql.NullInt64
	IndexOffsetLet sql.NullInt64
	CreatedAfter   sql.NullTime
	CreatedBefore  sql.NullTime
	IntentType     sql.NullInt16
	Reverse        interface{}
	NumLimit       int32
}

type FilterPaymentsRow struct {
	Payment       Payment
	IntentType    sql.NullInt16
	IntentPayload []byte
}

func (q *Queries) FilterPayments(ctx context.Context, arg FilterPaymentsParams) ([]FilterPaymentsRow, error) {
	rows, err := q.db.QueryContext(ctx, filterPayments,
		arg.IndexOffsetGet,
		arg.IndexOffsetLet,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.IntentType,
		arg.Reverse,
		arg.NumLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterPaymentsRow
	for rows.Next() {
		var i FilterPaymentsRow
		if err := rows.Scan(
			&i.Payment.ID,
			&i.Payment.IntentID,
			&i.Payment.AmountMsat,
			&i.Payment.CreatedAt,
			&i.Payment.PaymentIdentifier,
			&i.Payment.FailReason,
			&i.IntentType,
			&i.IntentPayload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
